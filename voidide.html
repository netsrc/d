<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VOID — Browser IDE v0.21 Alpha</title>

<!-- Monaco Editor -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
<!-- xterm.js -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&family=Rajdhani:wght@500;600;700&display=swap');

:root {
  --bg0:       #080b0f;
  --bg1:       #0d1117;
  --bg2:       #111820;
  --bg3:       #161f2b;
  --bg4:       #1c2736;
  --border:    #1e2d3d;
  --border2:   #253545;
  --accent:    #00d4ff;
  --accent-dim:#0099bb;
  --accent-rgb:0,212,255;
  --green:     #3ddc84;
  --yellow:    #f0c040;
  --red:       #ff4c6a;
  --purple:    #c792ea;
  --orange:    #ffb347;
  --cyan:      #00d4ff;
  --text:      #cdd9e5;
  --text-dim:  #768a9e;
  --text-faint:#3d5266;
  --tab-h:     32px;
  --sidebar-w: 220px;
  --status-h:  26px;
  --title-h:   38px;
  --panel-h:   200px;
  --glow:      0 0 12px rgba(var(--accent-rgb),0.3);
  --glow-sm:   0 0 6px rgba(var(--accent-rgb),0.2);
  --glow-lg:   0 0 28px rgba(var(--accent-rgb),0.45);
  --font-ui:   'JetBrains Mono', monospace;
  --sb-bg:     var(--bg1);
  --sb-fg:     var(--text-dim);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; background: var(--bg0); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 13px; }

/* ── Scanlines ── */
body::after {
  content: ''; position: fixed; inset: 0; pointer-events: none; z-index: 10000;
  background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.03) 3px, rgba(0,0,0,0.03) 4px);
}

/* ══════════════════════════════════════════
   TITLEBAR
══════════════════════════════════════════ */
#titlebar {
  height: var(--title-h);
  background: var(--bg1);
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center;
  padding: 0 10px; gap: 10px;
  user-select: none; flex-shrink: 0;
  position: relative; z-index: 200;
}

.title-logo {
  font-family: 'Rajdhani', sans-serif;
  font-weight: 700; font-size: 17px;
  color: var(--accent); letter-spacing: 0.18em;
  text-shadow: var(--glow);
  flex-shrink: 0;
}
.title-logo em { color: var(--text-faint); font-style: normal; font-size: 10px; margin-left: 6px; letter-spacing: 0; vertical-align: middle; }

.title-menu { display: flex; gap: 1px; margin-left: 6px; }
.menu-item {
  font-size: 12px; padding: 3px 9px; border-radius: 3px;
  color: var(--text-dim); cursor: pointer; transition: all 0.1s;
  position: relative;
}
.menu-item:hover { background: var(--bg3); color: var(--text); }

/* dropdown */
.menu-dropdown {
  display: none; position: absolute; top: 100%; left: 0; min-width: 190px;
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 5px; padding: 4px; z-index: 9999;
  box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  margin-top: 2px;
}
.menu-item:hover .menu-dropdown,
.menu-item.open .menu-dropdown { display: block; }
.menu-dropdown hr { border: none; border-top: 1px solid var(--border); margin: 3px 0; }
.dd-item {
  display: flex; align-items: center; justify-content: space-between;
  padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 11px;
  color: var(--text); transition: background 0.1s; gap: 20px;
}
.dd-item:hover { background: var(--bg4); color: var(--accent); }
.dd-item .kbd { color: var(--text-faint); font-size: 10px; white-space: nowrap; }

.title-actions { margin-left: auto; display: flex; gap: 5px; align-items: center; }
.tbtn {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  padding: 4px 11px; border-radius: 3px; cursor: pointer; transition: all 0.15s;
  border: 1px solid; letter-spacing: 0.04em;
}
.tbtn-run  { background: var(--green);  color: #000; border-color: var(--green);  font-weight: 700; }
.tbtn-run:hover  { box-shadow: 0 0 14px rgba(61,220,132,0.45); transform: translateY(-1px); }
.tbtn-save { background: transparent; color: var(--accent); border-color: var(--accent-dim); }
.tbtn-save:hover { background: rgba(var(--accent-rgb),0.08); box-shadow: var(--glow-sm); }
.tbtn-popout { background: transparent; color: var(--purple); border-color: rgba(199,146,234,0.4); }
.tbtn-popout:hover { background: rgba(199,146,234,0.08); box-shadow: 0 0 6px rgba(199,146,234,0.3); }
.tbtn-dir { background: transparent; color: var(--yellow, #e5c07b); border-color: rgba(229,192,123,0.4); }
.tbtn-dir:hover { background: rgba(229,192,123,0.08); }
.tbtn-dir.dir-set { color: var(--green); border-color: var(--green); }

/* ══════════════════════════════════════════
   MAIN LAYOUT
══════════════════════════════════════════ */
#app {
  display: flex;
  height: calc(100vh - var(--title-h) - var(--status-h));
  margin-bottom: var(--status-h);
}

/* ══════════════════════════════════════════
   ACTIVITY BAR
══════════════════════════════════════════ */
#activitybar {
  width: 44px; background: var(--bg1); border-right: 1px solid var(--border);
  display: flex; flex-direction: column; align-items: center;
  padding: 8px 0; gap: 4px; flex-shrink: 0; z-index: 100;
}
.act-btn {
  width: 34px; height: 34px; border-radius: 6px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  color: var(--text-faint); font-size: 17px; transition: all 0.15s;
  position: relative;
}
.act-btn:hover   { color: var(--text); background: var(--bg3); }
.act-btn.active  { color: var(--accent); background: rgba(0,212,255,0.08); }
.act-btn.active::before {
  content: ''; position: absolute; left: -1px; top: 6px; bottom: 6px;
  width: 2px; border-radius: 0 2px 2px 0; background: var(--accent);
  box-shadow: var(--glow-sm);
}

/* ══════════════════════════════════════════
   SIDEBAR
══════════════════════════════════════════ */
#sidebar {
  width: var(--sidebar-w); background: var(--bg1);
  border-right: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0;
  overflow: hidden;
}

.sidebar-header {
  padding: 8px 12px 6px; font-size: 10px; font-weight: 600;
  color: var(--text-faint); letter-spacing: 0.12em; text-transform: uppercase;
  display: flex; align-items: center; justify-content: space-between;
  user-select: none; flex-shrink: 0;
}
.sidebar-actions { display: flex; gap: 2px; }
.sact {
  width: 22px; height: 22px; border-radius: 4px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  color: var(--text-faint); font-size: 14px; transition: all 0.1s;
}
.sact:hover { color: var(--text); background: var(--bg3); }

/* File tree */
#filetree {
  flex: 1; overflow-y: auto; overflow-x: hidden;
  padding: 4px 0;
}
#filetree::-webkit-scrollbar { width: 4px; }
#filetree::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

.tree-item {
  display: flex; align-items: center; gap: 5px;
  padding: 3px 0 3px 0; cursor: pointer;
  font-size: 12px; color: var(--text-dim);
  user-select: none; position: relative;
  transition: color 0.1s;
  white-space: nowrap; overflow: hidden;
}
.tree-item:hover { color: var(--text); background: var(--bg3); }
.tree-item.selected { color: var(--text); background: var(--bg4); }
.tree-item.selected::before {
  content: ''; position: absolute; left: 0; top: 0; bottom: 0;
  width: 1px; background: var(--accent);
}

.tree-indent { display: inline-block; width: 16px; flex-shrink: 0; }
.tree-icon { flex-shrink: 0; font-size: 13px; }
.tree-name { overflow: hidden; text-overflow: ellipsis; flex: 1; padding-right: 6px; }
.tree-name.editing {
  background: var(--bg0); border: 1px solid var(--accent);
  border-radius: 2px; outline: none; color: var(--text);
  font-family: 'JetBrains Mono', monospace; font-size: 12px;
  padding: 0 4px; width: 130px;
}

/* ══════════════════════════════════════════
   EDITOR AREA
══════════════════════════════════════════ */
#editor-area {
  flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0;
}

/* Tabs */
#tabs-bar {
  height: var(--tab-h); background: var(--bg1);
  border-bottom: 1px solid var(--border);
  display: flex; align-items: flex-end; overflow-x: auto;
  overflow-y: hidden; flex-shrink: 0;
}
#tabs-bar::-webkit-scrollbar { height: 2px; }
#tabs-bar::-webkit-scrollbar-thumb { background: var(--border2); }

.tab {
  display: flex; align-items: center; gap: 6px;
  padding: 0 14px; height: var(--tab-h); flex-shrink: 0;
  border-right: 1px solid var(--border);
  font-size: 12px; color: var(--text-dim); cursor: pointer;
  position: relative; transition: color 0.1s;
  max-width: 180px; overflow: hidden;
  background: var(--bg1);
}
.tab:hover { color: var(--text); background: var(--bg2); }
.tab.active {
  color: var(--text); background: var(--bg0);
  border-top: 1px solid var(--accent);
  margin-top: 1px;
}
.tab-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
.tab-icon { font-size: 12px; flex-shrink: 0; }
.tab-close {
  width: 16px; height: 16px; border-radius: 3px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; color: var(--text-faint); transition: all 0.1s;
  margin-left: auto;
}
.tab-close:hover { color: var(--red); background: rgba(255,76,106,0.12); }
.tab-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--accent); flex-shrink: 0; }

/* Monaco container */
#monaco-container {
  flex: 1; min-height: 0; position: relative;
}
#empty-state {
  position: absolute; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 12px;
  color: var(--text-faint); pointer-events: none;
}
.empty-logo {
  font-family: 'Rajdhani', sans-serif; font-size: 48px; font-weight: 700;
  color: var(--border2); letter-spacing: 0.2em; line-height: 1;
}
.empty-sub { font-size: 11px; letter-spacing: 0.08em; }

/* ══════════════════════════════════════════
   BOTTOM PANEL
══════════════════════════════════════════ */
#panel-area {
  height: var(--panel-h); background: var(--bg1);
  border-top: 1px solid var(--border);
  display: flex; flex-direction: column; flex-shrink: 0;
}

#panel-tabs {
  display: flex; align-items: center;
  background: var(--bg2); border-bottom: 1px solid var(--border);
  padding: 0 8px; flex-shrink: 0; user-select: none;
}
.ptab {
  font-size: 11px; padding: 5px 12px; cursor: pointer;
  color: var(--text-faint); border-bottom: 2px solid transparent;
  transition: all 0.15s; letter-spacing: 0.04em;
}
.ptab:hover  { color: var(--text); }
.ptab.active { color: var(--accent); border-color: var(--accent); }

.ptab-actions { margin-left: auto; display: flex; gap: 4px; }
.ptab-btn {
  font-size: 11px; padding: 2px 8px; border-radius: 3px;
  cursor: pointer; border: 1px solid var(--border); background: transparent;
  color: var(--text-faint); font-family: 'JetBrains Mono', monospace; transition: all 0.1s;
}
.ptab-btn:hover { color: var(--text); border-color: var(--border2); }
.ptab-btn.live-on {
  color: var(--green); border-color: var(--green);
  background: rgba(61,220,132,0.08);
  animation: live-pulse 2s ease-in-out infinite;
}
@keyframes live-pulse {
  0%,100% { box-shadow: 0 0 6px rgba(61,220,132,0.2); }
  50%      { box-shadow: 0 0 14px rgba(61,220,132,0.5); }
}
.ptab-btn:hover { color: var(--text); border-color: var(--border2); }

/* Panel resize handle */
#panel-resize {
  height: 4px; cursor: ns-resize; flex-shrink: 0;
  background: transparent; transition: background 0.15s;
  position: relative; z-index: 10;
}
#panel-resize:hover, #panel-resize.dragging { background: var(--accent); }

#panel-content { flex: 1; overflow: hidden; min-height: 0; }

/* Terminal / output views */
.panel-view { display: none; height: 100%; flex-direction: column; }
.panel-view.active { display: flex; }

#terminal-output {
  flex: 1; overflow-y: auto; padding: 8px 14px;
  font-size: 11.5px; line-height: 1.8; background: var(--bg0);
}
#terminal-output::-webkit-scrollbar { width: 4px; }
#terminal-output::-webkit-scrollbar-thumb { background: var(--border2); }

.term-line { display: flex; gap: 10px; padding: 1px 0; animation: fadeIn 0.1s ease; }
@keyframes fadeIn { from{opacity:0;transform:translateX(-3px)}to{opacity:1;transform:none} }
.term-ts   { color: var(--text-faint); font-size: 10px; flex-shrink: 0; padding-top: 2px; min-width: 58px; }
.term-tag  { font-size: 10px; font-weight: 700; flex-shrink: 0; min-width: 46px; letter-spacing: 0.06em; padding-top: 2px; }
.term-tag.log   { color: #60a5fa; }
.term-tag.info  { color: var(--green); }
.term-tag.warn  { color: var(--yellow); }
.term-tag.error { color: var(--red); }
.term-tag.sys   { color: var(--accent); }
.term-msg { color: var(--text); word-break: break-all; flex: 1; }
.term-msg.error { color: var(--red); }
.term-msg.warn  { color: var(--yellow); }

/* Preview iframe */
#preview-frame {
  width: 100%; height: 100%; border: none; background: #fff;
  display: block;
}

/* ══════════════════════════════════════════
   SHELL PANEL — xterm.js powered ZSH
══════════════════════════════════════════ */
#view-shell {
  flex-direction: column !important;
  background: #0d1117;
  overflow: hidden;
}
#xterm-container {
  flex: 1;
  min-height: 0;
  padding: 4px 6px;
  background: #0d1117;
  overflow: hidden;
}
#xterm-container .xterm {
  height: 100%;
}
#xterm-container .xterm-viewport {
  background-color: transparent !important;
  overflow-y: auto !important;
}
#xterm-container .xterm-viewport::-webkit-scrollbar { width: 4px; }
#xterm-container .xterm-viewport::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
#xterm-container .xterm-screen { background: transparent; }

/* ══════════════════════════════════════════
   HEX EDITOR PANEL
══════════════════════════════════════════ */
#view-hex {
  flex-direction: column !important;
  background: var(--bg0);
  overflow: hidden;
  font-family: 'JetBrains Mono', monospace;
}
#hex-toolbar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 5px 12px; background: var(--bg2);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0; gap: 8px; font-size: 11px;
}
#hex-filename { color: var(--text-dim); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
#hex-filename code { color: var(--cyan); background: var(--bg3); padding: 1px 4px; border-radius: 3px; }
#hex-toolbar-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
#hex-open-btn {
  cursor: pointer; color: var(--accent); background: var(--bg3);
  border: 1px solid var(--border2); border-radius: 4px;
  padding: 2px 8px; font-size: 10px; font-family: 'JetBrains Mono', monospace;
  white-space: nowrap;
}
#hex-open-btn:hover { border-color: var(--accent); }
.hex-btn {
  background: var(--bg3); border: 1px solid var(--border2); border-radius: 4px;
  color: var(--text-dim); font-size: 10px; font-family: 'JetBrains Mono', monospace;
  padding: 2px 8px; cursor: pointer; white-space: nowrap;
}
.hex-btn:hover { color: var(--text); border-color: var(--border2); }
#hex-offset-display { color: var(--accent); font-size: 10px; font-family: 'JetBrains Mono', monospace; }
#hex-sel-display { color: var(--yellow); font-size: 10px; font-family: 'JetBrains Mono', monospace; min-width: 100px; }

#hex-main {
  flex: 1; display: flex; overflow: hidden; min-height: 0;
  font-size: 12px; line-height: 1.6; cursor: default;
  user-select: none;
}
#hex-addr-col {
  padding: 6px 10px; background: var(--bg1);
  border-right: 1px solid var(--border);
  overflow: hidden; flex-shrink: 0; white-space: pre;
  color: var(--text-faint); font-size: 11px;
}
#hex-bytes-col {
  padding: 6px 12px; overflow: auto; flex: 1;
  white-space: pre; outline: none; min-width: 0;
  color: var(--text);
}
#hex-bytes-col::-webkit-scrollbar { width: 5px; height: 5px; }
#hex-bytes-col::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 3px; }
#hex-ascii-col {
  padding: 6px 10px; background: var(--bg1);
  border-left: 1px solid var(--border);
  overflow: hidden; flex-shrink: 0; white-space: pre;
  color: var(--text-dim); font-size: 12px;
}
.hex-row { display: flex; }
.hex-byte {
  display: inline-block; width: 2ch; margin-right: 6px; cursor: pointer;
  border-radius: 2px; transition: background 0.05s;
}
.hex-byte:nth-child(8n) { margin-right: 14px; } /* group separator */
.hex-byte.sel { background: rgba(0,212,255,0.25); color: var(--accent); }
.hex-byte.sel-range { background: rgba(0,212,255,0.12); }
.hex-byte.cursor { background: var(--accent); color: var(--bg0) !important; border-radius: 2px; }
.hex-byte.modified { color: var(--yellow); }
.hex-byte.zero { color: var(--text-faint); }
.hex-byte.nonprint { color: var(--purple); }
.hex-char.sel { background: rgba(0,212,255,0.25); color: var(--accent); }
.hex-char.cursor { background: var(--accent); color: var(--bg0); }
.hex-char.modified { color: var(--yellow); }
.hex-row:hover .hex-byte:not(.cursor) { background: rgba(255,255,255,0.03); }

#hex-statusbar {
  display: flex; justify-content: space-between; align-items: center;
  padding: 3px 12px; background: var(--bg2); border-top: 1px solid var(--border);
  flex-shrink: 0; font-size: 10px; color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
}
#hex-status-right { color: var(--text-faint); }

/* ══════════════════════════════════════════
   PROXY PANEL
══════════════════════════════════════════ */
#view-proxy { display: none; flex-direction: column; height: 100%; background: var(--bg1); }
#view-proxy.active { display: flex; }
#proxy-toolbar {
  display: flex; align-items: center; gap: 8px; padding: 6px 10px;
  background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0;
}
#proxy-toolbar .proxy-title {
  font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 13px;
  color: var(--accent); letter-spacing: 0.1em; margin-right: 4px;
}
#proxy-status-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--text-faint); flex-shrink: 0; transition: background 0.3s;
}
#proxy-status-dot.connected { background: var(--green); box-shadow: 0 0 6px rgba(61,220,132,0.6); }
#proxy-status-dot.connecting { background: var(--yellow); animation: proxyPulse 0.8s infinite; }
#proxy-status-dot.error { background: var(--red); }
@keyframes proxyPulse { 0%,100%{opacity:1} 50%{opacity:0.3} }
#proxy-status-text { font-size: 11px; color: var(--text-dim); flex: 1; }
.proxy-tbtn {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  padding: 3px 10px; border-radius: 3px; cursor: pointer;
  border: 1px solid; transition: all 0.15s; background: transparent;
}
.proxy-tbtn-connect { color: var(--green); border-color: var(--green); }
.proxy-tbtn-connect:hover { background: rgba(61,220,132,0.1); }
.proxy-tbtn-disconnect { color: var(--red); border-color: var(--red); }
.proxy-tbtn-disconnect:hover { background: rgba(255,76,106,0.1); }
.proxy-tbtn-test { color: var(--accent); border-color: var(--accent-dim); }
.proxy-tbtn-test:hover { background: rgba(var(--accent-rgb),0.08); }

#proxy-body { display: flex; flex: 1; min-height: 0; }

#proxy-config {
  width: 260px; flex-shrink: 0; border-right: 1px solid var(--border);
  display: flex; flex-direction: column; overflow-y: auto; padding: 10px;
  gap: 10px; background: var(--bg1);
}
#proxy-config::-webkit-scrollbar { width: 4px; }
#proxy-config::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

.proxy-section-title {
  font-size: 9px; font-weight: 600; color: var(--text-faint);
  letter-spacing: 0.12em; text-transform: uppercase;
  padding-bottom: 4px; border-bottom: 1px solid var(--border);
}
.proxy-field { display: flex; flex-direction: column; gap: 3px; }
.proxy-field label { font-size: 10px; color: var(--text-dim); }
.proxy-field input, .proxy-field select {
  background: var(--bg3); border: 1px solid var(--border); color: var(--text);
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  padding: 4px 7px; border-radius: 3px; outline: none; width: 100%;
}
.proxy-field input:focus, .proxy-field select:focus { border-color: var(--accent); }
.proxy-field select option { background: var(--bg2); }

.proxy-mode-tabs { display: flex; gap: 2px; }
.proxy-mode-tab {
  flex: 1; padding: 4px; text-align: center; font-size: 10px;
  border: 1px solid var(--border); border-radius: 3px; cursor: pointer;
  color: var(--text-dim); background: var(--bg3); transition: all 0.1s;
}
.proxy-mode-tab.active { color: var(--accent); border-color: var(--accent); background: rgba(var(--accent-rgb),0.08); }

#proxy-log-panel {
  flex: 1; display: flex; flex-direction: column; min-width: 0;
}
#proxy-log-toolbar {
  display: flex; align-items: center; padding: 4px 10px; gap: 6px;
  background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0;
  font-size: 10px; color: var(--text-dim);
}
#proxy-log {
  flex: 1; overflow-y: auto; padding: 6px 10px;
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  background: var(--bg0); line-height: 1.6;
}
#proxy-log::-webkit-scrollbar { width: 4px; }
#proxy-log::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
.plog-sys  { color: var(--text-dim); }
.plog-ok   { color: var(--green); }
.plog-warn { color: var(--yellow); }
.plog-err  { color: var(--red); }
.plog-tx   { color: var(--cyan); }
.plog-rx   { color: var(--purple); }
.plog-ts   { color: var(--text-faint); margin-right: 6px; }

#proxy-stats {
  display: flex; gap: 16px; padding: 4px 10px;
  background: var(--bg2); border-top: 1px solid var(--border);
  font-size: 10px; color: var(--text-dim); flex-shrink: 0;
}
#proxy-stats span { color: var(--text); }
/* ══════════════════════════════════════════
   STATUS BAR — rich bottom bar
══════════════════════════════════════════ */
/* ── Status bar table ── */
#statusbar {
  position: fixed; bottom: 0; left: 0; right: 0;
  height: var(--status-h);
  background: var(--accent);
  border-top: 1px solid rgba(255,255,255,0.2);
  font-size: 10.5px; color: rgba(0,0,0,0.82);
  font-family: 'JetBrains Mono', monospace; font-weight: 500;
  user-select: none; z-index: 150;
  border-collapse: collapse; width: 100%;
}
#statusbar.error-mode { background: var(--red); }
#statusbar td {
  padding: 0 10px;
  white-space: nowrap;
  border-right: 1px solid rgba(0,0,0,0.15);
  height: var(--status-h);
  vertical-align: middle;
  cursor: default;
}
#statusbar td:last-child { border-right: none; }
#statusbar td:hover { background: rgba(0,0,0,0.12); cursor: pointer; }
#statusbar .sb-spacer { width: 100%; border-right: none; cursor: default; }
#statusbar .sb-spacer:hover { background: none; cursor: default; }

/* Left branch cell */
#sb-branch-area { background: rgba(0,0,0,0.25); padding: 0 12px; cursor: pointer; }
#sb-branch-area:hover { background: rgba(0,0,0,0.38) !important; }
#sb-dot { display: inline-block; width: 7px; height: 7px; border-radius: 50%; background: rgba(0,0,0,0.4); margin-right: 5px; vertical-align: middle; }
#sb-dot.on { background: rgba(0,0,0,0.75); }
#sb-branch { font-weight: 700; letter-spacing: 0.04em; }

/* Storage cell */
#sb-storage { background: rgba(0,0,0,0.2); position: relative; border-left: 1px solid rgba(0,0,0,0.2); }
#sb-storage:hover { background: rgba(0,0,0,0.32) !important; }
#sb-storage-mode { font-weight: 600; }
#sb-storage-popup {
  display: none; position: absolute; bottom: calc(100% + 6px); right: 0;
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 6px; padding: 5px; min-width: 230px;
  box-shadow: 0 -10px 35px rgba(0,0,0,0.6); z-index: 9999;
  color: var(--text); font-size: 11px;
}
#sb-storage.open #sb-storage-popup { display: block; }

/* Notif cell */
#sb-notif { background: rgba(0,0,0,0.2); border-left: 1px solid rgba(0,0,0,0.15); }
#sb-notif:hover { background: rgba(0,0,0,0.3) !important; }
#sb-notif-badge {
  display: inline-block;
  background: rgba(0,0,0,0.4); border-radius: 8px;
  padding: 0 5px; font-size: 9px; font-weight: 700; min-width: 16px; text-align: center;
  vertical-align: middle; margin-left: 3px;
}

/* ══════════════════════════════════════════
   CONTEXT MENU
══════════════════════════════════════════ */
#ctx-menu {
  display: none; position: fixed; z-index: 9999;
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 5px; padding: 4px; min-width: 160px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.6);
}
#ctx-menu.visible { display: block; }
.ctx-item {
  padding: 5px 10px; border-radius: 3px; cursor: pointer;
  font-size: 11px; color: var(--text); display: flex;
  align-items: center; gap: 8px; transition: background 0.1s;
}
.ctx-item:hover { background: var(--bg4); color: var(--accent); }
.ctx-item.danger:hover { color: var(--red); }
.ctx-item .ctx-icon { font-size: 13px; width: 16px; text-align: center; }
#ctx-menu hr { border: none; border-top: 1px solid var(--border); margin: 3px 0; }

/* ══════════════════════════════════════════
   DIALOG / MODAL
══════════════════════════════════════════ */
#dialog-overlay {
  display: none; position: fixed; inset: 0; z-index: 9998;
  background: rgba(0,0,0,0.6); backdrop-filter: blur(2px);
  align-items: center; justify-content: center;
}
#dialog-overlay.visible { display: flex; }
#dialog {
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 6px; padding: 20px; min-width: 320px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.7);
}
#dialog h3 { font-family: 'Rajdhani', sans-serif; font-size: 15px; color: var(--accent); margin-bottom: 12px; letter-spacing: 0.05em; }
#dialog input, #dialog select {
  width: 100%; background: var(--bg0); border: 1px solid var(--border2);
  color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 12px;
  padding: 7px 10px; border-radius: 3px; outline: none; margin-bottom: 12px;
  caret-color: var(--accent);
}
#dialog input:focus, #dialog select:focus { border-color: var(--accent); }
#dialog select option { background: var(--bg2); }
.dialog-btns { display: flex; gap: 8px; justify-content: flex-end; }
.dbtn {
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  padding: 6px 14px; border-radius: 3px; cursor: pointer; border: 1px solid; transition: all 0.15s;
}
.dbtn-ok     { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
.dbtn-ok:hover { box-shadow: var(--glow); }
.dbtn-cancel { background: transparent; color: var(--text-dim); border-color: var(--border2); }
.dbtn-cancel:hover { color: var(--text); }

/* ══════════════════════════════════════════
   SIDEBAR RESIZE
══════════════════════════════════════════ */
#sidebar-resize {
  width: 4px; cursor: ew-resize; flex-shrink: 0;
  background: transparent; transition: background 0.15s; z-index: 50;
}
#sidebar-resize:hover, #sidebar-resize.dragging { background: var(--accent); }

/* file icon colors */
.ic-html { color: #e44d26; }
.ic-css  { color: #264de4; }
.ic-js   { color: #f7df1e; }
.ic-ts   { color: #3178c6; }
.ic-json { color: #89ca78; }
.ic-md   { color: #a0c4ff; }
.ic-txt  { color: var(--text-dim); }
.ic-dir  { color: var(--yellow); }
.ic-img  { color: var(--purple); }
.ic-xml  { color: var(--orange); }

/* ══════════════════════════════════════════
   ZIP DRAG-DROP OVERLAY
══════════════════════════════════════════ */
#zip-drop-overlay {
  display: none; position: fixed; inset: 0; z-index: 99990;
  background: rgba(0,8,16,0.88); backdrop-filter: blur(4px);
  align-items: center; justify-content: center; pointer-events: none;
}
#zip-drop-overlay.active { display: flex; pointer-events: all; animation: dropFadeIn 0.15s ease; }
@keyframes dropFadeIn { from{opacity:0} to{opacity:1} }
#zip-drop-inner {
  border: 2px dashed var(--accent); border-radius: 12px; padding: 60px 80px; text-align: center;
  box-shadow: 0 0 60px rgba(0,212,255,0.15), inset 0 0 40px rgba(0,212,255,0.04);
  animation: dropPulse 1.5s ease-in-out infinite;
}
@keyframes dropPulse {
  0%,100% { border-color: var(--accent); box-shadow: 0 0 40px rgba(0,212,255,0.15); }
  50%      { border-color: #00ffcc;      box-shadow: 0 0 60px rgba(0,212,255,0.3);  }
}
#zip-drop-overlay.reject #zip-drop-inner { border-color: var(--red); box-shadow: 0 0 40px rgba(255,76,106,0.25); animation: none; }
#zip-drop-overlay.reject #zip-drop-title { color: var(--red); }
#zip-drop-overlay.reject #zip-drop-sub   { color: var(--red); opacity: 0.6; }
#zip-drop-icon  { font-size: 64px; margin-bottom: 16px; }
#zip-drop-title { font-family: 'Rajdhani', sans-serif; font-size: 24px; font-weight: 700;
                  color: var(--accent); letter-spacing: 0.08em; margin-bottom: 8px; }
#zip-drop-sub   { font-size: 12px; color: var(--text-dim); letter-spacing: 0.05em; }
/* ══════════════════════════════════════════
   ZIP PROGRESS MODAL
══════════════════════════════════════════ */
#zip-modal-overlay {
  display: none; position: fixed; inset: 0; z-index: 99991;
  background: rgba(0,0,0,0.75); backdrop-filter: blur(3px);
  align-items: center; justify-content: center;
}
#zip-modal-overlay.visible { display: flex; }
#zip-modal {
  background: var(--bg2); border: 1px solid var(--border2); border-radius: 8px;
  padding: 24px 28px; width: 420px; max-width: 90vw;
  box-shadow: 0 24px 80px rgba(0,0,0,0.7); animation: modalSlide 0.2s ease;
}
@keyframes modalSlide { from{opacity:0;transform:translateY(-12px)} to{opacity:1;transform:none} }
#zip-modal-title {
  font-family: 'Rajdhani', sans-serif; font-size: 16px; font-weight: 700;
  color: var(--accent); letter-spacing: 0.08em; margin-bottom: 6px;
  display: flex; align-items: center; gap: 8px;
}
#zip-modal-filename { font-size: 11px; color: var(--text-dim); margin-bottom: 16px;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
#zip-progress-track { height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; margin-bottom: 8px; }
#zip-progress-bar   { height: 100%; width: 0%; background: var(--accent);
  border-radius: 2px; transition: width 0.15s ease; box-shadow: 0 0 8px rgba(0,212,255,0.5); }
#zip-progress-label { font-size: 10px; color: var(--text-faint); letter-spacing: 0.06em; margin-bottom: 12px; min-height: 16px; }
#zip-file-list { max-height: 180px; overflow-y: auto; font-size: 10.5px; color: var(--text-dim);
  line-height: 1.9; border-top: 1px solid var(--border); padding-top: 10px; margin-top: 4px; }
#zip-file-list::-webkit-scrollbar { width: 3px; }
#zip-file-list::-webkit-scrollbar-thumb { background: var(--border2); }
.zfl-item { display: flex; align-items: center; gap: 7px; padding: 1px 0; }
.zfl-ok   { color: var(--green);  font-size: 11px; flex-shrink: 0; }
.zfl-skip { color: var(--yellow); font-size: 11px; flex-shrink: 0; }
.zfl-err  { color: var(--red);    font-size: 11px; flex-shrink: 0; }
.zfl-path { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
.zfl-size { color: var(--text-faint); flex-shrink: 0; font-size: 10px; }

/* ══════════════════════════════════════════
   STORAGE MODE SWITCHER
══════════════════════════════════════════ */
#storage-indicator {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 4px;
  background: var(--bg3); border: 1px solid var(--border);
  font-size: 10px; cursor: pointer; transition: all 0.15s;
}
#storage-indicator:hover { background: var(--bg4); border-color: var(--border2); }
#storage-icon { font-size: 12px; }
#storage-indicator {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 4px;
  background: var(--bg3); border: 1px solid var(--border);
  font-size: 10px; cursor: pointer; transition: all 0.15s;
  position: relative;
}
#storage-indicator:hover { background: var(--bg4); border-color: var(--border2); }
#storage-icon { font-size: 12px; }
#storage-label { color: var(--text-faint); letter-spacing: 0.06em; }
#storage-mode { color: var(--accent); font-weight: 700; letter-spacing: 0.05em; }
#storage-selector {
  display: none; position: absolute; top: calc(100% + 4px); right: 0;
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 5px; padding: 6px; min-width: 200px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.6); z-index: 1000;
}
#storage-selector.visible { display: block; }

/* Storage selector dropdown */
#storage-selector {
  display: none; position: absolute; top: calc(100% + 4px); right: 0;
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 5px; padding: 6px; min-width: 200px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.6); z-index: 1000;
}
#storage-selector.visible { display: block; }
.storage-option {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 10px; border-radius: 4px; cursor: pointer;
  transition: all 0.15s; margin-bottom: 4px;
}
.storage-option:hover { background: var(--bg4); }
.storage-option.active { background: rgba(var(--accent-rgb),0.1); border: 1px solid rgba(var(--accent-rgb),0.3); }
.storage-option-icon { font-size: 16px; }
.storage-option-text { flex: 1; }
.storage-option-name { font-size: 11px; color: var(--text); font-weight: 600; }
.storage-option-desc { font-size: 9px; color: var(--text-faint); margin-top: 2px; }
.storage-option-check { color: var(--accent); font-size: 14px; display: none; }
.storage-option.active .storage-option-check { display: block; }

/* ══════════════════════════════════════════
   SHARED FILES PANEL (File System Access API)
══════════════════════════════════════════ */
#sidebar-shared { height: 100%; display: flex; flex-direction: column; overflow: hidden; }
#shared-files-list {
  flex: 1; overflow-y: auto; padding: 4px 0;
  font-size: 11.5px;
}
#shared-files-list::-webkit-scrollbar { width: 4px; }
#shared-files-list::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
.shared-item {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 8px 4px 14px; cursor: pointer;
  color: var(--text-dim); transition: all 0.1s;
  white-space: nowrap; overflow: hidden;
  font-size: 11.5px;
}
.shared-item:hover { background: var(--bg3); color: var(--text); }
.shared-item.selected { background: var(--bg4); color: var(--text); border-left: 1px solid var(--accent); }
.shared-item .si-icon { font-size: 12px; flex-shrink: 0; }
.shared-item .si-name { overflow: hidden; text-overflow: ellipsis; flex: 1; }
.shared-item .si-badge {
  font-size: 9px; padding: 1px 4px; border-radius: 2px;
  background: rgba(61,220,132,0.15); color: var(--green); flex-shrink: 0;
}
.shared-item .si-badge.dirty {
  background: rgba(240,192,64,0.15); color: var(--yellow);
}
.shared-empty {
  padding: 20px 14px; text-align: center; color: var(--text-faint);
  font-size: 11px; line-height: 1.8;
}
.shared-actions {
  padding: 6px 8px; border-top: 1px solid var(--border);
  display: flex; gap: 4px; flex-wrap: wrap; flex-shrink: 0;
}
.shared-btn {
  font-size: 10px; padding: 4px 8px; border-radius: 3px; cursor: pointer;
  border: 1px solid var(--border2); background: transparent;
  color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
  transition: all 0.1s; white-space: nowrap;
}
.shared-btn:hover { color: var(--accent); border-color: var(--accent-dim); background: rgba(0,212,255,0.05); }
.shared-btn.primary { background: rgba(61,220,132,0.1); color: var(--green); border-color: rgba(61,220,132,0.3); }
.shared-btn.primary:hover { background: rgba(61,220,132,0.2); }
#shared-api-warning {
  margin: 8px; padding: 8px 10px; border-radius: 4px;
  background: rgba(240,192,64,0.08); border: 1px solid rgba(240,192,64,0.2);
  font-size: 10px; color: var(--yellow); line-height: 1.6; display: none;
}
.shared-dir-row {
  color: var(--text); cursor: pointer;
}
.shared-dir-row:hover { background: var(--bg3); }
.shared-dir-header {
  padding: 3px 10px; font-size: 9px; letter-spacing: 0.1em;
  color: var(--text-faint); text-transform: uppercase; user-select: none;
  display: flex; align-items: center; gap: 6px;
}
.shared-dir-header .sdi-path { color: var(--accent-dim); font-size: 9px; overflow: hidden; text-overflow: ellipsis; }

/* ══════════════════════════════════════════
   SETTINGS MODAL
══════════════════════════════════════════ */
#settings-overlay {
  display: none; position: fixed; inset: 0; z-index: 9999;
  background: rgba(0,0,0,0.7); backdrop-filter: blur(3px);
  align-items: center; justify-content: center;
}
#settings-overlay.visible { display: flex; }
#settings-modal {
  background: var(--bg2); border: 1px solid var(--border2);
  border-radius: 8px; width: 680px; max-width: 95vw; max-height: 85vh;
  display: flex; flex-direction: column;
  box-shadow: 0 24px 80px rgba(0,0,0,0.7);
  animation: modalSlide 0.2s ease;
}
#settings-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 20px; border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
#settings-header h2 {
  font-family: 'Rajdhani', sans-serif; font-size: 16px; font-weight: 700;
  color: var(--accent); letter-spacing: 0.1em;
}
#settings-close {
  width: 26px; height: 26px; border-radius: 4px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  color: var(--text-faint); font-size: 18px; transition: all 0.1s;
}
#settings-close:hover { color: var(--red); background: rgba(255,76,106,0.1); }
#settings-body { display: flex; flex: 1; overflow: hidden; }
#settings-nav {
  width: 160px; border-right: 1px solid var(--border);
  padding: 8px 0; flex-shrink: 0;
  overflow-y: auto;
}
.setnav-item {
  padding: 8px 16px; font-size: 11.5px; cursor: pointer;
  color: var(--text-dim); transition: all 0.1s;
  display: flex; align-items: center; gap: 8px;
}
.setnav-item:hover { color: var(--text); background: var(--bg3); }
.setnav-item.active { color: var(--accent); background: rgba(0,212,255,0.08);
  border-left: 2px solid var(--accent); padding-left: 14px; }
.setnav-icon { font-size: 14px; width: 18px; text-align: center; }
#settings-content { flex: 1; overflow-y: auto; padding: 20px 24px; }
#settings-content::-webkit-scrollbar { width: 4px; }
#settings-content::-webkit-scrollbar-thumb { background: var(--border2); }
.settings-section { display: none; }
.settings-section.active { display: block; }
.settings-section h3 {
  font-family: 'Rajdhani', sans-serif; font-size: 14px; color: var(--text);
  letter-spacing: 0.06em; margin-bottom: 16px; padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}
.set-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 0; border-bottom: 1px solid rgba(30,45,61,0.5);
  gap: 16px;
}
.set-label { flex: 1; }
.set-label-title { font-size: 12px; color: var(--text); }
.set-label-desc  { font-size: 10px; color: var(--text-faint); margin-top: 2px; }
.set-control { flex-shrink: 0; }
/* toggle switch */
.set-toggle {
  width: 38px; height: 20px; border-radius: 10px;
  background: var(--bg4); border: 1px solid var(--border2);
  cursor: pointer; position: relative; transition: all 0.2s; flex-shrink: 0;
}
.set-toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 14px; height: 14px; border-radius: 50%;
  background: var(--text-faint); transition: all 0.2s;
}
.set-toggle.on { background: rgba(var(--accent-rgb),0.2); border-color: var(--accent); }
.set-toggle.on::after { left: 20px; background: var(--accent); }
/* select */
.set-select {
  background: var(--bg0); border: 1px solid var(--border2);
  color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 11px;
  padding: 4px 8px; border-radius: 3px; outline: none; cursor: pointer;
  caret-color: var(--accent); min-width: 120px;
}
.set-select:focus { border-color: var(--accent); }
.set-select option { background: var(--bg2); }
/* range */
.set-range {
  -webkit-appearance: none; appearance: none;
  width: 120px; height: 4px; background: var(--bg4); border-radius: 2px;
  outline: none; cursor: pointer;
}
.set-range::-webkit-slider-thumb {
  -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
  background: var(--accent); cursor: pointer; box-shadow: 0 0 6px rgba(0,212,255,0.4);
}
.set-range-val { font-size: 11px; color: var(--accent); margin-left: 8px; min-width: 28px; }
.set-color-swatches { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
.set-swatch {
  width: 22px; height: 22px; border-radius: 4px; cursor: pointer;
  border: 2px solid transparent; transition: all 0.1s; flex-shrink: 0;
}
.set-swatch:hover { transform: scale(1.15); }
.set-swatch.selected { border-color: var(--text) !important; box-shadow: 0 0 8px rgba(255,255,255,0.2); }
.set-swatch-custom { width: 26px; height: 26px; border-radius: 4px; border: 2px solid var(--border2); overflow: hidden; }

/* Theme cards grid */
.set-theme-grid {
  display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;
  padding: 4px 0;
}
.set-theme-card {
  display: flex; flex-direction: column; align-items: center; gap: 5px;
  cursor: pointer; border-radius: 6px; padding: 6px 4px;
  border: 2px solid transparent; transition: all 0.15s;
}
.set-theme-card:hover { border-color: var(--border2); background: var(--bg3); }
.set-theme-card.selected { border-color: var(--accent); background: rgba(var(--accent-rgb),0.08); }
.set-theme-card span { font-size: 9px; color: var(--text-dim); text-align: center; white-space: nowrap; }
.set-theme-card.selected span { color: var(--accent); }
.stc-preview {
  width: 54px; height: 36px; border-radius: 4px; border: 1.5px solid;
  padding: 6px 7px; display: flex; flex-direction: column; justify-content: center;
}
#settings-footer {
  padding: 12px 20px; border-top: 1px solid var(--border);
  display: flex; justify-content: flex-end; gap: 8px; flex-shrink: 0;
}
.setbtn {
  font-family: 'JetBrains Mono', monospace; font-size: 11px;
  padding: 6px 16px; border-radius: 3px; cursor: pointer; border: 1px solid; transition: all 0.15s;
}
.setbtn-apply { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
.setbtn-apply:hover { box-shadow: var(--glow); }
.setbtn-reset { background: transparent; color: var(--text-dim); border-color: var(--border2); }
.setbtn-reset:hover { color: var(--text); }

/* fetch pre-runner log in terminal */
.term-tag.fetch { color: var(--purple); }

/* ══════════════════════════════════════════
   FILE PREVIEW (replaces Monaco for media/data files)
══════════════════════════════════════════ */
#file-preview {
  display:none; position:absolute; inset:0; background:var(--bg0);
  overflow:auto; flex-direction:column; align-items:center; padding:18px;
  z-index:5; box-sizing:border-box;
}
#file-preview.visible { display:flex; }
#file-preview::-webkit-scrollbar{width:5px}
#file-preview::-webkit-scrollbar-thumb{background:var(--border2);border-radius:3px}
.fp-toolbar{width:100%;display:flex;align-items:center;gap:8px;margin-bottom:14px;flex-shrink:0}
.fp-title{font-size:11px;color:var(--text-dim);flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.fp-btn{font-size:10px;padding:3px 9px;border-radius:3px;cursor:pointer;border:1px solid var(--border2);
  background:transparent;color:var(--text-dim);font-family:'JetBrains Mono',monospace;transition:all .1s}
.fp-btn:hover{color:var(--accent);border-color:var(--accent-dim)}
.fp-btn.ok{color:var(--green);border-color:rgba(61,220,132,.4);background:rgba(61,220,132,.05)}
.fp-img-wrap{display:flex;flex-direction:column;align-items:center;gap:10px;width:100%;max-width:100%}
.fp-img-wrap img{max-width:100%;max-height:58vh;object-fit:contain;border-radius:4px;
  border:1px solid var(--border);
  background:repeating-conic-gradient(#1c2736 0% 25%,#111820 0% 50%) 0 0/16px 16px}
.fp-info{font-size:10px;color:var(--text-faint);text-align:center}
.fp-media{width:100%;max-width:680px}
.fp-media audio,.fp-media video{width:100%;border-radius:6px;outline:none;background:var(--bg1)}
.fp-pdf{width:100%;height:70vh;border:none;border-radius:4px;background:#fff}
.fp-svg-wrap{width:100%;display:flex;flex-direction:column;align-items:center;gap:10px}
.fp-svg-wrap img.fp-svg{max-width:100%;max-height:55vh;border:1px solid var(--border);border-radius:4px;
  background:repeating-conic-gradient(#1c2736 0% 25%,#111820 0% 50%) 0 0/16px 16px;padding:8px}
.fp-font-wrap{width:100%;max-width:700px}
.fp-font-preview{font-size:30px;line-height:1.5;color:var(--text);padding:18px;
  background:var(--bg1);border-radius:6px;border:1px solid var(--border);margin-bottom:10px;word-break:break-all}
.fp-font-sizes{display:flex;flex-direction:column;gap:5px}
.fp-font-sizes span{color:var(--text-dim);padding:3px 0;border-bottom:1px solid var(--border)}
.fp-json{width:100%;font-size:11.5px;line-height:1.75}
.fp-json .jk{color:#82aaff}.fp-json .jv-str{color:#3ddc84}.fp-json .jv-num{color:#f0c040}
.fp-json .jv-bool{color:#c792ea}.fp-json .jv-null{color:var(--text-faint)}
.fp-json-toggle{cursor:pointer;user-select:none}.fp-json-toggle:hover{color:var(--accent)}
.fp-json-children{margin-left:16px;border-left:1px solid var(--border);padding-left:8px}
.fp-csv{width:100%;overflow-x:auto}
.fp-csv table{border-collapse:collapse;font-size:11px;min-width:300px;width:100%}
.fp-csv th{background:var(--bg2);color:var(--accent);padding:5px 9px;border:1px solid var(--border);
  text-align:left;position:sticky;top:0}
.fp-csv td{padding:3px 9px;border:1px solid var(--border);color:var(--text-dim)}
.fp-csv tr:hover td{background:var(--bg2);color:var(--text)}
.fp-md{width:100%;max-width:760px;line-height:1.8;color:var(--text)}
.fp-md h1,.fp-md h2,.fp-md h3{font-family:'Rajdhani',sans-serif;color:var(--accent);margin:14px 0 7px;letter-spacing:.04em}
.fp-md h1{font-size:22px;border-bottom:1px solid var(--border);padding-bottom:5px}
.fp-md h2{font-size:17px}.fp-md h3{font-size:14px}
.fp-md p{margin-bottom:9px}.fp-md a{color:var(--accent)}
.fp-md code{background:var(--bg2);padding:1px 5px;border-radius:3px;font-size:11px;color:var(--green)}
.fp-md pre{background:var(--bg1);border:1px solid var(--border);border-radius:4px;padding:10px;overflow-x:auto;margin:8px 0}
.fp-md pre code{background:none;padding:0;color:var(--text)}
.fp-md blockquote{border-left:3px solid var(--accent-dim);padding-left:10px;color:var(--text-dim);margin:7px 0}
.fp-md ul,.fp-md ol{margin:7px 0 7px 18px}
.fp-md table{border-collapse:collapse;width:100%;margin:9px 0}
.fp-md th{background:var(--bg2);color:var(--accent);padding:5px 9px;border:1px solid var(--border)}
.fp-md td{padding:4px 9px;border:1px solid var(--border)}.fp-md img{max-width:100%;border-radius:4px}
.fp-md hr{border:none;border-top:1px solid var(--border);margin:14px 0}
.fp-hex{width:100%;font-size:11px;line-height:1.9}
.fp-hex-row{display:flex;gap:10px;padding:1px 0}
.fp-hex-addr{color:var(--text-faint);min-width:52px}
.fp-hex-bytes{color:var(--accent);letter-spacing:.1em;flex:1}
.fp-hex-ascii{color:var(--text-dim)}
.fp-hex-zero{color:var(--border2)}
.fp-unknown{text-align:center;padding:36px 18px;color:var(--text-faint)}
.fp-unknown .fp-unk-icon{font-size:52px;margin-bottom:10px}
.fp-unknown .fp-unk-title{font-size:13px;color:var(--text-dim);margin-bottom:5px}
.fp-unknown .fp-unk-sub{font-size:11px}

/* ══════════════════════════════════════════
   URL BAR in preview panel
══════════════════════════════════════════ */
#preview-url-bar{
  display:none;align-items:center;gap:5px;
  padding:4px 7px;background:var(--bg1);border-bottom:1px solid var(--border);flex-shrink:0;
}
#preview-url-bar.visible{display:flex}
#url-bar-input{
  flex:1;background:var(--bg2);border:1px solid var(--border2);color:var(--text);
  font-family:'JetBrains Mono',monospace;font-size:11px;padding:4px 7px;
  border-radius:3px;outline:none;caret-color:var(--accent);
}
#url-bar-input:focus{border-color:var(--accent)}
#url-bar-go{
  font-size:11px;padding:3px 10px;border-radius:3px;cursor:pointer;
  background:var(--accent);color:#000;border:none;font-weight:700;
  font-family:'JetBrains Mono',monospace;white-space:nowrap;
}
#url-bar-go:hover{box-shadow:var(--glow-sm)}
.url-bar-btn{font-size:14px;cursor:pointer;color:var(--text-faint);padding:2px 4px;border-radius:3px;
  transition:all .1s;flex-shrink:0;background:none;border:none}
.url-bar-btn:hover{color:var(--text);background:var(--bg3)}
#url-bar-webpack{
  font-size:9px;padding:2px 6px;border-radius:3px;cursor:pointer;border:1px solid;
  font-family:'JetBrains Mono',monospace;white-space:nowrap;transition:all .1s;
  color:var(--orange);border-color:rgba(255,179,71,.4);background:transparent;
}
#url-bar-webpack.on{background:rgba(255,179,71,.12);box-shadow:0 0 5px rgba(255,179,71,.25)}
#url-bar-basedir{
  font-size:9px;padding:2px 6px;border-radius:3px;cursor:pointer;border:1px solid;
  font-family:'JetBrains Mono',monospace;white-space:nowrap;transition:all .1s;
  color:var(--green);border-color:rgba(61,220,132,.35);background:transparent;
  max-width:110px;overflow:hidden;text-overflow:ellipsis;
}
#url-bar-basedir:hover{background:rgba(61,220,132,.08)}
/* ── Logo pulse animation ── */
@keyframes logoPulse {
  0%, 100% { text-shadow: 0 0 8px rgba(var(--accent-rgb), 0.3); }
  50%       { text-shadow: 0 0 20px rgba(var(--accent-rgb), 0.7), 0 0 40px rgba(var(--accent-rgb), 0.3); }
}
.title-logo { animation: logoPulse 4s ease-in-out infinite; }

/* ── Statusbar shimmer on load ── */
@keyframes sbShimmer {
  from { opacity: 0; transform: translateY(100%); }
  to   { opacity: 1; transform: translateY(0); }
}
#statusbar { animation: sbShimmer 0.35s ease-out both; }

/* ── Activity bar icon hover bounce ── */
.act-btn { transition: transform 0.15s, color 0.15s, background 0.15s; }
.act-btn:hover { transform: translateX(2px); }
.act-btn.active { transform: none; }

/* ── Tab bar smooth scroll indicator ── */
#tabs-bar::after {
  content: ''; position: absolute; right: 0; top: 0; bottom: 0;
  width: 24px; pointer-events: none;
  background: linear-gradient(to right, transparent, var(--bg1));
}

/* ── Notification badge pulse when count > 0 ── */
#sb-notif-badge.has-notif { animation: live-pulse 2s ease-in-out infinite; }

/* ── Improved empty state ── */
.empty-logo {
  font-family: 'Rajdhani', sans-serif; font-size: 52px; font-weight: 700;
  background: linear-gradient(135deg, var(--border2) 0%, var(--border2) 40%, rgba(var(--accent-rgb),0.2) 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text; letter-spacing: 0.25em; line-height: 1;
}

/* ── Sidebar tree indent guides ── */
.tree-indent::before {
  content: ''; display: inline-block; width: 1px; height: 100%;
  background: var(--border); margin: 0 7px;
  vertical-align: middle; opacity: 0.5;
}

/* ── Panel tab active accent dot ── */
.ptab.active::after {
  content: ''; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%);
  width: 4px; height: 4px; border-radius: 50%;
  background: var(--accent); box-shadow: 0 0 6px rgba(var(--accent-rgb),0.6);
}
.ptab { position: relative; }

/* ── Tooltip micro style ── */
[title]:hover::after {
  content: attr(title);
  position: absolute; bottom: calc(100% + 6px); left: 50%; transform: translateX(-50%);
  background: var(--bg3); color: var(--text); font-size: 10px; padding: 3px 7px;
  border-radius: 4px; border: 1px solid var(--border2); white-space: nowrap;
  pointer-events: none; z-index: 99999; font-family: 'JetBrains Mono', monospace;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  opacity: 0; animation: fadeIn 0.15s 0.4s forwards;
}
/* Only show on act-btn and tbtn to avoid global noise */
.act-btn[title]:hover::after, .tbtn[title]:hover::after, #sb-storage[title]:hover::after { opacity: 1; }
.act-btn { position: relative; overflow: visible; }

/* ── Scrollbars global theme ── */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg1); }
::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent-dim); }
::-webkit-scrollbar-corner { background: var(--bg1); }

/* ── Advanced Monaco Config ── */
.adv-row {
  display: grid;
  grid-template-columns: 28px 1fr 120px 36px;
  align-items: center;
  gap: 0;
  padding: 5px 8px;
  border-radius: 3px;
  border: 1px solid transparent;
  transition: background 0.12s, border-color 0.12s;
  cursor: default;
}
.adv-row:hover { background: rgba(var(--accent-rgb),0.05); border-color: var(--border); }
.adv-row.adv-modified { background: rgba(240,192,64,0.07); border-color: rgba(240,192,64,0.25); }
.adv-row.adv-modified:hover { background: rgba(240,192,64,0.12); }
.adv-row.adv-hidden { display: none; }

.adv-modified-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: var(--yellow); box-shadow: 0 0 4px var(--yellow);
  margin: auto;
}
.adv-key {
  display: flex; flex-direction: column; gap: 2px;
  overflow: hidden; padding-right: 8px;
}
.adv-key-name { color: var(--accent); font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.adv-key-desc { color: var(--text-faint); font-size: 9.5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.adv-key-cat  { display: inline-block; font-size: 8.5px; color: var(--bg3); background: var(--text-faint); border-radius: 2px; padding: 0 4px; margin-left: 6px; vertical-align: middle; opacity: 0.7; }

.adv-val-wrap { display: flex; align-items: center; gap: 4px; }

/* Boolean toggle */
.adv-bool { display: flex; align-items: center; gap: 5px; }
.adv-bool-btn {
  width: 32px; height: 17px; border-radius: 9px;
  background: var(--bg4); border: 1px solid var(--border2);
  cursor: pointer; position: relative; transition: background 0.15s;
  flex-shrink: 0;
}
.adv-bool-btn.on { background: rgba(var(--accent-rgb),0.5); border-color: var(--accent); }
.adv-bool-btn::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 11px; height: 11px; border-radius: 50%;
  background: var(--text-dim); transition: transform 0.15s, background 0.15s;
}
.adv-bool-btn.on::after { transform: translateX(15px); background: var(--accent); }

/* Number input */
.adv-num {
  width: 100%; background: var(--bg0); border: 1px solid var(--border2);
  color: var(--text); font-family: 'JetBrains Mono', monospace;
  font-size: 11px; padding: 3px 6px; border-radius: 3px; outline: none;
  text-align: right;
}
.adv-num:focus { border-color: var(--accent); }

/* String / select inputs */
.adv-str, .adv-sel {
  width: 100%; background: var(--bg0); border: 1px solid var(--border2);
  color: var(--text); font-family: 'JetBrains Mono', monospace;
  font-size: 11px; padding: 3px 6px; border-radius: 3px; outline: none;
}
.adv-str:focus, .adv-sel:focus { border-color: var(--accent); }

/* Reset button */
.adv-reset-btn {
  background: none; border: none; color: var(--text-faint);
  cursor: pointer; font-size: 13px; padding: 2px 4px;
  border-radius: 3px; line-height: 1; transition: color 0.1s, background 0.1s;
  flex-shrink: 0;
}
.adv-reset-btn:hover { color: var(--red); background: rgba(255,76,106,0.12); }

/* JSON editor mode */
#adv-json-editor {
  width: 100%; min-height: 280px; resize: vertical;
  background: var(--bg0); border: 1px solid var(--border2);
  color: var(--text); font-family: 'JetBrains Mono', monospace;
  font-size: 11px; padding: 10px; border-radius: 4px; outline: none;
  line-height: 1.6; tab-size: 2;
}
#adv-json-editor:focus { border-color: var(--accent); }
#adv-json-error { color: var(--red); font-size: 10px; margin-top: 4px; min-height: 16px; font-family: 'JetBrains Mono', monospace; }
</style>
<body>

<!-- ── Title bar ── -->
<div id="titlebar">
  <div class="title-logo">VOID <em>browser ide v0.21 alpha</em></div>
  <div class="title-menu">
    <div class="menu-item" id="menu-file" onclick="toggleMenu(this)">File
      <div class="menu-dropdown">
        <div class="dd-item" onclick="showNewFileDialog()">  <span>New File</span>       <span class="kbd">Ctrl+N</span></div>
        <div class="dd-item" onclick="showNewFolderDialog()"><span>New Folder</span>      <span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="saveCurrentFile()">    <span>Save</span>            <span class="kbd">Ctrl+S</span></div>
        <div class="dd-item" onclick="saveAll()">            <span>Save All</span>        <span class="kbd">Ctrl+Shift+S</span></div>
        <hr>
        <div class="dd-item" onclick="importFile()">  <span>Import File…</span>     <span class="kbd"></span></div>
        <div class="dd-item" onclick="importZip()">   <span>Import ZIP…</span>      <span class="kbd">Ctrl+Shift+O</span></div>
        <hr>
        <div class="dd-item" onclick="exportFile()">  <span>Export File…</span>     <span class="kbd"></span></div>
        <div class="dd-item" onclick="exportZip()">   <span>Export as ZIP…</span>   <span class="kbd">Ctrl+Shift+E</span></div>
        <div class="dd-item" onclick="exportWebpackBundle()"><span>Export Bundled HTML…</span><span class="kbd">Ctrl+Shift+B</span></div>
        <hr>
        <div class="dd-item" onclick="resetFS()">            <span>Reset Filesystem</span><span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="promptSetProjectDir()"> <span>Set Project Dir…</span>  <span class="kbd"></span></div>
      </div>
    </div>
    <div class="menu-item" id="menu-view" onclick="toggleMenu(this)">View
      <div class="menu-dropdown">
        <div class="dd-item" onclick="togglePanel()">  <span>Toggle Panel</span>   <span class="kbd">Ctrl+`</span></div>
        <div class="dd-item" onclick="toggleSidebar()"><span>Toggle Sidebar</span> <span class="kbd">Ctrl+B</span></div>
        <hr>
        <div class="dd-item" onclick="switchPanelTab('terminal')"><span>🖥 Terminal</span></div>
        <div class="dd-item" onclick="switchPanelTab('preview')"> <span>▶ Preview</span></div>
        <div class="dd-item" onclick="switchPanelTab('shell')">   <span>⚡ Shell</span></div>
        <div class="dd-item" onclick="switchPanelTab('hex')">     <span>🔢 Hex Viewer</span></div>
        <div class="dd-item" onclick="switchPanelTab('proxy')">   <span>🌐 Proxy</span></div>
        <hr>
        <div class="dd-item" onclick="toggleWordWrap()">   <span>Toggle Word Wrap</span>   <span class="kbd">Alt+Z</span></div>
        <div class="dd-item" onclick="toggleMinimap()">    <span>Toggle Minimap</span>     <span class="kbd"></span></div>
        <div class="dd-item" onclick="toggleLineNumbers()"><span>Toggle Line Numbers</span><span class="kbd"></span></div>
        <div class="dd-item" onclick="toggleBreadcrumbs()"><span>Toggle Breadcrumbs</span><span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="increaseFontSize()">    <span>Increase Font Size</span>    <span class="kbd">Ctrl+=</span></div>
        <div class="dd-item" onclick="decreaseFontSize()">    <span>Decrease Font Size</span>    <span class="kbd">Ctrl+-</span></div>
        <div class="dd-item" onclick="resetFontSize()">       <span>Reset Font Size</span>       <span class="kbd">Ctrl+0</span></div>
        <div class="dd-item" onclick="increaseUIFontSize()">  <span>Increase UI Font Size</span> <span class="kbd">Ctrl+Shift+=</span></div>
        <div class="dd-item" onclick="decreaseUIFontSize()">  <span>Decrease UI Font Size</span> <span class="kbd">Ctrl+Shift+-</span></div>
        <hr>
        <div class="dd-item" onclick="zoomIn()">  <span>Zoom In</span>  <span class="kbd"></span></div>
        <div class="dd-item" onclick="zoomOut()"> <span>Zoom Out</span> <span class="kbd"></span></div>
        <div class="dd-item" onclick="zoomReset()"><span>Reset Zoom</span><span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="openSettings('appearance')"><span>Appearance Settings…</span></div>
      </div>
    </div>
    <div class="menu-item" id="menu-run" onclick="toggleMenu(this)">Run
      <div class="menu-dropdown">
        <div class="dd-item" onclick="runCurrentFile()">   <span>▶ Run File</span>            <span class="kbd">Ctrl+Enter</span></div>
        <div class="dd-item" onclick="runProjectIndex()">  <span>▶ Run index.html</span>      <span class="kbd">Ctrl+Shift+Enter</span></div>
        <div class="dd-item" onclick="runWithFetchPreload()"><span>⚡ Run w/ Fetch Preloader</span><span class="kbd">Ctrl+Shift+R</span></div>
        <hr>
        <div class="dd-item" onclick="runInNewWindow()">   <span>🪟 Run in New Window</span>  <span class="kbd"></span></div>
        <div class="dd-item" onclick="popoutPreview()">    <span>⧉ Popout Preview</span>      <span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="analyzeJSFetches()"> <span>🔍 Analyze JS Fetches</span> <span class="kbd"></span></div>
        <div class="dd-item" onclick="promptSetBaseDir()">  <span>📂 Set Preload Base Dir…</span><span class="kbd"></span></div>
        <div class="dd-item" onclick="promptSetProjectDir()"><span>📁 Set Project Dir…</span>  <span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="toggleUrlBar()">     <span>🔗 Toggle URL Bar</span>     <span class="kbd"></span></div>
        <div class="dd-item" onclick="toggleLiveReload()"> <span>🔄 Toggle Live Reload</span> <span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="clearTerminal()">    <span>🗑 Clear Terminal</span>      <span class="kbd"></span></div>
        <div class="dd-item" onclick="clearPreview()">     <span>🗑 Clear Preview</span>       <span class="kbd"></span></div>
      </div>
    </div>
    <div class="menu-item" id="menu-tools" onclick="toggleMenu(this)">Tools
      <div class="menu-dropdown">
        <div class="dd-item" onclick="formatCode()">          <span>Format Document</span>     <span class="kbd">Shift+Alt+F</span></div>
        <div class="dd-item" onclick="commentLine()">         <span>Toggle Comment</span>      <span class="kbd">Ctrl+/</span></div>
        <div class="dd-item" onclick="duplicateLine()">       <span>Duplicate Line</span>      <span class="kbd">Shift+Alt+D</span></div>
        <div class="dd-item" onclick="moveLinesUp()">         <span>Move Lines Up</span>       <span class="kbd">Alt+↑</span></div>
        <div class="dd-item" onclick="moveLinesDown()">       <span>Move Lines Down</span>     <span class="kbd">Alt+↓</span></div>
        <hr>
        <div class="dd-item" onclick="findReplace()">         <span>Find &amp; Replace</span>  <span class="kbd">Ctrl+H</span></div>
        <div class="dd-item" onclick="goToLine()">            <span>Go to Line…</span>         <span class="kbd">Ctrl+G</span></div>
        <div class="dd-item" onclick="goToSymbol()">          <span>Go to Symbol…</span>       <span class="kbd">Ctrl+Shift+O</span></div>
        <hr>
        <div class="dd-item" onclick="convertEncoding()">     <span>Convert File Encoding…</span><span class="kbd"></span></div>
        <div class="dd-item" onclick="reloadWithEncoding()">  <span>Reload with Encoding…</span><span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="sortLinesAsc()">        <span>Sort Lines Ascending</span> <span class="kbd"></span></div>
        <div class="dd-item" onclick="sortLinesDesc()">       <span>Sort Lines Descending</span><span class="kbd"></span></div>
        <div class="dd-item" onclick="trimTrailingWhitespace()"><span>Trim Trailing Whitespace</span><span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="analyzeJSFetches()">    <span>Analyze JS Fetches</span>  <span class="kbd"></span></div>
        <div class="dd-item" onclick="showFileInfo()">         <span>File Info / Stats</span>   <span class="kbd"></span></div>
        <div class="dd-item" onclick="openSettings('editor')"><span>Editor Settings…</span>   <span class="kbd"></span></div>
        <hr>
        <div class="dd-item" onclick="packOffline()">          <span>📦 Pack Offline…</span>    <span class="kbd"></span></div>
        <div class="dd-item" onclick="exportWebpackBundle()">  <span>📦 Export Bundled HTML…</span><span class="kbd">Ctrl+Shift+B</span></div>
      </div>
    </div>
  </div>
  <div class="title-actions">
    <div id="storage-indicator" onclick="toggleStorageSelector()" title="Switch storage backend">
      <span id="storage-icon">💾</span>
      <span id="storage-label">Storage:</span>
      <span id="storage-mode">IndexedDB</span>
      <div id="storage-selector">
        <div class="storage-option active" onclick="switchStorageMode(event,'indexed')">
          <span class="storage-option-icon">🗄️</span>
          <div class="storage-option-text">
            <div class="storage-option-name">IndexedDB</div>
            <div class="storage-option-desc">Persistent, fast (recommended)</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" onclick="switchStorageMode(event,'local')">
          <span class="storage-option-icon">📦</span>
          <div class="storage-option-text">
            <div class="storage-option-name">LocalStorage</div>
            <div class="storage-option-desc">Persistent, 5-10 MB limit</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" onclick="switchStorageMode(event,'memory')">
          <span class="storage-option-icon">⚡</span>
          <div class="storage-option-text">
            <div class="storage-option-name">Memory</div>
            <div class="storage-option-desc">Volatile, lost on refresh</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" id="storage-opt-folder" onclick="switchStorageToFolder(event)">
          <span class="storage-option-icon">🗂️</span>
          <div class="storage-option-text">
            <div class="storage-option-name">Real Folder</div>
            <div class="storage-option-desc">Read/write a folder on disk</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
      </div>
    </div>
    <button class="tbtn tbtn-popout" onclick="popoutPreview()" title="Open preview in popup window">⧉ Popout</button>
    <button class="tbtn tbtn-save" onclick="saveCurrentFile()">💾 Save</button>
    <button class="tbtn tbtn-dir" onclick="promptSetProjectDir()" id="btn-project-dir" title="Set project directory for native file:// loading">📂 Dir</button>
    <button class="tbtn tbtn-run"  onclick="runCurrentFile()" id="btn-run" title="Run (Ctrl+Enter)">▶ Run</button>
  </div>
</div>

<!-- ── App body ── -->
<div id="app">

  <!-- Activity bar -->
  <div id="activitybar">
    <div class="act-btn active" id="act-files" onclick="setActivity('files')" title="Explorer">📁</div>
    <div class="act-btn" id="act-search" onclick="setActivity('search')" title="Search">🔍</div>
    <div class="act-btn" id="act-shared" onclick="setActivity('shared')" title="Shared Files (File System Access API)">🖥️</div>
    <div class="act-btn" style="margin-top:auto" onclick="openSettings()" title="Settings">⚙️</div>
  </div>

  <!-- Sidebar -->
  <div id="sidebar">
    <div id="sidebar-explorer">
      <div class="sidebar-header">
        <span>Explorer</span>
        <div class="sidebar-actions">
          <div class="sact" onclick="showNewFileDialog()"   title="New File">📄</div>
          <div class="sact" onclick="showNewFolderDialog()" title="New Folder">📁</div>
          <div class="sact" onclick="refreshTree()"         title="Refresh">🔄</div>
          <div class="sact" onclick="importZip()"            title="Import ZIP">📦</div>
        </div>
      </div>
      <div id="filetree"></div>
    </div>
    <div id="sidebar-search" style="display:none">
      <div class="sidebar-header"><span>Search</span></div>
      <div style="padding:8px">
        <input id="search-input" type="text" placeholder="Search in files…"
          style="width:100%;background:var(--bg0);border:1px solid var(--border2);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px;padding:5px 8px;border-radius:3px;outline:none;"
          oninput="doSearch(this.value)">
        <div id="search-results" style="margin-top:8px;font-size:11px;color:var(--text-dim);"></div>
      </div>
    </div>

    <!-- Shared Files panel (File System Access API) -->
    <div id="sidebar-shared" style="display:none">
      <div class="sidebar-header">
        <span>Shared Files</span>
        <div class="sidebar-actions">
          <div class="sact" onclick="sharedOpenFile()" title="Open File(s)">📄</div>
          <div class="sact" onclick="sharedOpenDir()" title="Open Folder">📁</div>
          <div class="sact" onclick="sharedSaveActive()" title="Save back to disk">💾</div>
          <div class="sact" onclick="sharedClearAll()" title="Clear list">✕</div>
        </div>
      </div>
      <div id="shared-api-warning">⚠ File System Access API not supported in this browser. Use Chrome/Edge 86+.</div>
      <div id="shared-files-list">
        <div class="shared-empty">No real files open.<br><br>
          Use <b>📄</b> to pick file(s) or <b>📁</b> for a whole folder.<br><br>
          Files open with full read &amp; write access to your actual disk.
        </div>
      </div>
      <div class="shared-actions">
        <button class="shared-btn primary" onclick="sharedOpenFile()">📄 Open File(s)</button>
        <button class="shared-btn primary" onclick="sharedOpenDir()">📁 Open Folder</button>
        <button class="shared-btn" onclick="sharedSaveActive()">💾 Save to Disk</button>
        <button class="shared-btn" onclick="sharedSaveAll()">💾 Save All</button>
        <button class="shared-btn" onclick="sharedImportToVFS()">⬇ Copy→VFS</button>
      </div>
    </div>
  </div>

  <!-- Sidebar resize handle -->
  <div id="sidebar-resize"></div>

  <!-- Editor area -->
  <div id="editor-area">
    <div id="tabs-bar"></div>
    <div id="monaco-container">
      <div id="empty-state">
        <div class="empty-logo">VOID</div>
        <div class="empty-sub">open a file or create a new one</div>
      </div>
      <!-- File Preview pane — shown instead of Monaco for binary/media/data files -->
      <div id="file-preview"></div>
    </div>

    <!-- Panel resize -->
    <div id="panel-resize"></div>

    <!-- Bottom panel -->
    <div id="panel-area">
      <div id="panel-tabs">
        <div class="ptab active" onclick="switchPanelTab('terminal')" id="ptab-terminal">TERMINAL</div>
        <div class="ptab" onclick="switchPanelTab('preview')"  id="ptab-preview">PREVIEW</div>
        <div class="ptab" onclick="switchPanelTab('shell')"    id="ptab-shell">SHELL</div>
        <div class="ptab" onclick="switchPanelTab('hex')"      id="ptab-hex">HEX</div>
        <div class="ptab" onclick="switchPanelTab('proxy')"    id="ptab-proxy">PROXY</div>
        <div class="ptab-actions">
          <button class="ptab-btn" onclick="clearTerminal()">clear</button>
          <button class="ptab-btn" onclick="promptSetProjectDir()" title="Set project dir for native file:// loading" id="ptab-btn-dir">📂 dir</button>
          <button class="ptab-btn" id="ptab-btn-live" onclick="toggleLiveReload()" title="Live reload — auto re-runs preview on every edit">⚡ live</button>
          <button class="ptab-btn" onclick="runWithFetchPreload()" title="Run with Fetch Preloader — pre-resolves fetch() calls as blobs" style="color:var(--purple);border-color:rgba(199,146,234,0.4)">🔗 preload</button>
          <button class="ptab-btn" onclick="toggleUrlBar()" title="Toggle URL bar — load any URL through the preloader" style="color:var(--orange);border-color:rgba(255,179,71,0.4)" id="ptab-btn-url">🌐 url</button>
          <button class="ptab-btn" onclick="runCurrentFile()">▶ run</button>
        </div>
      </div>
      <div id="panel-content">
        <div class="panel-view active" id="view-terminal">
          <div id="terminal-output"></div>
        </div>
        <!-- ── Shell tab ── -->
        <div class="panel-view" id="view-shell">
          <div id="xterm-container"></div>
        </div>
        <div class="panel-view" id="view-preview">
          <!-- URL bar (shown when URL mode active) -->
          <div id="preview-url-bar">
            <button class="url-bar-btn" onclick="urlBarBack()" title="Back">◀</button>
            <button class="url-bar-btn" onclick="urlBarReload()" title="Reload">↺</button>
            <input id="url-bar-input" type="text" placeholder="https://… or /local/path" spellcheck="false"
              onkeydown="if(event.key==='Enter')urlBarGo()">
            <button id="url-bar-go" onclick="urlBarGo()">GO</button>
            <button id="url-bar-webpack" onclick="toggleUrlWebpack(this)" title="Apply webpack/CommonJS shim to loaded JS">WP</button>
            <button id="url-bar-basedir" onclick="promptSetBaseDir()" title="Set preload base directory">📂 basedir</button>
          </div>
          <iframe id="preview-frame" sandbox="allow-scripts allow-forms allow-modals allow-popups allow-same-origin"></iframe>
        </div>

        <!-- ── Hex Editor tab ── -->
        <div class="panel-view" id="view-hex">
          <div id="hex-toolbar">
            <span id="hex-filename">No file — use <code>hexedit &lt;file&gt;</code> in shell or open below</span>
            <div id="hex-toolbar-right">
              <label id="hex-open-btn" title="Open file in hex editor">
                📂 open file
                <input type="file" id="hex-file-input" style="display:none" onchange="hexLoadNativeFile(this)">
              </label>
              <button class="hex-btn" onclick="hexSave()" title="Save changes to VFS">💾 save</button>
              <button class="hex-btn" onclick="hexExport()" title="Download binary">⬇ export</button>
              <span id="hex-offset-display">OFF: 0x000000</span>
              <span id="hex-sel-display"></span>
            </div>
          </div>
          <div id="hex-main">
            <div id="hex-addr-col"></div>
            <div id="hex-bytes-col" tabindex="0"></div>
            <div id="hex-ascii-col"></div>
          </div>
          <div id="hex-statusbar">
            <span id="hex-status-left">Ready — open a file to begin</span>
            <span id="hex-status-right">0 bytes</span>
          </div>
        </div><!-- end view-hex -->

        <!-- ── Proxy panel ── -->
        <div class="panel-view" id="view-proxy">
          <div id="proxy-toolbar">
            <span class="proxy-title">PROXY</span>
            <div id="proxy-status-dot"></div>
            <span id="proxy-status-text">Disconnected</span>
            <button class="proxy-tbtn proxy-tbtn-test" onclick="proxyTest()" id="proxy-btn-test">⚡ test</button>
            <button class="proxy-tbtn proxy-tbtn-connect" onclick="proxyConnect()" id="proxy-btn-connect">▶ connect</button>
            <button class="proxy-tbtn proxy-tbtn-disconnect" onclick="proxyDisconnect()" id="proxy-btn-disconnect" style="display:none">■ disconnect</button>
          </div>
          <div id="proxy-body">
            <div id="proxy-config">
              <div class="proxy-section-title">Proxy Server</div>
              <div class="proxy-field">
                <label>WebSocket URL</label>
                <input id="proxy-ws-url" type="text" value="ws://localhost:8765" placeholder="ws://host:port" spellcheck="false">
              </div>
              <div class="proxy-field">
                <label>Auth Token (optional)</label>
                <input id="proxy-token" type="password" placeholder="leave blank if none">
              </div>

              <div class="proxy-section-title" style="margin-top:4px">Tunnel Mode</div>
              <div class="proxy-mode-tabs" style="flex-wrap:wrap;gap:3px;">
                <div class="proxy-mode-tab active" id="pmode-http"      onclick="proxySetMode('http')">VOID</div>
                <div class="proxy-mode-tab"         id="pmode-socks5"   onclick="proxySetMode('socks5')">SOCKS5</div>
                <div class="proxy-mode-tab"         id="pmode-wsx"      onclick="proxySetMode('wsx')">websockify</div>
                <div class="proxy-mode-tab"         id="pmode-wstunnel" onclick="proxySetMode('wstunnel')">wstunnel</div>
                <div class="proxy-mode-tab"         id="pmode-ovpn"     onclick="proxySetMode('ovpn')">OpenVPN</div>
                <div class="proxy-mode-tab"         id="pmode-wg"       onclick="proxySetMode('wg')">WireGuard</div>
              </div>

              <!-- VOID custom JSON protocol -->
              <div id="proxy-cfg-http">
                <div style="font-size:10px;color:var(--text-faint);margin-bottom:6px;line-height:1.5;">Custom JSON protocol — requires <span style="color:var(--accent)">void-proxy-server</span> companion.</div>
                <div class="proxy-field">
                  <label>Intercept</label>
                  <select id="proxy-intercept">
                    <option value="all">All fetch/XHR</option>
                    <option value="external">External URLs only</option>
                    <option value="manual">Manual (shell only)</option>
                  </select>
                </div>
              </div>

              <!-- websockify config -->
              <div id="proxy-cfg-wsx" style="display:none">
                <div style="font-size:10px;color:var(--text-faint);margin-bottom:6px;line-height:1.5;">
                  <b style="color:var(--text-dim)">novnc/websockify</b> — raw TCP over WebSocket.<br>
                  Install: <span style="color:var(--accent)">pip install websockify</span><br>
                  Run: <span style="color:var(--accent)">websockify 8765 host:port</span>
                </div>
                <div class="proxy-field">
                  <label>Target Host (what websockify connects to)</label>
                  <input id="proxy-wsx-host" type="text" placeholder="e.g. api.example.com" spellcheck="false">
                </div>
                <div class="proxy-field">
                  <label>Target Port</label>
                  <input id="proxy-wsx-port" type="text" value="80" spellcheck="false">
                </div>
                <div class="proxy-field">
                  <label>Subprotocol</label>
                  <select id="proxy-wsx-sub">
                    <option value="binary">binary (recommended)</option>
                    <option value="base64">base64 (legacy)</option>
                  </select>
                </div>
                <div style="font-size:10px;color:var(--text-faint);margin-top:4px;line-height:1.5;">
                  The WS URL field above should point at the websockify server (no path needed). Raw bytes are streamed — use proxy fetch or node scripts to read the TCP stream.
                </div>
              </div>

              <!-- wstunnel config -->
              <div id="proxy-cfg-wstunnel" style="display:none">
                <div style="font-size:10px;color:var(--text-faint);margin-bottom:6px;line-height:1.5;">
                  <b style="color:var(--text-dim)">erebe/wstunnel</b> — TCP tunnel over WebSocket.<br>
                  Get binary: <span style="color:var(--accent)">github.com/erebe/wstunnel</span><br>
                  Run: <span style="color:var(--accent)">wstunnel server ws://0.0.0.0:8080</span>
                </div>
                <div class="proxy-field">
                  <label>Target Host</label>
                  <input id="proxy-wst-host" type="text" placeholder="e.g. api.example.com" spellcheck="false" oninput="proxyWstPreview()">
                </div>
                <div class="proxy-field">
                  <label>Target Port</label>
                  <input id="proxy-wst-port" type="text" value="80" spellcheck="false" oninput="proxyWstPreview()">
                </div>
                <div class="proxy-field">
                  <label>Path Prefix (default: v1)</label>
                  <input id="proxy-wst-prefix" type="text" value="v1" spellcheck="false" oninput="proxyWstPreview()">
                </div>
                <div class="proxy-field">
                  <label>Credentials (user:pass, optional)</label>
                  <input id="proxy-wst-creds" type="text" placeholder="user:pass" spellcheck="false">
                </div>
                <div style="font-size:10px;color:var(--text-faint);margin-top:4px;line-height:1.5;">
                  Upgrade URL: <span id="proxy-wst-url-preview" style="color:var(--accent)">ws://…/v1/tcp/host/port</span>
                </div>
              </div>

              <!-- OpenVPN config -->
              <div id="proxy-cfg-ovpn" style="display:none">
                <div class="proxy-field">
                  <label>.ovpn Config</label>
                  <textarea id="proxy-ovpn-cfg" rows="5" style="background:var(--bg3);border:1px solid var(--border);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px;border-radius:3px;width:100%;resize:vertical;" placeholder="Paste .ovpn config here…"></textarea>
                </div>
                <div class="proxy-field"><label>Username</label><input id="proxy-ovpn-user" type="text" placeholder="optional"></div>
                <div class="proxy-field"><label>Password</label><input id="proxy-ovpn-pass" type="password" placeholder="optional"></div>
              </div>

              <!-- WireGuard config -->
              <div id="proxy-cfg-wg" style="display:none">
                <div class="proxy-field">
                  <label>WireGuard Config (wg0.conf)</label>
                  <textarea id="proxy-wg-cfg" rows="8" style="background:var(--bg3);border:1px solid var(--border);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px;border-radius:3px;width:100%;resize:vertical;" placeholder="[Interface]&#10;PrivateKey = ...&#10;Address = ...&#10;&#10;[Peer]&#10;PublicKey = ...&#10;Endpoint = ...&#10;AllowedIPs = 0.0.0.0/0"></textarea>
                </div>
              </div>

              <div class="proxy-section-title" style="margin-top:4px">Routing Rules</div>
              <div class="proxy-field">
                <label>Bypass list (one per line)</label>
                <textarea id="proxy-bypass" rows="3" style="background:var(--bg3);border:1px solid var(--border);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px;border-radius:3px;width:100%;resize:vertical;">localhost
127.0.0.1
*.local</textarea>
              </div>

              <div class="proxy-section-title" style="margin-top:4px">Server Setup</div>
              <div style="font-size:10px;color:var(--text-dim);line-height:1.7;">
                VOID: <span style="color:var(--accent)">npx void-proxy-server</span><br>
                websockify: <span style="color:var(--accent)">pip install websockify</span><br>
                wstunnel: <span style="color:var(--accent)">github.com/erebe/wstunnel/releases</span><br><br>
                <span style="color:var(--text-faint);cursor:pointer;text-decoration:underline" onclick="proxyShowServerCode()">Show VOID server source →</span>
              </div>
            </div>

            <div id="proxy-log-panel">
              <div id="proxy-log-toolbar">
                <span>Connection Log</span>
                <span style="margin-left:auto;cursor:pointer;color:var(--accent)" onclick="proxyClearLog()">clear</span>
              </div>
              <div id="proxy-log"></div>
              <div id="proxy-stats">
                <div>↑ <span id="proxy-stat-tx">0 B</span></div>
                <div>↓ <span id="proxy-stat-rx">0 B</span></div>
                <div>requests: <span id="proxy-stat-req">0</span></div>
                <div>latency: <span id="proxy-stat-lat">—</span></div>
              </div>
            </div>
          </div>
        </div><!-- end view-proxy -->
    </div>
  </div>
</div>

<!-- Status bar -->
<table id="statusbar" cellspacing="0" cellpadding="0">
  <tr>
    <td id="sb-branch-area" onclick="openSettings()" title="VOID IDE Settings">
      <span id="sb-dot" class="on"></span><span id="sb-branch">VOID</span>
    </td>
    <td id="sb-file" title="Current file">
      📄 <span id="sb-file-name">No file open</span>
    </td>
    <td id="sb-problems" onclick="switchPanelTab('terminal')" title="Problems">
      ⚠ <span id="sb-problems-count">0</span>
    </td>
    <td class="sb-spacer"></td>
    <td id="sb-lang" title="Language mode">—</td>
    <td title="File encoding" id="sb-encoding" onclick="showEncodingPicker()" style="cursor:pointer;position:relative">
      <span id="sb-encoding-label">UTF-8</span>
      <div id="sb-encoding-popup" style="display:none;position:absolute;bottom:calc(100% + 6px);right:0;background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:5px;min-width:200px;box-shadow:0 -10px 35px rgba(0,0,0,0.6);z-index:9999">
        <div style="padding:4px 8px 6px;color:var(--text-faint);font-size:10px;letter-spacing:.08em;text-transform:uppercase">File Encoding</div>
        <div class="storage-option" onclick="setFileEncoding(event,'UTF-8')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">UTF-8</div><div class="storage-option-desc">Unicode (recommended)</div></div><span class="storage-option-check" id="enc-check-UTF-8">✓</span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'UTF-16 LE')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">UTF-16 LE</div><div class="storage-option-desc">Unicode little-endian</div></div><span class="storage-option-check" id="enc-check-UTF-16 LE"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'UTF-16 BE')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">UTF-16 BE</div><div class="storage-option-desc">Unicode big-endian</div></div><span class="storage-option-check" id="enc-check-UTF-16 BE"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'ISO-8859-1')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">ISO-8859-1 (Latin-1)</div><div class="storage-option-desc">Western European</div></div><span class="storage-option-check" id="enc-check-ISO-8859-1"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'Windows-1252')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">Windows-1252</div><div class="storage-option-desc">Western Windows codepage</div></div><span class="storage-option-check" id="enc-check-Windows-1252"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'Shift-JIS')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">Shift-JIS</div><div class="storage-option-desc">Japanese</div></div><span class="storage-option-check" id="enc-check-Shift-JIS"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'EUC-JP')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">EUC-JP</div><div class="storage-option-desc">Japanese Unix</div></div><span class="storage-option-check" id="enc-check-EUC-JP"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'GB2312')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">GB2312</div><div class="storage-option-desc">Simplified Chinese</div></div><span class="storage-option-check" id="enc-check-GB2312"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'Big5')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">Big5</div><div class="storage-option-desc">Traditional Chinese</div></div><span class="storage-option-check" id="enc-check-Big5"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'KOI8-R')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">KOI8-R</div><div class="storage-option-desc">Russian Cyrillic</div></div><span class="storage-option-check" id="enc-check-KOI8-R"></span></div>
        <div class="storage-option" onclick="setFileEncoding(event,'ASCII')"><span class="storage-option-icon">🔤</span><div class="storage-option-text"><div class="storage-option-name">ASCII</div><div class="storage-option-desc">7-bit US ASCII</div></div><span class="storage-option-check" id="enc-check-ASCII"></span></div>
      </div>
    </td>
    <td id="sb-indent" title="Indentation">Spaces: 2</td>
    <td id="sb-pos" title="Cursor position">Ln 1, Col 1</td>
    <td id="sb-storage" onclick="toggleSbStorage()" title="Storage backend">
      💾 <span id="sb-storage-mode">IndexedDB</span>
      <div id="sb-storage-popup">
        <div style="padding:4px 8px 6px;color:var(--text-faint);font-size:10px;letter-spacing:.08em;text-transform:uppercase">Storage Backend</div>
        <div class="storage-option active" onclick="switchStorageMode(event,'indexed')">
          <span class="storage-option-icon">🗄️</span>
          <div class="storage-option-text">
            <div class="storage-option-name">IndexedDB</div>
            <div class="storage-option-desc">Persistent, fast (recommended)</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" onclick="switchStorageMode(event,'local')">
          <span class="storage-option-icon">📦</span>
          <div class="storage-option-text">
            <div class="storage-option-name">LocalStorage</div>
            <div class="storage-option-desc">Persistent, 5-10 MB limit</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" onclick="switchStorageMode(event,'memory')">
          <span class="storage-option-icon">⚡</span>
          <div class="storage-option-text">
            <div class="storage-option-name">Memory</div>
            <div class="storage-option-desc">Volatile, lost on refresh</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
        <div class="storage-option" id="storage-opt-folder" onclick="switchStorageToFolder(event)">
          <span class="storage-option-icon">🗂️</span>
          <div class="storage-option-text">
            <div class="storage-option-name">Real Folder</div>
            <div class="storage-option-desc">Read/write a folder on disk</div>
          </div>
          <span class="storage-option-check">✓</span>
        </div>
      </div>
    </td>
    <td id="sb-notif" title="Notifications">
      🔔 <span id="sb-notif-badge">0</span>
    </td>
  </tr>
</table>

<!-- Context menu -->
<div id="ctx-menu">
  <div class="ctx-item" id="ctx-open">    <span class="ctx-icon">📂</span>Open</div>
  <div class="ctx-item" id="ctx-rename">  <span class="ctx-icon">✏️</span>Rename</div>
  <hr>
  <div class="ctx-item" id="ctx-newfile"> <span class="ctx-icon">📄</span>New File Here</div>
  <div class="ctx-item" id="ctx-newfolder"><span class="ctx-icon">📁</span>New Folder Here</div>
  <hr>
  <div class="ctx-item danger" id="ctx-delete"><span class="ctx-icon">🗑</span>Delete</div>
</div>

<!-- Dialog -->
<div id="dialog-overlay">
  <div id="dialog">
    <h3 id="dialog-title">New File</h3>
    <input type="text" id="dialog-input" placeholder="filename.js" autocomplete="off" spellcheck="false">
    <div class="dialog-btns">
      <button class="dbtn dbtn-cancel" onclick="(function(){var fn=_confirmCancel;closeDialog();if(fn)fn();})()">Cancel</button>
      <button class="dbtn dbtn-ok"     id="dialog-ok">Create</button>
    </div>
  </div>
</div>


<!-- ── Settings Modal ── -->
<div id="settings-overlay">
  <div id="settings-modal">
    <div id="settings-header">
      <h2>⚙️ SETTINGS</h2>
      <div id="settings-close" onclick="closeSettings()">✕</div>
    </div>
    <div id="settings-body">
      <div id="settings-nav">
        <div class="setnav-item active" onclick="showSettingsSection('editor')" data-sec="editor"><span class="setnav-icon">📝</span>Editor</div>
        <div class="setnav-item" onclick="showSettingsSection('appearance')" data-sec="appearance"><span class="setnav-icon">🎨</span>Appearance</div>
        <div class="setnav-item" onclick="showSettingsSection('preview')" data-sec="preview"><span class="setnav-icon">▶</span>Run &amp; Preview</div>
        <div class="setnav-item" onclick="showSettingsSection('keybinds')" data-sec="keybinds"><span class="setnav-icon">⌨️</span>Keybinds</div>
        <div class="setnav-item" onclick="showSettingsSection('advanced')" data-sec="advanced"><span class="setnav-icon">⚗️</span>Advanced</div>
        <div class="setnav-item" onclick="showSettingsSection('about')" data-sec="about"><span class="setnav-icon">ℹ️</span>About</div>
      </div>
      <div id="settings-content">

        <!-- EDITOR -->
        <div class="settings-section active" id="set-sec-editor">
          <h3>Editor</h3>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Font Size</div><div class="set-label-desc">Editor font size in pixels</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="10" max="24" value="13" id="set-font-size" oninput="document.getElementById('set-font-size-val').textContent=this.value+'px';applySettingLive('fontSize',+this.value)">
              <span class="set-range-val" id="set-font-size-val">13px</span>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Tab Size</div><div class="set-label-desc">Number of spaces per tab</div></div>
            <div class="set-control">
              <select class="set-select" id="set-tab-size" onchange="applySettingLive('tabSize',+this.value)">
                <option value="2">2 spaces</option>
                <option value="4" selected>4 spaces</option>
                <option value="8">8 spaces</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Word Wrap</div><div class="set-label-desc">Wrap long lines in the editor</div></div>
            <div class="set-control"><div class="set-toggle" id="set-word-wrap" onclick="toggleSettingToggle(this,'wordWrap')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Minimap</div><div class="set-label-desc">Show the code minimap on the right</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-minimap" onclick="toggleSettingToggle(this,'minimap')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Line Numbers</div><div class="set-label-desc">Show line numbers in the gutter</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-line-numbers" onclick="toggleSettingToggle(this,'lineNumbers')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Cursor Blinking</div><div class="set-label-desc">Cursor animation style</div></div>
            <div class="set-control">
              <select class="set-select" id="set-cursor-blink" onchange="applySettingLive('cursorBlinking',this.value)">
                <option value="blink">Blink</option>
                <option value="smooth" selected>Smooth</option>
                <option value="phase">Phase</option>
                <option value="expand">Expand</option>
                <option value="solid">Solid</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Cursor Style</div><div class="set-label-desc">Shape of the text cursor</div></div>
            <div class="set-control">
              <select class="set-select" id="set-cursor-style" onchange="applySettingLive('cursorStyle',this.value)">
                <option value="line" selected>Line</option>
                <option value="block">Block</option>
                <option value="underline">Underline</option>
                <option value="line-thin">Line Thin</option>
                <option value="block-outline">Block Outline</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Auto Save</div><div class="set-label-desc">Automatically save files on edit</div></div>
            <div class="set-control"><div class="set-toggle" id="set-auto-save" onclick="toggleSettingToggle(this,'autoSave')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Format on Save</div><div class="set-label-desc">Auto-format when saving</div></div>
            <div class="set-control"><div class="set-toggle" id="set-fmt-save" onclick="toggleSettingToggle(this,'formatOnSave')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Bracket Pair Colorization</div><div class="set-label-desc">Color matching brackets</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-bracket-color" onclick="toggleSettingToggle(this,'bracketColorization')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Smooth Scrolling</div><div class="set-label-desc">Animate editor scrolling</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-smooth-scroll" onclick="toggleSettingToggle(this,'smoothScrolling')"></div></div>
          </div>
        </div>

        <!-- APPEARANCE -->
        <div class="settings-section" id="set-sec-appearance">
          <h3>Appearance</h3>

          <!-- Color Themes -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Color Theme</div><div class="set-label-desc">Overall IDE color palette</div></div>
            <div class="set-control">
              <div class="set-theme-grid" id="set-theme-grid">
                <div class="set-theme-card selected" data-theme="void" onclick="applyTheme('void',this)">
                  <div class="stc-preview" style="background:#080b0f;border-color:#00d4ff">
                    <div style="background:#00d4ff;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#3d5266;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#3ddc84;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>VOID Dark</span>
                </div>
                <div class="set-theme-card" data-theme="midnight" onclick="applyTheme('midnight',this)">
                  <div class="stc-preview" style="background:#0a0a1a;border-color:#7c6fcd">
                    <div style="background:#7c6fcd;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#3d3d5c;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#c792ea;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Midnight</span>
                </div>
                <div class="set-theme-card" data-theme="forest" onclick="applyTheme('forest',this)">
                  <div class="stc-preview" style="background:#0d1a0d;border-color:#3ddc84">
                    <div style="background:#3ddc84;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#1a3320;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#f0c040;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Forest</span>
                </div>
                <div class="set-theme-card" data-theme="rose" onclick="applyTheme('rose',this)">
                  <div class="stc-preview" style="background:#120a10;border-color:#ff4c6a">
                    <div style="background:#ff4c6a;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#3d1a24;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#ff79c6;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Rose</span>
                </div>
                <div class="set-theme-card" data-theme="amber" onclick="applyTheme('amber',this)">
                  <div class="stc-preview" style="background:#110d00;border-color:#ffb347">
                    <div style="background:#ffb347;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#332500;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#f0c040;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Amber</span>
                </div>
                <div class="set-theme-card" data-theme="ice" onclick="applyTheme('ice',this)">
                  <div class="stc-preview" style="background:#071018;border-color:#86e1fb">
                    <div style="background:#86e1fb;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#0e2030;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#8be9fd;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Ice</span>
                </div>
                <div class="set-theme-card" data-theme="dracula" onclick="applyTheme('dracula',this)">
                  <div class="stc-preview" style="background:#282a36;border-color:#bd93f9">
                    <div style="background:#bd93f9;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#44475a;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#50fa7b;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Dracula</span>
                </div>
                <div class="set-theme-card" data-theme="monokai" onclick="applyTheme('monokai',this)">
                  <div class="stc-preview" style="background:#272822;border-color:#a6e22e">
                    <div style="background:#a6e22e;width:30%;height:3px;border-radius:1px"></div>
                    <div style="background:#49483e;width:60%;height:2px;margin-top:3px;border-radius:1px"></div>
                    <div style="background:#f92672;width:40%;height:2px;margin-top:2px;border-radius:1px"></div>
                  </div>
                  <span>Monokai</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Accent Color -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Accent Color</div><div class="set-label-desc">Override the theme accent color</div></div>
            <div class="set-control">
              <div class="set-color-swatches" id="set-accent-swatches">
                <div class="set-swatch selected" style="background:#00d4ff" data-color="#00d4ff" onclick="setAccentColor('#00d4ff',this)" title="Cyan"></div>
                <div class="set-swatch" style="background:#3ddc84" data-color="#3ddc84" onclick="setAccentColor('#3ddc84',this)" title="Green"></div>
                <div class="set-swatch" style="background:#c792ea" data-color="#c792ea" onclick="setAccentColor('#c792ea',this)" title="Purple"></div>
                <div class="set-swatch" style="background:#ff4c6a" data-color="#ff4c6a" onclick="setAccentColor('#ff4c6a',this)" title="Red"></div>
                <div class="set-swatch" style="background:#ffb347" data-color="#ffb347" onclick="setAccentColor('#ffb347',this)" title="Orange"></div>
                <div class="set-swatch" style="background:#f0c040" data-color="#f0c040" onclick="setAccentColor('#f0c040',this)" title="Yellow"></div>
                <div class="set-swatch" style="background:#ff79c6" data-color="#ff79c6" onclick="setAccentColor('#ff79c6',this)" title="Pink"></div>
                <div class="set-swatch" style="background:#86e1fb" data-color="#86e1fb" onclick="setAccentColor('#86e1fb',this)" title="Light Blue"></div>
                <div class="set-swatch" style="background:#50fa7b" data-color="#50fa7b" onclick="setAccentColor('#50fa7b',this)" title="Bright Green"></div>
                <div class="set-swatch" style="background:#bd93f9" data-color="#bd93f9" onclick="setAccentColor('#bd93f9',this)" title="Lavender"></div>
                <input type="color" class="set-swatch set-swatch-custom" value="#00d4ff" title="Custom color"
                  oninput="setAccentColor(this.value, this)" style="cursor:crosshair;padding:1px">
              </div>
            </div>
          </div>

          <!-- UI Font -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">UI Font</div><div class="set-label-desc">Font for menus, sidebar, panels</div></div>
            <div class="set-control">
              <select class="set-select" id="set-ui-font-family" onchange="applySettingLive('uiFontFamily',this.value)">
                <option value="'JetBrains Mono', monospace" selected>JetBrains Mono</option>
                <option value="'Fira Code', monospace">Fira Code</option>
                <option value="'Cascadia Code', monospace">Cascadia Code</option>
                <option value="'Consolas', monospace">Consolas</option>
                <option value="system-ui, sans-serif">System UI</option>
                <option value="'Rajdhani', sans-serif">Rajdhani</option>
              </select>
            </div>
          </div>

          <!-- UI Font Size -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">UI Font Size</div><div class="set-label-desc">Font size for the IDE chrome</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="10" max="16" value="13" id="set-ui-font" oninput="document.getElementById('set-ui-font-val').textContent=this.value+'px';applySettingLive('uiFontSize',+this.value)">
              <span class="set-range-val" id="set-ui-font-val">13px</span>
            </div>
          </div>

          <!-- Sidebar Width -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Sidebar Width</div><div class="set-label-desc">Width of the file explorer sidebar</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="140" max="400" value="220" id="set-sidebar-w" oninput="document.getElementById('set-sidebar-w-val').textContent=this.value+'px';applySettingLive('sidebarWidth',+this.value)">
              <span class="set-range-val" id="set-sidebar-w-val">220px</span>
            </div>
          </div>

          <!-- Panel Height -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Panel Height</div><div class="set-label-desc">Default bottom panel height</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="80" max="500" value="200" id="set-panel-h" oninput="document.getElementById('set-panel-h-val').textContent=this.value+'px';applySettingLive('panelHeight',+this.value)">
              <span class="set-range-val" id="set-panel-h-val">200px</span>
            </div>
          </div>

          <!-- Visual Effects -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Scanlines Effect</div><div class="set-label-desc">Retro CRT scanline overlay</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-scanlines" onclick="toggleSettingToggle(this,'scanlines')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Glow Effects</div><div class="set-label-desc">Neon glow on accent elements</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-glow" onclick="toggleAppearanceFx('glow',this)"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Smooth Animations</div><div class="set-label-desc">Transitions and hover animations</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-animations" onclick="toggleAppearanceFx('animations',this)"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Compact Mode</div><div class="set-label-desc">Reduce padding and spacing</div></div>
            <div class="set-control"><div class="set-toggle" id="set-compact" onclick="toggleAppearanceFx('compact',this)"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Activity Bar Labels</div><div class="set-label-desc">Show text labels under activity bar icons</div></div>
            <div class="set-control"><div class="set-toggle" id="set-act-labels" onclick="toggleAppearanceFx('actLabels',this)"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Tab Style</div><div class="set-label-desc">How editor tabs look</div></div>
            <div class="set-control">
              <select class="set-select" id="set-tab-style" onchange="applySettingLive('tabStyle',this.value)">
                <option value="default" selected>Default (top border)</option>
                <option value="filled">Filled</option>
                <option value="minimal">Minimal (underline)</option>
                <option value="pill">Pill</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Status Bar Style</div><div class="set-label-desc">Bottom status bar appearance</div></div>
            <div class="set-control">
              <select class="set-select" id="set-sb-style" onchange="applyStatusBarStyle(this.value)">
                <option value="accent" selected>Accent (colored)</option>
                <option value="dark">Dark</option>
                <option value="glass">Glass</option>
                <option value="gradient">Gradient</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Indent Guides</div><div class="set-label-desc">Show indentation guide lines in sidebar</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-indent-guides" onclick="toggleSettingToggle(this,'indentGuides')"></div></div>
          </div>

          <!-- Border Radius -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Border Radius</div><div class="set-label-desc">UI element corner rounding</div></div>
            <div class="set-control">
              <select class="set-select" id="set-border-radius" onchange="applyBorderRadius(this.value)">
                <option value="0">Sharp (0px)</option>
                <option value="3" selected>Default (3px)</option>
                <option value="6">Rounded (6px)</option>
                <option value="10">Very Rounded (10px)</option>
              </select>
            </div>
          </div>

          <!-- Line Highlight -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Line Highlight Style</div><div class="set-label-desc">How the current line is highlighted</div></div>
            <div class="set-control">
              <select class="set-select" id="set-line-highlight" onchange="applySettingLive('lineHighlight',this.value)">
                <option value="line" selected>Full Line</option>
                <option value="gutter">Gutter Only</option>
                <option value="all">Line + Gutter</option>
                <option value="none">None</option>
              </select>
            </div>
          </div>

          <!-- Cursor Color -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Cursor Color</div><div class="set-label-desc">Override editor cursor color</div></div>
            <div class="set-control" style="display:flex;align-items:center;gap:8px">
              <div class="set-color-swatches" id="set-cursor-swatches">
                <div class="set-swatch selected" style="background:#00d4ff" data-color="#00d4ff" onclick="setCursorColor('#00d4ff',this)" title="Cyan"></div>
                <div class="set-swatch" style="background:#ffffff" data-color="#ffffff" onclick="setCursorColor('#ffffff',this)" title="White"></div>
                <div class="set-swatch" style="background:#3ddc84" data-color="#3ddc84" onclick="setCursorColor('#3ddc84',this)" title="Green"></div>
                <div class="set-swatch" style="background:#ff4c6a" data-color="#ff4c6a" onclick="setCursorColor('#ff4c6a',this)" title="Red"></div>
                <div class="set-swatch" style="background:#ffb347" data-color="#ffb347" onclick="setCursorColor('#ffb347',this)" title="Orange"></div>
                <div class="set-swatch" style="background:#c792ea" data-color="#c792ea" onclick="setCursorColor('#c792ea',this)" title="Purple"></div>
                <input type="color" class="set-swatch set-swatch-custom" value="#00d4ff" title="Custom cursor color"
                  oninput="setCursorColor(this.value,this)" style="cursor:crosshair;padding:1px">
              </div>
            </div>
          </div>

          <!-- Letter Spacing -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Letter Spacing</div><div class="set-label-desc">Editor font letter spacing (px)</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="-1" max="4" step="0.5" value="0" id="set-letter-spacing" oninput="document.getElementById('set-letter-spacing-val').textContent=this.value+'px';applySettingLive('letterSpacing',+this.value)">
              <span class="set-range-val" id="set-letter-spacing-val">0px</span>
            </div>
          </div>

          <!-- Line Height -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Line Height</div><div class="set-label-desc">Editor line height multiplier</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="1.0" max="2.5" step="0.1" value="1.5" id="set-line-height" oninput="document.getElementById('set-line-height-val').textContent=this.value;applySettingLive('lineHeight',+this.value)">
              <span class="set-range-val" id="set-line-height-val">1.5</span>
            </div>
          </div>

          <!-- Statusbar Encoding display -->
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Show Encoding in Status Bar</div><div class="set-label-desc">Display and change file encoding in the status bar</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-show-encoding" onclick="toggleSettingToggle(this,'showEncoding')"></div></div>
          </div>
        </div>

        <!-- RUN & PREVIEW -->
        <div class="settings-section" id="set-sec-preview">
          <h3>Run &amp; Preview</h3>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Fetch Preloader</div><div class="set-label-desc">Before running, scan JS files for fetch() calls and pre-resolve as blobs</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-fetch-preload" onclick="toggleSettingToggle(this,'fetchPreload')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Fetch Scan Depth</div><div class="set-label-desc">How many levels deep to follow JS imports when scanning for fetches</div></div>
            <div class="set-control">
              <select class="set-select" id="set-fetch-depth" onchange="applySettingLive('fetchDepth',+this.value)">
                <option value="1">1 level</option>
                <option value="3" selected>3 levels</option>
                <option value="5">5 levels</option>
                <option value="10">10 levels (slow)</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Auto-switch to Preview</div><div class="set-label-desc">Switch to preview tab when running</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-auto-preview" onclick="toggleSettingToggle(this,'autoPreview')"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">iframe Sandbox</div><div class="set-label-desc">Sandbox permissions for the preview iframe</div></div>
            <div class="set-control">
              <select class="set-select" id="set-sandbox" onchange="applySettingLive('iframeSandbox',this.value)">
                <option value="allow-scripts allow-forms allow-modals allow-popups">Standard</option>
                <option value="allow-scripts allow-forms allow-modals allow-popups allow-same-origin">Allow Same-Origin</option>
                <option value="allow-scripts">Scripts Only</option>
              </select>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Live Reload Debounce</div><div class="set-label-desc">Milliseconds to wait before live-reloading after an edit</div></div>
            <div class="set-control" style="display:flex;align-items:center">
              <input class="set-range" type="range" min="100" max="2000" step="100" value="500" id="set-live-debounce" oninput="document.getElementById('set-live-debounce-val').textContent=this.value+'ms';applySettingLive('liveDebounce',+this.value)">
              <span class="set-range-val" id="set-live-debounce-val">500ms</span>
            </div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Webpack / CommonJS Compat</div><div class="set-label-desc">Inject module/exports/require/__webpack_require__ shim into preloaded JS blobs — enables webpack bundles and CommonJS modules to run in blob context</div></div>
            <div class="set-control"><div class="set-toggle on" id="set-webpack-compat" onclick="toggleSettingToggle(this,'webpackCompat');_webpackCompatEnabled=ideSettings.webpackCompat"></div></div>
          </div>
          <div class="set-row">
            <div class="set-label"><div class="set-label-title">Preload Base Directory</div><div class="set-label-desc">Fallback directory for resolving asset paths that can't be found relative to the HTML file (e.g. /public or /dist)</div></div>
            <div class="set-control">
              <button class="fp-btn" onclick="promptSetBaseDir()" style="min-width:90px" id="set-basedir-btn">📂 Set…</button>
            </div>
          </div>

        </div><!-- end set-sec-preview -->

        <!-- KEYBINDS -->
        <div class="settings-section" id="set-sec-keybinds">
          <h3>Keyboard Shortcuts</h3>
          <div style="font-size:11px;color:var(--text-faint);margin-bottom:12px">These are the current keyboard shortcuts. Custom bindings coming soon.</div>
          <div id="keybind-list"></div>
        </div>

        <!-- ABOUT -->
        <div class="settings-section" id="set-sec-about">
          <h3>About VOID IDE</h3>
          <div style="text-align:center;padding:20px 0">
            <div style="font-family:'Rajdhani',sans-serif;font-size:42px;font-weight:700;color:var(--accent);letter-spacing:0.2em;text-shadow:var(--glow)">VOID</div>
            <div style="font-size:11px;color:var(--text-dim);margin-top:4px;letter-spacing:0.1em">BROWSER IDE v0.21 Alpha</div>
          </div>
          <div style="font-size:11.5px;color:var(--text-dim);line-height:1.8">
            <p style="margin-bottom:12px">VOID is a fully offline, browser-based IDE with a virtual filesystem, Monaco editor, and a powerful asset bundler that lets you run HTML/CSS/JS projects entirely within the browser — no server required.</p>
            <p style="margin-bottom:12px">Features: VFS with IndexedDB/LocalStorage/Memory/Real Folder storage, JS module bundling, CSS inlining, binary asset embedding, fetch() bridge, live reload, ZIP import/export, hex editor, shell emulator, proxy panel, and the <span style="color:var(--accent)">fetch pre-loader</span> that resolves fetch() calls in JS files to blob URLs before execution.</p>
          </div>

          <!-- Contributors -->
          <div style="margin-top:16px;padding:12px 0;border-top:1px solid var(--border)">
            <div style="font-size:10px;color:var(--text-faint);letter-spacing:.1em;text-transform:uppercase;margin-bottom:10px">Contributors</div>
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;padding:8px 10px;background:rgba(var(--accent-rgb),0.06);border-radius:6px;border:1px solid rgba(var(--accent-rgb),0.2)">
              <div style="font-size:22px">🤖</div>
              <div>
                <div style="font-size:12px;color:var(--accent);font-weight:700;letter-spacing:.04em">Claude (Anthropic)</div>
                <div style="font-size:10px;color:var(--text-dim);margin-top:2px">Main Contributor — Architecture, features, bug fixes, v0.21 release</div>
              </div>
              <div style="margin-left:auto;font-size:9px;padding:2px 7px;border-radius:10px;background:rgba(var(--accent-rgb),0.15);color:var(--accent);font-weight:700;letter-spacing:.05em">MAIN</div>
            </div>
          </div>

          <!-- v0.21 Changelog -->
          <div style="margin-top:8px;padding:12px 0;border-top:1px solid var(--border)">
            <div style="font-size:10px;color:var(--text-faint);letter-spacing:.1em;text-transform:uppercase;margin-bottom:8px">v0.21 Changelog</div>
            <div style="font-size:11px;color:var(--text-dim);line-height:2">
              <div>✓ <span style="color:var(--green)">Fixed</span> — All View menu commands now fully functional</div>
              <div>✓ <span style="color:var(--green)">Fixed</span> — All Run menu commands now fully functional</div>
              <div>✓ <span style="color:var(--green)">Fixed</span> — All Tools menu commands now fully functional</div>
              <div>✓ <span style="color:var(--green)">New</span> — File encoding picker (UTF-8, UTF-16, ISO-8859-1, Shift-JIS, GB2312, Big5, KOI8-R, ASCII + more)</div>
              <div>✓ <span style="color:var(--green)">New</span> — UI font size scaling (Ctrl+Shift+=/−)</div>
              <div>✓ <span style="color:var(--green)">New</span> — Editor font size reset (Ctrl+0)</div>
              <div>✓ <span style="color:var(--green)">New</span> — Page zoom In/Out/Reset</div>
              <div>✓ <span style="color:var(--green)">New</span> — Sort Lines Ascending/Descending</div>
              <div>✓ <span style="color:var(--green)">New</span> — Trim Trailing Whitespace</div>
              <div>✓ <span style="color:var(--green)">New</span> — Move Lines Up/Down</div>
              <div>✓ <span style="color:var(--green)">New</span> — Go to Symbol in file</div>
              <div>✓ <span style="color:var(--green)">New</span> — Toggle Breadcrumbs</div>
              <div>✓ <span style="color:var(--green)">New</span> — File Info/Stats panel</div>
              <div>✓ <span style="color:var(--green)">New</span> — Run in New Window</div>
              <div>✓ <span style="color:var(--green)">New</span> — Clear Preview command</div>
              <div>✓ <span style="color:var(--green)">New</span> — Convert/Reload with Encoding in Tools menu</div>
              <div>✓ <span style="color:var(--green)">New</span> — More appearance settings: border radius, cursor color, line highlight style</div>
            </div>
          </div>

          <div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border)">
            <div style="font-size:10px;color:var(--text-faint);display:grid;grid-template-columns:1fr 1fr;gap:6px">
              <span>Monaco Editor: 0.44.0</span>
              <span>BrowserFS: 2.0.0</span>
              <span>JSZip: 3.10.1</span>
              <span>xterm.js: 5.3.0</span>
              <span>Storage: <span id="set-about-storage" style="color:var(--accent)">—</span></span>
            </div>
          </div>
        </div>

        <!-- ADVANCED MONACO CONFIG -->
        <div class="settings-section" id="set-sec-advanced">
          <h3>Advanced Monaco Config <span style="font-size:10px;color:var(--text-faint);font-weight:400;margin-left:6px">about:config style</span></h3>

          <!-- Warning banner -->
          <div id="adv-warning" style="display:flex;align-items:center;gap:10px;background:rgba(240,192,64,0.1);border:1px solid rgba(240,192,64,0.3);border-radius:5px;padding:10px 14px;margin-bottom:14px;font-size:11px;color:var(--yellow)">
            <span style="font-size:18px">⚠</span>
            <div><b>Caution:</b> These are raw Monaco editor options. Incorrect values may break the editor. Changes apply immediately. <span style="color:var(--text-dim)">The editor auto-recovers if a value causes an error.</span></div>
            <button onclick="document.getElementById('adv-warning').style.display='none'" style="margin-left:auto;background:none;border:none;color:var(--text-faint);cursor:pointer;font-size:14px;padding:0 4px">✕</button>
          </div>

          <!-- Toolbar -->
          <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap">
            <input id="adv-search" type="text" placeholder="🔍 Filter options…" autocomplete="off"
              style="flex:1;min-width:160px;background:var(--bg0);border:1px solid var(--border2);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px;padding:6px 10px;border-radius:4px;outline:none;"
              oninput="advFilter(this.value)">
            <select id="adv-category-filter" onchange="advFilter(document.getElementById('adv-search').value)"
              style="background:var(--bg0);border:1px solid var(--border2);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px;padding:5px 8px;border-radius:4px;outline:none;cursor:pointer">
              <option value="">All Categories</option>
              <option value="font">Font</option>
              <option value="cursor">Cursor</option>
              <option value="scroll">Scroll</option>
              <option value="indent">Indent</option>
              <option value="folding">Folding</option>
              <option value="suggest">Suggest / Intellisense</option>
              <option value="find">Find</option>
              <option value="minimap">Minimap</option>
              <option value="render">Rendering</option>
              <option value="perf">Performance</option>
              <option value="other">Other</option>
            </select>
            <button onclick="advShowOnlyModified()" id="adv-btn-modified"
              style="background:var(--bg0);border:1px solid var(--border2);color:var(--text-dim);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px 10px;border-radius:4px;cursor:pointer;white-space:nowrap">
              ★ Modified Only
            </button>
            <button onclick="advResetAll()"
              style="background:var(--bg0);border:1px solid rgba(255,76,106,0.4);color:var(--red);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px 10px;border-radius:4px;cursor:pointer;white-space:nowrap">
              ↺ Reset All
            </button>
          </div>

          <!-- JSON import/export bar -->
          <div style="display:flex;gap:8px;margin-bottom:14px;flex-wrap:wrap">
            <button onclick="advExportJSON()"
              style="background:rgba(var(--accent-rgb),0.1);border:1px solid rgba(var(--accent-rgb),0.3);color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px 12px;border-radius:4px;cursor:pointer">
              ↓ Export JSON
            </button>
            <button onclick="advImportJSON()"
              style="background:rgba(var(--accent-rgb),0.1);border:1px solid rgba(var(--accent-rgb),0.3);color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px 12px;border-radius:4px;cursor:pointer">
              ↑ Import JSON
            </button>
            <button onclick="advCopyJSON()"
              style="background:rgba(var(--accent-rgb),0.1);border:1px solid rgba(var(--accent-rgb),0.3);color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:10px;padding:5px 12px;border-radius:4px;cursor:pointer">
              ⎘ Copy JSON
            </button>
            <div id="adv-count" style="margin-left:auto;font-size:10px;color:var(--text-faint);align-self:center"></div>
          </div>

          <!-- Option rows container -->
          <div id="adv-options-list" style="display:flex;flex-direction:column;gap:1px;font-family:'JetBrains Mono',monospace;font-size:11px">
            <!-- populated by JS -->
          </div>

          <div id="adv-no-results" style="display:none;text-align:center;padding:30px;color:var(--text-faint);font-size:12px">
            No options match your filter.
          </div>
        </div>


    <div id="settings-footer">
      <button class="setbtn setbtn-reset" onclick="resetSettings()">Reset Defaults</button>
      <button class="setbtn setbtn-apply" onclick="closeSettings()">Done</button>
    </div>
  </div>
</div>

<!-- ── ZIP drag-drop overlay ── -->
<div id="zip-drop-overlay">
  <div id="zip-drop-inner">
    <div id="zip-drop-icon">📦</div>
    <div id="zip-drop-title">Drop ZIP to Import</div>
    <div id="zip-drop-sub">Release to extract all files into the filesystem</div>
  </div>
</div>

<!-- ZIP progress modal -->
<div id="zip-modal-overlay">
  <div id="zip-modal">
    <div id="zip-modal-title">Importing ZIP</div>
    <div id="zip-modal-filename"></div>
    <div id="zip-progress-track"><div id="zip-progress-bar"></div></div>
    <div id="zip-progress-label">Reading archive…</div>
    <div id="zip-file-list"></div>
  </div>
</div>

<!-- JSZip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- BrowserFS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/BrowserFS/2.0.0/browserfs.min.js"></script>
<!-- Monaco loader -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>

<script>
'use strict';

// ═══════════════════════════════════════════════════════════════════
//  GLOBALS
// ═══════════════════════════════════════════════════════════════════
let FS = null;          // BrowserFS fs module

// ═══════════════════════════════════════════════════════════════════
//  STORAGE MODE SWITCHER
// ═══════════════════════════════════════════════════════════════════
let currentStorageMode = 'indexed'; // indexed, local, or memory

function toggleStorageSelector() {
  var sel = document.getElementById('storage-selector');
  if (sel) sel.classList.toggle('visible');
  event && event.stopPropagation();
}

function toggleSbStorage() {
  const el = document.getElementById('sb-storage');
  if (el) el.classList.toggle('open');
  event && event.stopPropagation();
}

// Close storage popups when clicking outside
document.addEventListener('click', (e) => {
  const ind = document.getElementById('storage-indicator');
  if (ind && !ind.contains(e.target)) {
    const sel = document.getElementById('storage-selector');
    if (sel) sel.classList.remove('visible');
  }
  const stor = document.getElementById('sb-storage');
  if (stor && !stor.contains(e.target)) stor.classList.remove('open');
});

async function switchStorageMode(event, mode) {
  event.stopPropagation();
  const sbStor = document.getElementById('sb-storage');
  if (sbStor) sbStor.classList.remove('open');
  const sel = document.getElementById('storage-selector');
  if (sel) sel.classList.remove('visible');
  
  if (mode === currentStorageMode) return;
  
  showConfirm('Switch to ' + mode.toUpperCase() + ' storage?', 'Current unsaved changes will be lost and the IDE will reload.', () => {
    try { localStorage.setItem('void-storage-mode', mode); } catch(e) {}
    termLog('sys', 'Switching to ' + mode.toUpperCase() + ' storage...');
    setTimeout(() => location.reload(), 500);
  });
}

// Init storage mode from saved preference
function initStorageMode() {
  try {
    var saved = localStorage.getItem('void-storage-mode');
    if (saved && ['indexed', 'local', 'memory'].includes(saved)) {
      currentStorageMode = saved;
      var labels = { indexed: 'IndexedDB', local: 'LocalStorage', memory: 'Memory' };
      // Update new statusbar storage display
      const sbMode = document.getElementById('sb-storage-mode');
      if (sbMode) sbMode.textContent = labels[saved];
      // Update old element if still present (compat)
      const oldMode = document.getElementById('storage-mode');
      if (oldMode) oldMode.textContent = labels[saved];
      document.querySelectorAll('.storage-option').forEach(opt => opt.classList.remove('active'));
      const el = document.querySelector('.storage-option[onclick*="' + saved + '"]');
      if (el) el.classList.add('active');
    }
  } catch(e) {}
}

// ═══════════════════════════════════════════════════════════════════
//  FOLDER STORAGE — real directory as VFS backend
// ═══════════════════════════════════════════════════════════════════
let folderStorageRoot = null;   // FileSystemDirectoryHandle
let folderStorageActive = false;

// Navigate to a subpath within the folder root, creating dirs as needed
async function folderNavTo(pathStr, create) {
  const parts = pathStr.replace(/^\/+|\/+$/g,'').split('/').filter(Boolean);
  let dir = folderStorageRoot;
  for (const part of parts) {
    dir = await dir.getDirectoryHandle(part, { create: !!create });
  }
  return dir;
}

async function folderGetFileHandle(pathStr, create) {
  const parts = pathStr.replace(/^\/+|\/+$/g,'').split('/').filter(Boolean);
  const fileName = parts.pop();
  let dir = folderStorageRoot;
  for (const part of parts) {
    dir = await dir.getDirectoryHandle(part, { create: !!create });
  }
  return dir.getFileHandle(fileName, { create: !!create });
}

// Folder-backed FS helpers (same signatures as BrowserFS ones)
async function folderReadFile(p) {
  const h = await folderGetFileHandle(p, false);
  const f = await h.getFile();
  const isBin = /\.(png|jpg|jpeg|gif|webp|bmp|ico|woff2?|ttf|otf|mp3|mp4|wav|ogg|pdf|zip|gz|wasm|avif|svg)$/i.test(p);
  if (isBin) {
    const buf = await f.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let b64 = ''; const chunk = 8192;
    for (let i = 0; i < bytes.length; i += chunk)
      b64 += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i+chunk, bytes.length)));
    const ext = p.split('.').pop().toLowerCase();
    return 'data:' + getMime(ext) + ';base64,' + btoa(b64);
  }
  return f.text();
}

async function folderWriteFile(p, data) {
  const h = await folderGetFileHandle(p, true);
  const w = await h.createWritable();
  if (typeof data === 'string' && data.startsWith('data:') && data.includes(';base64,')) {
    const b64 = data.split(';base64,')[1];
    await w.write(Uint8Array.from(atob(b64), c => c.charCodeAt(0)));
  } else {
    await w.write(data);
  }
  await w.close();
}

async function folderReaddir(p) {
  const dir = p === '/' ? folderStorageRoot : await folderNavTo(p, false);
  const names = [];
  for await (const name of dir.keys()) names.push(name);
  return names;
}

async function folderStat(p) {
  const parts = p.replace(/^\/+|\/+$/g,'').split('/').filter(Boolean);
  if (!parts.length) return { isDirectory: () => true };
  const name = parts[parts.length - 1];
  let dir = folderStorageRoot;
  for (const part of parts.slice(0,-1)) dir = await dir.getDirectoryHandle(part, { create: false });
  try {
    await dir.getFileHandle(name, { create: false });
    return { isDirectory: () => false };
  } catch(e) {
    await dir.getDirectoryHandle(name, { create: false });
    return { isDirectory: () => true };
  }
}

async function folderExists(p) {
  try { await folderStat(p); return true; } catch(e) { return false; }
}

async function folderMkdir(p) {
  await folderNavTo(p, true);
}

async function folderUnlink(p) {
  const parts = p.replace(/^\/+|\/+$/g,'').split('/').filter(Boolean);
  const name = parts.pop();
  let dir = folderStorageRoot;
  for (const part of parts) dir = await dir.getDirectoryHandle(part, { create: false });
  await dir.removeEntry(name);
}

async function folderRmdir(p) {
  const parts = p.replace(/^\/+|\/+$/g,'').split('/').filter(Boolean);
  const name = parts.pop();
  let dir = folderStorageRoot;
  for (const part of parts) dir = await dir.getDirectoryHandle(part, { create: false });
  await dir.removeEntry(name, { recursive: true });
}

// Activate folder storage — reassign all FS helpers to real-folder versions
function activateFolderStorage(dirHandle) {
  folderStorageRoot = dirHandle;
  folderStorageActive = true;

  // Reassign the module-level let helpers
  fsReadFile  = folderReadFile;
  fsWriteFile = folderWriteFile;
  fsReaddir   = folderReaddir;
  fsStat      = folderStat;
  fsExists    = folderExists;
  fsMkdir     = folderMkdir;
  fsUnlink    = folderUnlink;
  fsRmdir     = folderRmdir;
  fsRename    = async (o, n) => {
    try { const c = await folderReadFile(o); await folderWriteFile(n, c); await folderUnlink(o); }
    catch(e) { throw e; }
  };

  const _smEl2 = document.getElementById('storage-mode'); if (_smEl2) _smEl2.textContent = '📂 ' + dirHandle.name;
  document.getElementById('sb-branch').textContent = '📂 ' + dirHandle.name;
  document.querySelectorAll('.storage-option').forEach(o => o.classList.remove('active'));
  document.getElementById('storage-opt-folder').classList.add('active');

  // Also index in shared file map so asset resolution works
  if (!sharedRoots.find(r => r.name === dirHandle.name)) {
    sharedRoots.push({ name: dirHandle.name, handle: dirHandle, kind: 'dir' });
    sharedTreeExp.add(dirHandle.name);
    sharedIndexDir(dirHandle, dirHandle.name, dirHandle.name).then(() => sharedRender());
  }

  termLog('sys', 'Folder storage active: ' + dirHandle.name + ' — reads/writes go to disk.');
}

async function switchStorageToFolder(event) {
  event.stopPropagation();
  if (!sharedFSAP) { termLog('warn', 'File System Access API not supported in this browser.'); return; }
  showConfirm('Use a real folder as the IDE filesystem?', 'All file operations will read/write directly to that folder on disk.', async () => {
    try {
      document.getElementById('storage-selector').classList.remove('visible');
      const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      activateFolderStorage(dirHandle);
      // Reload file tree from real folder
      openTabs.forEach(t => t.model.dispose());
      openTabs = []; activeTab = null;
      monacoEditor.setModel(null);
      document.getElementById('empty-state').style.display = 'flex';
      renderTabs();
      await refreshTree();
    } catch(e) {
      if (e.name !== 'AbortError') termLog('error', 'Folder storage failed: ' + e.message);
    }
  });
}

// Close selector when clicking outside
document.addEventListener('click', () => {
  document.getElementById('storage-selector')?.classList.remove('visible');
});


let monacoEditor = null;
let openTabs = [];      // [{path, model, dirty}]
let activeTab = null;   // path string
let ctxTarget = null;   // path string for context menu

// Live reload state
let _liveReload      = false;
let _liveDebounce    = null;
let _liveDisposables = [];
let LIVE_DEBOUNCE_MS = 400;

const DEFAULT_FILES = {

};

// ═══════════════════════════════════════════════════════════════════
//  INIT — BrowserFS → Monaco → load tree
// ═══════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════
//  NATIVE INDEXEDDB FILESYSTEM
//  Replaces BrowserFS entirely. Stores each file as a record:
//    { path: '/foo/bar.js', content: '...', isDir: false }
//  Directories are also stored as records with isDir:true.
//  The FS helper let-variables are reassigned to point at these
//  implementations, exactly like activateFolderStorage() does.
// ═══════════════════════════════════════════════════════════════════

let _idb = null;   // the IDBDatabase instance

function _idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open('void-ide-v2', 1);
    req.onupgradeneeded = ev => {
      const db = ev.target.result;
      if (!db.objectStoreNames.contains('files')) {
        db.createObjectStore('files', { keyPath: 'path' });
      }
    };
    req.onsuccess = ev => res(ev.target.result);
    req.onerror   = ev => rej(ev.target.error);
  });
}

function _idbGet(path) {
  return new Promise((res, rej) => {
    const tx  = _idb.transaction('files', 'readonly');
    const req = tx.objectStore('files').get(path);
    req.onsuccess = ev => res(ev.target.result || null);
    req.onerror   = ev => rej(ev.target.error);
  });
}

function _idbPut(record) {
  return new Promise((res, rej) => {
    const tx  = _idb.transaction('files', 'readwrite');
    tx.objectStore('files').put(record);
    tx.oncomplete = () => res();
    tx.onerror    = ev => rej(ev.target.error);
    tx.onabort    = ev => rej(ev.target.error || new Error('IDB transaction aborted'));
  });
}

function _idbDelete(path) {
  return new Promise((res, rej) => {
    const tx  = _idb.transaction('files', 'readwrite');
    tx.objectStore('files').delete(path);
    tx.oncomplete = () => res();
    tx.onerror    = ev => rej(ev.target.error);
    tx.onabort    = ev => rej(ev.target.error || new Error('IDB transaction aborted'));
  });
}

function _idbGetAll() {
  return new Promise((res, rej) => {
    const tx  = _idb.transaction('files', 'readonly');
    const req = tx.objectStore('files').getAll();
    req.onsuccess = ev => res(ev.target.result);
    req.onerror   = ev => rej(ev.target.error);
  });
}

// Normalize path: always starts with /, never ends with / (except root)
function _normPath(p) {
  p = p.split('\\\\').join('/');  // convert backslashes (Windows paths)
  p = p.replace(/\/\/+/g, '/'); // collapse double slashes
  if (!p.startsWith('/')) p = '/' + p;
  if (p !== '/' && p.endsWith('/')) p = p.slice(0, -1);
  return p;
}

function _idbParentPath(p) {
  if (p === '/') return null;
  const idx = p.lastIndexOf('/');
  return idx === 0 ? '/' : p.slice(0, idx);
}

// Activate native IDB — reassign all FS helpers
function activateIDB() {
  fsReadFile = async (p) => {
    p = _normPath(p);
    const rec = await _idbGet(p);
    if (!rec)      throw Object.assign(new Error('ENOENT: ' + p), { code: 'ENOENT' });
    if (rec.isDir) throw Object.assign(new Error('EISDIR: ' + p), { code: 'EISDIR' });
    return rec.content;
  };

  fsWriteFile = async (p, data) => {
    p = _normPath(p);
    try {
      await _idbPut({ path: p, content: data, isDir: false });
    } catch(e) {
      termLog('error', 'IDB write failed for ' + p + ': ' + e.message);
      throw e;
    }
  };

  fsReaddir = async (p) => {
    p = _normPath(p);
    const all = await _idbGetAll();
    const children = new Set();
    for (const rec of all) {
      if (rec.path === p) continue;
      const parent = _idbParentPath(rec.path);
      if (parent === p) {
        children.add(rec.path.split('/').pop());
      }
    }
    return [...children].sort();
  };

  fsStat = async (p) => {
    p = _normPath(p);
    if (p === '/') return { isDirectory: () => true, isFile: () => false, size: 0 };
    const rec = await _idbGet(p);
    if (!rec) throw Object.assign(new Error('ENOENT: ' + p), { code: 'ENOENT' });
    return {
      isDirectory: () => !!rec.isDir,
      isFile:      () => !rec.isDir,
      size:        rec.isDir ? 0 : (rec.content || '').length,
    };
  };

  fsExists = async (p) => {
    p = _normPath(p);
    if (p === '/') return true;
    const rec = await _idbGet(p);
    return rec !== null;
  };

  fsMkdir = async (p) => {
    p = _normPath(p);
    if (p === '/') return;
    const existing = await _idbGet(p);
    if (existing) throw Object.assign(new Error('EEXIST: ' + p), { code: 'EEXIST' });
    await _idbPut({ path: p, content: null, isDir: true });
  };

  fsUnlink = async (p) => {
    p = _normPath(p);
    await _idbDelete(p);
  };

  fsRmdir = async (p) => {
    p = _normPath(p);
    await _idbDelete(p);
  };

  fsRename = async (oldPath, newPath) => {
    oldPath = _normPath(oldPath);
    newPath = _normPath(newPath);
    const rec = await _idbGet(oldPath);
    if (!rec) throw Object.assign(new Error('ENOENT: ' + oldPath), { code: 'ENOENT' });
    await _idbPut({ ...rec, path: newPath });
    await _idbDelete(oldPath);
  };

  // FS is no longer a BrowserFS object — set to a sentinel so callers know
  FS = { __nativeIDB: true };
}

function _rewireFS() {
  FS = BrowserFS.BFSRequire('fs');
  fsReaddir  = p => new Promise((res,rej)=>FS.readdir(p,(e,d)=>e?rej(e):res(d)));
  fsReadFile = p => new Promise((res,rej)=>FS.readFile(p,'utf8',(e,d)=>e?rej(e):res(d)));
  fsStat     = p => new Promise((res,rej)=>FS.stat(p,(e,s)=>e?rej(e):res(s)));
  fsMkdir    = p => new Promise((res,rej)=>FS.mkdir(p,(e)=>e?rej(e):res()));
  fsUnlink   = p => new Promise((res,rej)=>FS.unlink(p,(e)=>e?rej(e):res()));
  fsRmdir    = p => new Promise((res,rej)=>FS.rmdir(p,(e)=>e?rej(e):res()));
  fsRename   = (o,n) => new Promise((res,rej)=>FS.rename(o,n,(e)=>e?rej(e):res()));
  fsExists   = p => new Promise(res=>FS.exists(p,res));
  fsWriteFile= (p,d) => new Promise((res,rej)=>FS.writeFile(p,d,'utf8',(e)=>e?rej(e):res()));
}

async function initBrowserFS() {
  // ── IndexedDB (native, no BrowserFS) ─────────────────────────────
  if (currentStorageMode === 'indexed') {
    try {
      _idb = await _idbOpen();
      activateIDB();
      await fsWriteFile('/.void_probe', 'ok');
      const probe = await fsReadFile('/.void_probe');
      await fsUnlink('/.void_probe');
      if (probe !== 'ok') throw new Error('read-back mismatch');
      termLog('sys', 'Storage: native IndexedDB ✓');
      return 'IndexedDB';
    } catch(e) {
      termLog('warn', 'IndexedDB failed (' + e.message + '), falling back to LocalStorage…');
      _idb = null;
      currentStorageMode = 'local';
    }
  }

  // ── LocalStorage ─────────────────────────────────────────────────
  if (currentStorageMode === 'local') {
    try {
      await new Promise((res, rej) =>
        BrowserFS.configure({ fs: 'LocalStorage' }, e => e ? rej(e) : res())
      );
      _rewireFS();
      await new Promise((res, rej) => FS.stat('/', (e, s) => e ? rej(e) : res(s)));
      termLog('sys', 'Storage: LocalStorage ✓ (limited to ~5 MB)');
      return 'LocalStorage';
    } catch(e) {
      termLog('warn', 'LocalStorage failed (' + e.message + '), falling back to Memory…');
      currentStorageMode = 'memory';
    }
  }

  // ── InMemory ─────────────────────────────────────────────────────
  await new Promise((res, rej) =>
    BrowserFS.configure({ fs: 'InMemory' }, e => e ? rej(e) : res())
  );
  _rewireFS();
  termLog('warn', 'Storage: in-memory only — files lost on refresh');
  return 'InMemory';
}

async function boot() {
  initStorageMode();
  loadSettings(); // Load saved settings early
  termLog('sys', 'Booting VOID IDE…');
  await initBrowserFS();

  // Check if FS already has files
  let items = [];
  try { items = await fsReaddir('/'); } catch(e) {
    // Root unreadable on fresh IndexedDB — that's fine, seed will create files
    items = [];
  }

  // Filter out hidden/system entries
  const userFiles = items.filter(i => !i.startsWith('.'));

  if (!userFiles.length) {
    termLog('sys', 'Seeding default project files…');
    for (const [filePath, content] of Object.entries(DEFAULT_FILES)) {
      await fsWriteFileSafe(filePath, content);
    }
    termLog('sys', 'Default files created.');
  } else {
    termLog('sys', `Found ${userFiles.length} existing file(s).`);
  }

  await initMonaco();
  applyAllSettings(); // Apply after Monaco is ready
  advLoadSaved();     // Apply persisted advanced Monaco config
  await refreshTree();
  // Auto-open index.html if it exists, else first file
  if (await fsExists('/index.html')) {
    await openFile('/index.html');
  } else if (userFiles.length) {
    await openFile('/' + userFiles[0]);
  }
  termLog('sys', 'VOID ready. Happy coding! 🚀');
  document.getElementById('sb-branch').textContent = '✓ FS mounted';
}

// ═══════════════════════════════════════════════════════════════════
//  FS HELPERS (promisified)
// ═══════════════════════════════════════════════════════════════════
let fsReaddir  = p => new Promise((res,rej)=>FS.readdir(p,(e,d)=>e?rej(e):res(d)));
let fsReadFile = p => new Promise((res,rej)=>FS.readFile(p,'utf8',(e,d)=>e?rej(e):res(d)));
let fsStat     = p => new Promise((res,rej)=>FS.stat(p,(e,s)=>e?rej(e):res(s)));
let fsMkdir    = p => new Promise((res,rej)=>FS.mkdir(p,(e)=>e?rej(e):res()));
let fsUnlink   = p => new Promise((res,rej)=>FS.unlink(p,(e)=>e?rej(e):res()));
let fsRmdir    = p => new Promise((res,rej)=>FS.rmdir(p,(e)=>e?rej(e):res()));
let fsRename   = (o,n) => new Promise((res,rej)=>FS.rename(o,n,(e)=>e?rej(e):res()));
let fsExists   = p => new Promise(res=>FS.exists(p,res));

// Raw write — caller must ensure parent dir exists
let fsWriteFile = (p,d) => new Promise((res,rej)=>FS.writeFile(p,d,'utf8',(e)=>e?rej(e):res()));

// mkdir -p: recursively create all ancestor directories
async function fsMkdirP(dirPath) {
  if (!dirPath || dirPath === '/') return;
  const parts = dirPath.replace(/^\/+/,'').split('/').filter(Boolean);
  let cur = '';
  for (const part of parts) {
    cur += '/' + part;
    if (!(await fsExists(cur))) {
      try { await fsMkdir(cur); }
      catch(e) {
        if (!String(e.message).includes('EEXIST') && String(e.code) !== 'EEXIST') throw e;
      }
    }
  }
}

// Safe write: creates all parent dirs first, then writes
async function fsWriteFileSafe(filePath, data) {
  const parts = filePath.split('/');
  parts.pop();
  const dir = parts.join('/') || '/';
  if (dir && dir !== '/') await fsMkdirP(dir);
  await fsWriteFile(filePath, data);
}

// Recursive delete: remove a folder and all its contents
async function fsRmdirR(dirPath) {
  const items = await fsReaddir(dirPath).catch(()=>[]);
  for (const item of items) {
    const p = joinPath(dirPath, item);
    const s = await fsStat(p).catch(()=>null);
    if (!s) continue;
    if (s.isDirectory()) await fsRmdirR(p);
    else await fsUnlink(p).catch(()=>{});
  }
  await fsRmdir(dirPath).catch(()=>{});
}

//  MONACO INIT
// ═══════════════════════════════════════════════════════════════════
function initMonaco() {
  return new Promise(resolve => {
    require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });
    require(['vs/editor/editor.main'], () => {
      // Void dark theme
      monaco.editor.defineTheme('void-dark', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: 'comment',    foreground: '3d5266', fontStyle: 'italic' },
          { token: 'keyword',    foreground: '00d4ff', fontStyle: 'bold' },
          { token: 'string',     foreground: '3ddc84' },
          { token: 'number',     foreground: 'f0c040' },
          { token: 'type',       foreground: 'c792ea' },
          { token: 'function',   foreground: '82aaff' },
          { token: 'variable',   foreground: 'cdd9e5' },
          { token: 'operator',   foreground: '89ca78' },
          { token: 'tag',        foreground: 'ff4c6a' },
          { token: 'attribute.name',  foreground: '82aaff' },
          { token: 'attribute.value', foreground: '3ddc84' },
        ],
        colors: {
          'editor.background':           '#080b0f',
          'editor.foreground':           '#cdd9e5',
          'editorLineNumber.foreground': '#3d5266',
          'editorLineNumber.activeForeground': '#768a9e',
          'editor.lineHighlightBackground': '#0d1117',
          'editorCursor.foreground':     '#00d4ff',
          'editor.selectionBackground':  '#1e3a4a',
          'editorIndentGuide.background':'#161f2b',
          'editorIndentGuide.activeBackground': '#1e2d3d',
          'scrollbarSlider.background':  '#1c2736',
          'scrollbarSlider.hoverBackground':'#253545',
          'editorBracketMatch.background':'#00d4ff22',
          'editorBracketMatch.border':   '#00d4ff',
        }
      });

      monacoEditor = monaco.editor.create(document.getElementById('monaco-container'), {
        theme: 'void-dark',
        fontSize:           ideSettings.fontSize        || 13,
        tabSize:            ideSettings.tabSize         || 4,
        fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
        fontLigatures: true,
        lineNumbers:        ideSettings.lineNumbers     !== false ? 'on' : 'off',
        minimap: { enabled: ideSettings.minimap        !== false, scale: 1 },
        scrollBeyondLastLine: false,
        wordWrap:           ideSettings.wordWrap        ? 'on' : 'off',
        automaticLayout: true,
        renderWhitespace: 'selection',
        smoothScrolling:    ideSettings.smoothScrolling !== false,
        cursorBlinking:     ideSettings.cursorBlinking  || 'phase',
        cursorStyle:        ideSettings.cursorStyle     || 'line',
        cursorSmoothCaretAnimation: 'on',
        bracketPairColorization: { enabled: ideSettings.bracketColorization !== false },
        guides: { indentation: ideSettings.indentGuides !== false },
        renderLineHighlight: ideSettings.lineHighlight  || 'line',
        letterSpacing:      ideSettings.letterSpacing   || 0,
        lineHeight:         ideSettings.lineHeight      || 0,
        padding: { top: 8, bottom: 8 },
        model: null,
      });

      // Update status bar on cursor move
      monacoEditor.onDidChangeCursorPosition(e => {
        const p = e.position;
        document.getElementById('sb-pos').textContent = `Ln ${p.lineNumber}, Col ${p.column}`;
      });

      // Mark tab dirty on edit + handle autoSave
      let _autoSaveTimer = null;
      monacoEditor.onDidChangeModelContent(() => {
        if (activeTab) {
          const tab = openTabs.find(t=>t.path===activeTab);
          if (tab && !tab.dirty) { tab.dirty = true; renderTabs(); }
          // Auto-save with debounce
          if (ideSettings.autoSave) {
            clearTimeout(_autoSaveTimer);
            _autoSaveTimer = setTimeout(() => saveCurrentFile(), 1000);
          }
        }
      });

      document.getElementById('empty-state').style.display = 'none';
      resolve();
    });
  });
}

// ═══════════════════════════════════════════════════════════════════
//  FILE TREE
// ═══════════════════════════════════════════════════════════════════
let treeExpanded = new Set(['/']);

async function refreshTree() {
  const el = document.getElementById('filetree');
  el.innerHTML = '';
  await buildTree('/', el, 0);
}

async function buildTree(dir, container, depth) {
  let items;
  try { items = await fsReaddir(dir); }
  catch { return; }

  items.sort((a,b) => a.localeCompare(b));

  // Dirs first
  const stats = await Promise.all(items.map(i => fsStat(joinPath(dir,i)).catch(()=>null)));
  const sorted = items.map((n,i)=>({n,s:stats[i]}))
    .sort((a,b) => {
      const ad = a.s && a.s.isDirectory(); const bd = b.s && b.s.isDirectory();
      if (ad && !bd) return -1; if (!ad && bd) return 1;
      return a.n.localeCompare(b.n);
    });

  for (const {n, s} of sorted) {
    if (!s) continue;
    const path = joinPath(dir, n);
    const isDir = s.isDirectory();
    const el = document.createElement('div');
    el.className = 'tree-item' + (path===activeTab?' selected':'');
    el.dataset.path = path;

    const indent = document.createElement('span');
    indent.className = 'tree-indent';
    indent.style.width = (depth * 14 + 6) + 'px';

    const icon = document.createElement('span');
    icon.className = 'tree-icon';
    icon.innerHTML = isDir ? (treeExpanded.has(path) ? '📂' : '📁') : getFileIcon(n);

    const name = document.createElement('span');
    name.className = 'tree-name';
    name.textContent = n;

    el.appendChild(indent);
    el.appendChild(icon);
    el.appendChild(name);

    el.addEventListener('click', async e => {
      e.stopPropagation();
      if (isDir) {
        treeExpanded.has(path) ? treeExpanded.delete(path) : treeExpanded.add(path);
        await refreshTree();
      } else {
        await openFile(path);
      }
    });

    el.addEventListener('contextmenu', e => {
      e.preventDefault();
      showCtxMenu(e.clientX, e.clientY, path, isDir);
    });

    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      if (!isDir) startRename(el, path);
    });

    container.appendChild(el);

    if (isDir && treeExpanded.has(path)) {
      await buildTree(path, container, depth+1);
    }
  }
}

function getFileIcon(name) {
  const ext = name.split('.').pop().toLowerCase();
  const map = {
    html:'<span class="ic-html">⟨/⟩</span>', htm:'<span class="ic-html">⟨/⟩</span>',
    css: '<span class="ic-css">🎨</span>',  scss:'<span class="ic-css">🎨</span>', less:'<span class="ic-css">🎨</span>',
    js:  '<span class="ic-js">JS</span>',   mjs:'<span class="ic-js">JS</span>',   cjs:'<span class="ic-js">JS</span>',
    ts:  '<span class="ic-ts">TS</span>',   tsx:'<span class="ic-ts">TS</span>',
    json:'<span class="ic-json">{}</span>', jsonc:'<span class="ic-json">{}</span>',
    md:  '<span class="ic-md">📝</span>',   mdx:'<span class="ic-md">📝</span>',
    txt: '<span class="ic-txt">📄</span>',
    xml: '<span class="ic-xml">XML</span>', svg:'<span class="ic-img">🖼</span>',
    png: '<span class="ic-img">🖼</span>', jpg:'<span class="ic-img">🖼</span>',
    jpeg:'<span class="ic-img">🖼</span>',gif:'<span class="ic-img">🖼</span>',
    webp:'<span class="ic-img">🖼</span>',avif:'<span class="ic-img">🖼</span>',
    bmp: '<span class="ic-img">🖼</span>',ico:'<span class="ic-img">🖼</span>',
    mp3: '🎵', wav:'🎵', ogg:'🎵', flac:'🎵', aac:'🎵', m4a:'🎵',
    mp4: '🎬', webm:'🎬', avi:'🎬', mov:'🎬', mkv:'🎬',
    pdf: '📕', csv:'📊', xls:'📊', xlsx:'📊',
    glb: '🧊', gltf:'🧊', obj:'🧊', fbx:'🧊', stl:'🧊',
    woff:'🔤', woff2:'🔤', ttf:'🔤', otf:'🔤', eot:'🔤',
    zip: '📦', gz:'📦', tar:'📦', rar:'📦',
    wasm:'⚙️', bin:'🔢', dat:'🔢',
    py:  '🐍', rs:'🦀', go:'🐹', java:'☕', rb:'💎', php:'🐘', sh:'🖥️',
    glsl:'✨', vert:'✨', frag:'✨', wgsl:'✨',
  };
  return map[ext] || '📄';
}

// ── File-type categorisation ──────────────────────────────────────
const PREVIEW_IMAGE = new Set(['png','jpg','jpeg','gif','webp','avif','bmp','ico','tiff','tif']);
const PREVIEW_SVG   = new Set(['svg']);
const PREVIEW_AUDIO = new Set(['mp3','wav','ogg','flac','aac','m4a','opus','weba']);
const PREVIEW_VIDEO = new Set(['mp4','webm','avi','mov','mkv','ogv']);
const PREVIEW_PDF   = new Set(['pdf']);
const PREVIEW_FONT  = new Set(['woff','woff2','ttf','otf','eot']);
const PREVIEW_JSON  = new Set(['json','jsonc','geojson','topojson']);
const PREVIEW_CSV   = new Set(['csv','tsv']);
const PREVIEW_MD    = new Set(['md','mdx','markdown']);
const PREVIEW_BINARY= new Set(['bin','dat','wasm','exe','dll','so','class','pyc','zip','gz','tar','rar','7z','glb','fbx','stl']);
// Text/code extensions that Monaco handles fine
const PREVIEW_TEXT  = new Set([
  'html','htm','css','scss','less','js','mjs','cjs','jsx','ts','tsx',
  'json','jsonc','xml','svg','txt','sh','bash','py','rs','go','java','rb','php',
  'c','cpp','h','hpp','cs','swift','kt','lua','r','sql','yaml','yml','toml','ini',
  'env','gitignore','log','glsl','vert','frag','wgsl','obj','mtl','gltf','csv','tsv',
  'md','mdx','markdown','csv',
]);

function _fileCategory(path) {
  const ext = path.split('.').pop().split('?')[0].toLowerCase();
  if (PREVIEW_IMAGE.has(ext))  return 'image';
  if (PREVIEW_SVG.has(ext))    return 'svg';
  if (PREVIEW_AUDIO.has(ext))  return 'audio';
  if (PREVIEW_VIDEO.has(ext))  return 'video';
  if (PREVIEW_PDF.has(ext))    return 'pdf';
  if (PREVIEW_FONT.has(ext))   return 'font';
  if (PREVIEW_JSON.has(ext))   return 'json';
  if (PREVIEW_CSV.has(ext))    return 'csv';
  if (PREVIEW_MD.has(ext))     return 'markdown';
  if (PREVIEW_BINARY.has(ext)) return 'binary';
  return 'text'; // default: open in Monaco
}

function joinPath(...parts) {
  return ('/' + parts.map(p=>p.replace(/^\/+|\/+$/g,'')).filter(Boolean).join('/')).replace(/\/+/g,'/') || '/';
}

// ═══════════════════════════════════════════════════════════════════
//  FILE PREVIEW ENGINE
// ═══════════════════════════════════════════════════════════════════

function _fpToolbar(path, extraBtns='') {
  const name = path.split('/').pop();
  return `<div class="fp-toolbar">
    <span class="fp-title">📄 ${escH(path)}</span>
    ${extraBtns}
    <button class="fp-btn" onclick="openFileInMonaco('${escH(path)}')" title="Open raw in Monaco editor">✏️ Edit</button>
    <button class="fp-btn" onclick="closeFP()">✕</button>
  </div>`;
}

function closeFP() {
  const fp = document.getElementById('file-preview');
  fp.innerHTML = '';
  fp.classList.remove('visible');
  document.getElementById('monaco-container').style.position = '';
  if (activeTab) monacoEditor.focus();
}

function showFP(html) {
  const fp = document.getElementById('file-preview');
  fp.innerHTML = html;
  fp.classList.add('visible');
  document.getElementById('monaco-container').style.position = 'relative';
}

// Force-open a file in Monaco regardless of type
async function openFileInMonaco(path) {
  closeFP();
  let content = '';
  try { content = await fsReadFile(path); } catch(e) { content = ''; }
  const lang = getLang(path);
  let existing = openTabs.find(t=>t.path===path);
  if (!existing) {
    const model = monaco.editor.createModel(content, lang, monaco.Uri.file(path));
    existing = { path, model, dirty: false };
    openTabs.push(existing);
  }
  activeTab = path;
  monacoEditor.setModel(existing.model);
  document.getElementById('empty-state').style.display = 'none';
  renderTabs();
  refreshTree();
  updateStatusBar(path);
  monacoEditor.focus();
}

async function showImagePreview(path) {
  let url;
  try {
    const bytes = await readRawBytes(path);
    const ext = path.split('.').pop().toLowerCase();
    url = URL.createObjectURL(new Blob([bytes], { type: getMime(ext) }));
  } catch(e) {
    try {
      const text = await fsReadFile(path);
      if (text.startsWith('data:')) url = text;
      else url = 'data:image/png;base64,' + btoa(text);
    } catch(e2) { url = ''; }
  }
  showFP(`${_fpToolbar(path)}
  <div class="fp-img-wrap">
    <img src="${url}" alt="" id="fp-img" onload="
      const i=this;
      document.getElementById('fp-img-info').textContent=
        i.naturalWidth+'×'+i.naturalHeight+'px  •  '+i.src.slice(0,6)+'…';
    ">
    <div class="fp-info" id="fp-img-info">loading…</div>
  </div>`);
}

async function showSvgPreview(path) {
  let svg = '', url = '';
  try { svg = await fsReadFile(path); } catch(e) {}
  try { url = URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml' })); } catch(e) {}
  showFP(`${_fpToolbar(path, `<button class="fp-btn ok" onclick="window.open('${url}','_blank')">⧉ Full</button>`)}
  <div class="fp-svg-wrap">
    <img class="fp-svg" src="${url}" alt="SVG preview">
    <div class="fp-info">${escH(path.split('/').pop())}</div>
  </div>`);
}

async function showAudioPreview(path) {
  const ext = path.split('.').pop().toLowerCase();
  let url = '';
  try {
    const bytes = await readRawBytes(path);
    url = URL.createObjectURL(new Blob([bytes], { type: getMime(ext) }));
  } catch(e) {}
  showFP(`${_fpToolbar(path)}
  <div class="fp-media" style="margin-top:40px">
    <div style="font-size:64px;text-align:center;margin-bottom:20px">🎵</div>
    <div style="font-size:13px;color:var(--text-dim);text-align:center;margin-bottom:14px">${escH(path.split('/').pop())}</div>
    <audio controls src="${url}" style="width:100%"></audio>
  </div>`);
}

async function showVideoPreview(path) {
  const ext = path.split('.').pop().toLowerCase();
  let url = '';
  try {
    const bytes = await readRawBytes(path);
    url = URL.createObjectURL(new Blob([bytes], { type: getMime(ext) }));
  } catch(e) {}
  showFP(`${_fpToolbar(path)}
  <div class="fp-media">
    <video controls src="${url}" style="max-height:65vh;width:100%"></video>
  </div>`);
}

async function showPdfPreview(path) {
  let url = '';
  try {
    const bytes = await readRawBytes(path);
    url = URL.createObjectURL(new Blob([bytes], { type: 'application/pdf' }));
  } catch(e) {}
  showFP(`${_fpToolbar(path, `<button class="fp-btn ok" onclick="window.open('${url}','_blank')">⧉ Open</button>`)}
  <iframe class="fp-pdf" src="${url}#toolbar=1&navpanes=1"></iframe>`);
}

async function showFontPreview(path) {
  const ext = path.split('.').pop().toLowerCase();
  const name = path.split('/').pop();
  const fontFace = 'fp-preview-font-' + Date.now();
  let url = '';
  try {
    const bytes = await readRawBytes(path);
    url = URL.createObjectURL(new Blob([bytes], { type: getMime(ext) }));
    const style = document.createElement('style');
    style.id = 'fp-font-style';
    style.textContent = `@font-face { font-family: '${fontFace}'; src: url('${url}'); }`;
    document.head.appendChild(style);
  } catch(e) {}
  const sizes = [48, 32, 24, 18, 14, 11];
  const sample = 'The quick brown fox jumps over the lazy dog. 0123456789 !@#$%';
  showFP(`${_fpToolbar(path)}
  <div class="fp-font-wrap">
    <div style="font-size:11px;color:var(--text-faint);margin-bottom:10px">Font: ${escH(name)}</div>
    <div class="fp-font-sizes">
      ${sizes.map(s=>`<span style="font-family:'${fontFace}',sans-serif;font-size:${s}px">${sample.slice(0,s>24?sample.length:30)}</span>`).join('')}
    </div>
    <div style="margin-top:14px">
      <div class="fp-font-preview" style="font-family:'${fontFace}',serif" contenteditable="true" spellcheck="false"
        title="Click to edit preview text">${sample}</div>
      <div class="fp-info">Click above to edit preview text</div>
    </div>
  </div>`);
}

async function showJsonPreview(path) {
  let text = '';
  try { text = await fsReadFile(path); } catch(e) {}
  let obj = null, parseErr = '';
  try { obj = JSON.parse(text); } catch(e) { parseErr = e.message; }

  function renderJson(val, depth) {
    if (depth > 8) return `<span class="jv-str">"…"</span>`;
    if (val === null) return `<span class="jv-null">null</span>`;
    if (typeof val === 'boolean') return `<span class="jv-bool">${val}</span>`;
    if (typeof val === 'number') return `<span class="jv-num">${val}</span>`;
    if (typeof val === 'string') return `<span class="jv-str">"${escH(val.slice(0,200))}${val.length>200?'…':''}"</span>`;
    if (Array.isArray(val)) {
      if (!val.length) return `<span style="color:var(--text-faint)">[]</span>`;
      const id = 'jp'+(Math.random()*1e9|0);
      return `<span class="fp-json-toggle" onclick="document.getElementById('${id}').style.display=document.getElementById('${id}').style.display==='none'?'':'none'">▾ [${val.length}]</span>`
        +`<div class="fp-json-children" id="${id}">${val.slice(0,500).map((v,i)=>`<div><span class="jv-num">${i}</span>: ${renderJson(v,depth+1)}</div>`).join('')}${val.length>500?`<div style="color:var(--text-faint)">…+${val.length-500} more</div>`:''}</div>`;
    }
    if (typeof val === 'object') {
      const keys = Object.keys(val);
      if (!keys.length) return `<span style="color:var(--text-faint)">{}</span>`;
      const id = 'jp'+(Math.random()*1e9|0);
      return `<span class="fp-json-toggle" onclick="document.getElementById('${id}').style.display=document.getElementById('${id}').style.display==='none'?'':'none'">▾ {${keys.length}}</span>`
        +`<div class="fp-json-children" id="${id}">${keys.slice(0,300).map(k=>`<div><span class="jk">"${escH(k)}"</span>: ${renderJson(val[k],depth+1)}</div>`).join('')}${keys.length>300?`<div style="color:var(--text-faint)">…+${keys.length-300} more keys</div>`:''}</div>`;
    }
    return escH(String(val));
  }

  const content = parseErr
    ? `<div style="color:var(--red);margin-bottom:12px">Parse error: ${escH(parseErr)}</div><pre style="color:var(--text-dim);font-size:11px;white-space:pre-wrap">${escH(text.slice(0,4000))}</pre>`
    : `<div class="fp-json">${renderJson(obj,0)}</div>`;

  showFP(`${_fpToolbar(path, `<span style="font-size:10px;color:var(--text-faint)">${(text.length/1024).toFixed(1)} KB</span>`)}${content}`);
}

async function showCsvPreview(path) {
  let text = '';
  try { text = await fsReadFile(path); } catch(e) {}
  const sep = path.endsWith('.tsv') ? '\t' : ',';
  const rows = text.split(/\r?\n/).filter(Boolean).map(r => {
    // Simple CSV parse (handles quoted fields)
    const cells = [];
    let cur = '', inQ = false;
    for (let i = 0; i < r.length; i++) {
      if (r[i] === '"') { inQ = !inQ; continue; }
      if (r[i] === sep && !inQ) { cells.push(cur); cur = ''; }
      else cur += r[i];
    }
    cells.push(cur);
    return cells;
  });
  const maxRows = 500, headers = rows[0] || [];
  const body = rows.slice(1, maxRows + 1);
  showFP(`${_fpToolbar(path, `<span style="font-size:10px;color:var(--text-faint)">${rows.length} rows × ${headers.length} cols</span>`)}
  <div class="fp-csv">
    <table>
      <thead><tr>${headers.map(h=>`<th>${escH(h)}</th>`).join('')}</tr></thead>
      <tbody>${body.map(row=>`<tr>${headers.map((_,i)=>`<td>${escH(row[i]||'')}</td>`).join('')}</tr>`).join('')}</tbody>
    </table>
    ${rows.length > maxRows ? `<div style="font-size:10px;color:var(--text-faint);padding:8px">Showing first ${maxRows} of ${rows.length-1} rows</div>` : ''}
  </div>`);
}

async function showMarkdownPreview(path) {
  let text = '';
  try { text = await fsReadFile(path); } catch(e) {}
  // Simple but solid MD renderer
  function mdToHtml(md) {
    let html = escH(md);
    // Code blocks
    html = html.replace(/```[\w]*\n?([\s\S]*?)```/g, (_,c) => `<pre><code>${c}</code></pre>`);
    // Inline code
    html = html.replace(/`([^`]+)`/g, (_,c) => `<code>${c}</code>`);
    // Headers
    html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
    html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
    html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
    html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
    html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
    // Bold / italic
    html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
    html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
    // Strikethrough
    html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
    // Links & images
    html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img alt="$1" src="$2">');
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
    // Horizontal rule
    html = html.replace(/^---+$/gm, '<hr>');
    // Blockquote
    html = html.replace(/^&gt;\s+(.+)$/gm, '<blockquote>$1</blockquote>');
    // Unordered list
    html = html.replace(/((?:^[-*+]\s+.+\n?)+)/gm, m => '<ul>' + m.replace(/^[-*+]\s+(.+)$/gm,'<li>$1</li>') + '</ul>');
    // Ordered list
    html = html.replace(/((?:^\d+\.\s+.+\n?)+)/gm, m => '<ol>' + m.replace(/^\d+\.\s+(.+)$/gm,'<li>$1</li>') + '</ol>');
    // Table
    html = html.replace(/(\|.+\|\n\|[-| :]+\|\n(?:\|.+\|\n?)+)/g, tableMatch => {
      const lines = tableMatch.trim().split('\n');
      const headers = lines[0].split('|').filter((_,i,a)=>i>0&&i<a.length-1).map(h=>`<th>${h.trim()}</th>`).join('');
      const rows = lines.slice(2).map(l=>'<tr>'+l.split('|').filter((_,i,a)=>i>0&&i<a.length-1).map(c=>`<td>${c.trim()}</td>`).join('')+'</tr>').join('');
      return `<table><thead><tr>${headers}</tr></thead><tbody>${rows}</tbody></table>`;
    });
    // Paragraphs
    html = html.replace(/\n\n+/g, '</p><p>');
    html = '<p>' + html + '</p>';
    // Clean up empty paragraphs around block elements
    html = html.replace(/<p>(<(?:h[1-6]|ul|ol|pre|blockquote|table|hr)[^>]*>)/g, '$1');
    html = html.replace(/(<\/(?:h[1-6]|ul|ol|pre|blockquote|table)>)<\/p>/g, '$1');
    html = html.replace(/<p><\/p>/g, '');
    return html;
  }
  showFP(`${_fpToolbar(path, `<button class="fp-btn ok" onclick="document.getElementById('fp-md-toggle').classList.toggle('raw')">⇌ Raw</button>`)}
  <div class="fp-md" id="fp-md-toggle">${mdToHtml(text)}</div>
  <style>#fp-md-toggle.raw{font-family:'JetBrains Mono',monospace;font-size:11px;white-space:pre-wrap;color:var(--text-dim);max-width:100%}
  #fp-md-toggle.raw h1,#fp-md-toggle.raw h2,#fp-md-toggle.raw h3,#fp-md-toggle.raw p,#fp-md-toggle.raw blockquote,#fp-md-toggle.raw ul,#fp-md-toggle.raw ol{all:unset;display:block;white-space:pre-wrap;font-size:11px;color:var(--text-dim)}</style>`);
}

async function showBinaryPreview(path) {
  let bytes = null;
  try { bytes = await readRawBytes(path); } catch(e) {}
  if (!bytes) { showFP(`${_fpToolbar(path)}<div class="fp-unknown"><div class="fp-unk-icon">🔢</div><div class="fp-unk-title">Cannot read binary file</div></div>`); return; }
  const arr = new Uint8Array(bytes);
  const maxBytes = 1024;
  let html = '<div class="fp-hex">';
  for (let i = 0; i < Math.min(arr.length, maxBytes); i += 16) {
    const chunk = arr.slice(i, i + 16);
    const addr = i.toString(16).padStart(8, '0');
    const hexParts = Array.from(chunk).map(b => b === 0
      ? `<span class="fp-hex-zero">${b.toString(16).padStart(2,'0')}</span>`
      : b.toString(16).padStart(2, '0'));
    while (hexParts.length < 16) hexParts.push('<span style="opacity:0">00</span>');
    const ascii = Array.from(chunk).map(b => (b>=32&&b<127) ? escH(String.fromCharCode(b)) : '<span class="fp-hex-zero">.</span>').join('');
    html += `<div class="fp-hex-row"><span class="fp-hex-addr">${addr}</span><span class="fp-hex-bytes">${hexParts.join(' ')}</span><span class="fp-hex-ascii">${ascii}</span></div>`;
  }
  if (arr.length > maxBytes) html += `<div style="color:var(--text-faint);font-size:10px;padding:6px 0">…${arr.length - maxBytes} more bytes (${(arr.length/1024).toFixed(1)} KB total)</div>`;
  html += '</div>';
  showFP(`${_fpToolbar(path, `<span style="font-size:10px;color:var(--text-faint)">${(arr.length/1024).toFixed(1)} KB · binary</span>`)}${html}`);
}

async function showUnknownPreview(path) {
  const ext = path.split('.').pop().toLowerCase();
  // Try opening as text first
  let text = null;
  try { text = await fsReadFile(path); } catch(e) {}
  if (text !== null && text !== undefined) {
    // It read as text — just open in Monaco
    closeFP();
    return openFileInMonaco(path);
  }
  showFP(`${_fpToolbar(path)}
  <div class="fp-unknown">
    <div class="fp-unk-icon">📄</div>
    <div class="fp-unk-title">.${escH(ext)} file</div>
    <div class="fp-unk-sub">No preview available. Try editing as text.</div>
  </div>`);
}

// Master file opener — dispatches to preview or Monaco
async function openFile(path) {
  const cat = _fileCategory(path);

  // Always add to tabs for tracking even if showing preview
  let existing = openTabs.find(t => t.path === path);
  if (!existing) {
    // For preview types, create a placeholder model
    let content = '';
    if (cat === 'text') {
      try { content = await fsReadFile(path); } catch(e) { content = ''; }
    }
    const lang = cat === 'text' ? getLang(path) : 'plaintext';
    const model = monaco.editor.createModel(content, lang, monaco.Uri.file(path));
    existing = { path, model, dirty: false, previewOnly: cat !== 'text' };
    openTabs.push(existing);
    if (_liveReload && cat === 'text') {
      const d = model.onDidChangeContent(() => {
        if (!_liveReload) return;
        clearTimeout(_liveDebounce);
        _liveDebounce = setTimeout(_liveRun, LIVE_DEBOUNCE_MS);
      });
      _liveDisposables.push(d);
    }
  }

  activeTab = path;
  renderTabs();
  await refreshTree();
  updateStatusBar(path);
  document.getElementById('empty-state').style.display = 'none';

  // Show appropriate preview or Monaco
  if (cat === 'text') {
    closeFP();
    // Make sure the monaco container is visible (not hidden behind a preview)
    const mc = document.getElementById('monaco-container');
    if (mc) mc.style.display = '';
    // Set model and force layout so editor is ready immediately
    monacoEditor.setModel(existing.model);
    // Trigger layout in case the container size changed (e.g. was hidden)
    setTimeout(() => {
      monacoEditor.layout();
      monacoEditor.focus();
    }, 0);
  } else if (cat === 'image')    await showImagePreview(path);
  else if (cat === 'svg')        await showSvgPreview(path);
  else if (cat === 'audio')      await showAudioPreview(path);
  else if (cat === 'video')      await showVideoPreview(path);
  else if (cat === 'pdf')        await showPdfPreview(path);
  else if (cat === 'font')       await showFontPreview(path);
  else if (cat === 'json')       await showJsonPreview(path);
  else if (cat === 'csv')        await showCsvPreview(path);
  else if (cat === 'markdown')   await showMarkdownPreview(path);
  else if (cat === 'binary')     await showBinaryPreview(path);
  else                           await showUnknownPreview(path);

  // Auto-preview: if HTML and autoPreview is on, render it
  if (ideSettings.autoPreview && (cat === 'text') && /\.(html|htm)$/i.test(path)) {
    // Don't auto-run on every tab switch, only on first open
    if (!existing._autoPreviewDone) {
      existing._autoPreviewDone = true;
      // Run silently without switching panel away from editor
    }
  }
}

function closeTab(path) {
  const idx = openTabs.findIndex(t=>t.path===path);
  if (idx<0) return;
  const tab = openTabs[idx];
  function _doClose() {
    tab.model.dispose();
    openTabs.splice(idx,1);
    if (activeTab===path) {
      activeTab = openTabs[Math.min(idx, openTabs.length-1)]?.path || null;
      if (activeTab) {
        const nextTab = openTabs.find(t=>t.path===activeTab);
        monacoEditor.setModel(nextTab.model);
        setTimeout(() => { monacoEditor.layout(); monacoEditor.focus(); }, 0);
        updateStatusBar(activeTab);
      } else {
        monacoEditor.setModel(null);
        document.getElementById('empty-state').style.display = 'flex';
        const fileEl = document.getElementById('sb-file-name');
        if (fileEl) fileEl.textContent = 'No file open';
        document.getElementById('sb-lang').textContent = '—';
      }
    }
    renderTabs();
    refreshTree();
  }
  if (tab.dirty) {
    showConfirm('Save changes to ' + path.split('/').pop() + ' before closing?', '', _doClose);
  } else {
    _doClose();
  }
}

function renderTabs() {
  const bar = document.getElementById('tabs-bar');
  bar.innerHTML = '';
  for (const tab of openTabs) {
    const name = tab.path.split('/').pop();
    const el = document.createElement('div');
    el.className = 'tab' + (tab.path===activeTab?' active':'');
    el.innerHTML = `
      <span class="tab-icon">${getFileIconPlain(name)}</span>
      <span class="tab-name">${name}</span>
      ${tab.dirty ? '<span class="tab-dot"></span>' : ''}
      <span class="tab-close" data-path="${tab.path}">×</span>`;
    el.addEventListener('click', e => {
      if (e.target.classList.contains('tab-close')) { closeTab(e.target.dataset.path); return; }
      openFile(tab.path);
    });
    bar.appendChild(el);
  }
}

function getFileIconPlain(name) {
  const ext = name.split('.').pop().toLowerCase();
  return {html:'🌐',css:'🎨',js:'✨',ts:'🔷',json:'📋',md:'📝',txt:'📄'}[ext]||'📄';
}

function getLang(path) {
  const ext = path.split('.').pop().toLowerCase();
  return {
    html:'html', htm:'html', css:'css', js:'javascript', mjs:'javascript',
    ts:'typescript', tsx:'typescript', jsx:'javascript',
    json:'json', jsonc:'json', md:'markdown', markdown:'markdown',
    xml:'xml', svg:'xml', yaml:'yaml', yml:'yaml',
    txt:'plaintext', py:'python', rb:'ruby', php:'php',
    java:'java', c:'c', cpp:'cpp', h:'c', rs:'rust',
    go:'go', sh:'shell', bash:'shell', zsh:'shell', fish:'shell',
    toml:'ini', ini:'ini', conf:'ini', sql:'sql',
    wasm:'plaintext', wat:'wat', graphql:'graphql',
  }[ext] || 'plaintext';
}

function updateStatusBar(path) {
  const name = path ? path.split('/').pop() : 'No file open';
  const lang = path ? getLang(path) : '—';
  const fileEl = document.getElementById('sb-file-name');
  if (fileEl) fileEl.textContent = path || 'No file open';
  // Compat fallback for old code that sets sb-file directly
  const sbFile = document.getElementById('sb-file');
  if (sbFile && sbFile.tagName !== 'SPAN') sbFile.title = path || '';
  const langEl = document.getElementById('sb-lang');
  if (langEl) langEl.textContent = path ? lang.toUpperCase() : '—';
}

// ═══════════════════════════════════════════════════════════════════
//  SAVE
// ═══════════════════════════════════════════════════════════════════
async function saveCurrentFile() {
  if (!activeTab) return;
  const tab = openTabs.find(t=>t.path===activeTab);
  if (!tab) return;
  // Format on save
  if (ideSettings.formatOnSave && window.monacoEditor && monacoEditor.getModel() === tab.model) {
    const fmtAction = monacoEditor.getAction('editor.action.formatDocument');
    if (fmtAction) {
      try { await fmtAction.run(); } catch(e) {}
    }
  }
  const content = tab.model.getValue();
  try {
    await fsWriteFileSafe(activeTab, content);
    tab.dirty = false;
    renderTabs();
    termLog('sys', `Saved: ${activeTab}`);
  } catch(e) {
    termLog('error', 'Save failed: '+e.message);
  }
}

async function saveAll() {
  for (const tab of openTabs) {
    if (!tab.dirty) continue;
    await fsWriteFileSafe(tab.path, tab.model.getValue());
    tab.dirty = false;
  }
  renderTabs();
  termLog('sys', 'All files saved.');
}

// ═══════════════════════════════════════════════════════════════════
//  RUN
// ═══════════════════════════════════════════════════════════════════
async function runCurrentFile() {
  await saveCurrentFile();
  if (!activeTab) return;
  const ext = activeTab.split('.').pop().toLowerCase();
  if (ext === 'html' || ext === 'htm') {
    await runProject(activeTab);  // routes to about:blank or srcdoc based on knownProjectDir
  } else if (ext === 'js' || ext === 'mjs') {
    await runJS(activeTab);
  } else if (ext === 'wasm') {
    await runWasm(activeTab);
  } else if (ext === 'css') {
    termLog('info', 'CSS cannot be run standalone. Open an HTML file that links it.');
  } else if (ext === 'sh' || ext === 'bash' || ext === 'zsh' || ext === 'fish') {
    switchPanelTab('shell');
    const content = openTabs.find(t=>t.path===activeTab)?.model.getValue() || await fsReadFile(activeTab).catch(()=>'');
    shellRunScript(content, activeTab.split('/').pop());
  } else {
    termLog('warn', 'No runner for .' + ext + ' files.');
  }
}

async function runProjectIndex() {
  await saveAll();
  // Find the best HTML entry point: active tab, index.html in shared map, or VFS index.html
  let entry = null;
  if (activeTab && /\.(html|htm)$/i.test(activeTab)) {
    entry = activeTab;
  } else {
    for (const [vp] of sharedFileMap) {
      if (vp.endsWith('/index.html') || vp === 'index.html') { entry = '/' + vp; break; }
    }
    if (!entry && await fsExists('/index.html').catch(()=>false)) entry = '/index.html';
  }
  if (!entry) { termLog('warn', 'No HTML file found. Create an index.html first.'); return; }
  await runProject(entry);
}


// ═══════════════════════════════════════════════════════════════════
//  LIVE EDITOR LOOKUP
// ═══════════════════════════════════════════════════════════════════

function getLiveContent(vPath) {
  if (!openTabs || !openTabs.length) return null;
  const norm = vPath.replace(/^\/+/, '');
  const name = norm.split('/').pop();
  for (const tab of openTabs) {
    const tp = tab.path.replace(/^\/+/, '');
    if (tp === norm || tab.path === vPath) return tab.model.getValue();
  }
  for (const tab of openTabs) {
    const tp = tab.path.replace(/^\/+/, '');
    if (tp.endsWith('/' + norm) || norm.endsWith('/' + tp)) return tab.model.getValue();
  }
  for (const tab of openTabs) {
    if (tab.path.split('/').pop() === name) return tab.model.getValue();
  }
  return null;
}

// ═══════════════════════════════════════════════════════════════════
//  LIVE RELOAD
// ═══════════════════════════════════════════════════════════════════

function toggleLiveReload() {
  _liveReload = !_liveReload;
  const btn = document.getElementById('ptab-btn-live');
  if (btn) btn.classList.toggle('live-on', _liveReload);
  if (_liveReload) {
    termLog('sys', '⚡ Live reload ON');
    _attachLiveListeners();
    switchPanelTab('preview');
    _liveRun();
  } else {
    termLog('sys', 'Live reload OFF');
    _detachLiveListeners();
    clearTimeout(_liveDebounce); _liveDebounce = null;
  }
}

function _attachLiveListeners() {
  _detachLiveListeners();
  for (const tab of openTabs) {
    const d = tab.model.onDidChangeContent(() => {
      if (!_liveReload) return;
      clearTimeout(_liveDebounce);
      _liveDebounce = setTimeout(_liveRun, LIVE_DEBOUNCE_MS);
    });
    _liveDisposables.push(d);
  }
}

function _detachLiveListeners() {
  for (const d of _liveDisposables) { try { d.dispose(); } catch(e) {} }
  _liveDisposables = [];
}

async function _liveRun() {
  _blobCache = {};
  let htmlPath = null;
  if (activeTab && /\.(html|htm)$/i.test(activeTab)) {
    htmlPath = activeTab;
  } else {
    for (const [vp] of sharedFileMap) {
      if (vp.endsWith('/index.html') || vp === 'index.html') { htmlPath = '/' + vp; break; }
    }
    if (!htmlPath && await fsExists('/index.html').catch(() => false)) htmlPath = '/index.html';
    if (!htmlPath) { const h = openTabs.find(t => /\.(html|htm)$/i.test(t.path)); if (h) htmlPath = h.path; }
  }
  if (!htmlPath) return;
  await runHTML(htmlPath);
}

// ═══════════════════════════════════════════════════════════════════
//  ASSET RESOLUTION ENGINE
//  All assets are read via sharedFileMap handles or VFS.
//  file:// URLs are NEVER emitted — everything becomes inline or blob:.
// ═══════════════════════════════════════════════════════════════════

// Resolve a src string to a sharedFileMap entry, trying multiple strategies
function resolveEntry(src, htmlVPath) {
  // Strip file:// prefix and leading slashes for lookup
  const stripped = src.replace(/^file:\/\/\//, '').replace(/^file:\/\//, '').replace(/^\/+/, '');
  // 1. Direct lookup
  let entry = sharedMapLookup(src) || sharedMapLookup(stripped);
  if (entry) return entry;
  // 2. Resolve relative path against HTML vPath
  if (htmlVPath && /^\.\.?\//.test(src)) {
    const resolved = resolveRelVPath(htmlVPath, src.replace(/^\.\//, ''));
    entry = sharedFileMap.get(resolved);
    if (entry) return entry;
  }
  // 3. VFS check (caller will try VFS separately)
  return null;
}

// Read any asset as text, from handle or VFS
async function readAssetText(src, baseDir) {
  const filePath = src.startsWith('/') ? src : joinPath(baseDir, src);
  const stripped = filePath.replace(/^\/+/, '');
  const entry = sharedMapLookup(src) || sharedMapLookup(stripped);
  if (entry) {
    try { const f = await entry.handle.getFile(); return await f.text(); } catch(e) {}
  }
  try { return await fsReadFile(filePath); } catch(e) { return null; }
}


// ═══════════════════════════════════════════════════════════════════
//  RECURSIVE ASSET BUNDLER
//  Reads every asset via sharedFileMap handles or VFS.
//  No file:// URLs are ever emitted — everything becomes inline or blob:.
//
//  Strategy:
//   - Binary assets (images, fonts, etc.) → data: URI, inlined in place
//   - CSS files → inlined as <style>, with their url() assets also inlined
//   - JS/MJS modules → bundled recursively: imports rewritten to blob: URLs
//   - All other text → inlined directly
// ═══════════════════════════════════════════════════════════════════

const BIN_EXTS  = new Set(['png','jpg','jpeg','gif','webp','avif','bmp','ico',
  'woff','woff2','ttf','otf','eot','mp3','mp4','wav','ogg','webm','flac','aac',
  'opus','avi','mov','pdf','zip','gz']);
const TEXT_EXTS = new Set(['js','mjs','cjs','ts','jsx','tsx','css','json','jsonld',
  'xml','svg','txt','md','yaml','yml','toml','sh','py','rb','php','java','c','cpp',
  'h','rs','go','swift','kt','dart','r','sql','graphql']);

// Read raw bytes from handle or VFS, return ArrayBuffer or null
async function readRawBytes(vPath) {
  const entry = sharedMapLookup(vPath);
  if (entry) {
    try { return await (await entry.handle.getFile()).arrayBuffer(); } catch(e) {}
  }
  // VFS
  try {
    const content = await fsReadFile(vPath.startsWith('/') ? vPath : '/' + vPath);
    if (typeof content === 'string' && content.startsWith('data:') && content.includes(';base64,')) {
      const b64 = content.split(';base64,')[1];
      const bin = atob(b64);
      const buf = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
      return buf.buffer;
    }
    // text stored as string — encode to bytes
    return new TextEncoder().encode(content).buffer;
  } catch(e) { return null; }
}

// Read text — live editor first, then disk handle, then VFS
async function readRawText(vPath) {
  const live = getLiveContent(vPath);
  if (live !== null) return live;
  const entry = sharedMapLookup(vPath);
  if (entry) {
    try { return await (await entry.handle.getFile()).text(); } catch(e) {}
  }
  try {
    return await fsReadFile(vPath.startsWith('/') ? vPath : '/' + vPath);
  } catch(e) { return null; }
}

// Convert ArrayBuffer to base64
function bufToB64(buf) {
  const bytes = new Uint8Array(buf);
  let b64 = ''; const chunk = 8192;
  for (let i = 0; i < bytes.length; i += chunk)
    b64 += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + chunk, bytes.length)));
  return btoa(b64);
}

// Resolve a src string (relative, absolute, file://) to a vPath key usable with sharedFileMap/VFS
// htmlVPath: the vPath of the HTML file (e.g. "browserbench.org/Speedometer3.1/index.html")
function resolveSrc(src, htmlVPath) {
  // Already absolute non-local → return as-is (caller will skip)
  if (/^https?:\/\/|^data:|^blob:/.test(src)) return src;
  // Strip file:// to get an absolute disk path, then match against sharedFileMap
  if (src.startsWith('file://')) {
    const stripped = src.replace(/^file:\/\/\//, '').replace(/^file:\/\//, '');
    return stripped; // sharedMapLookup will do tail matching
  }
  if (!htmlVPath) return src;
  // Relative path — resolve against HTML's directory
  const base = htmlVPath.split('/').slice(0, -1);
  const parts = src.replace(/^\.\//, '').split('/');
  const stack = [...base];
  for (const p of parts) {
    if (p === '..') stack.pop();
    else if (p !== '.') stack.push(p);
  }
  return stack.join('/');
}

// Read a binary asset and return a data: URI
async function assetToDataUri(src, htmlVPath) {
  const vPath = resolveSrc(src, htmlVPath);
  if (/^https?:|^data:|^blob:/.test(vPath)) return null; // external, skip
  const ext = vPath.split('.').pop().toLowerCase();
  const buf = await readRawBytes(vPath);
  if (!buf) return null;
  return 'data:' + getMime(ext) + ';base64,' + bufToB64(buf);
}

// Inline CSS url() references (fonts, images) recursively
async function inlineCssUrls(css, cssVPath) {
  const urlRe = /url\(\s*(['"]?)(?!https?:|data:|blob:|#)([^)'"#\s]+)\1\s*\)/gi;
  const hits = [];
  let m;
  while ((m = urlRe.exec(css)) !== null) {
    hits.push({ full: m[0], src: m[2].trim() });
  }
  for (const { full, src } of hits) {
    const dataUri = await assetToDataUri(src, cssVPath);
    if (dataUri) css = css.split(full).join('url("' + dataUri + '")');
  }
  return css;
}

// Module bundler cache: vPath → blob: URL (avoids re-processing)
let _blobCache = {};

// Recursively bundle a JS/MJS module: rewrite all imports to blob: URLs
// Returns the blob: URL for this module
async function bundleModule(src, baseVPath) {
  const vPath = resolveSrc(src, baseVPath);
  if (/^https?:|^blob:/.test(vPath)) return vPath; // external or already blob
  if (_blobCache[vPath]) return _blobCache[vPath];

  // Reserve spot to prevent infinite recursion
  _blobCache[vPath] = '__pending__';

  let text = await readRawText(vPath);
  if (text === null) {
    termLog('warn', '  ✗ module not found: ' + (vPath.split('/').pop() || vPath));
    delete _blobCache[vPath];
    return src;
  }

  // Collect all static import/export from '...' and dynamic import('...') specifiers
  // We collect them first, then process in reverse so offsets stay valid
  const importRe = /\b(import|export)\s[^'"]*?from\s*(['"])((?!https?:|blob:|data:)[^'"]+)\2|import\s*\(\s*(['"])((?!https?:|blob:|data:)[^'"]+)\4\s*\)/g;
  const replacements = [];
  let im;
  while ((im = importRe.exec(text)) !== null) {
    const depSrc = im[3] || im[5]; // static or dynamic
    const quote  = im[2] || im[4];
    if (!depSrc) continue;
    replacements.push({ offset: im.index, length: im[0].length, full: im[0], quote, depSrc });
  }

  // Process in reverse to preserve offsets
  for (let i = replacements.length - 1; i >= 0; i--) {
    const { offset, length, full, quote, depSrc } = replacements[i];
    const blobUrl = await bundleModule(depSrc, vPath);
    const newFull = full.replace(quote + depSrc + quote, quote + blobUrl + quote);
    text = text.slice(0, offset) + newFull + text.slice(offset + length);
  }

  // Rewrite binary asset references inside the module (CSS url(), string literals for images)
  // These become data URIs so they work in the blob: context
  const assetRe = /(['"])((?:\.\.?\/)[^'"]+\.(png|jpg|jpeg|gif|webp|bmp|ico|svg|woff2?|ttf|otf))\1/gi;
  const assetHits = [];
  let am;
  while ((am = assetRe.exec(text)) !== null) {
    assetHits.push({ offset: am.index, length: am[0].length, quote: am[1], assetSrc: am[2] });
  }
  for (let i = assetHits.length - 1; i >= 0; i--) {
    const { offset, length, quote, assetSrc } = assetHits[i];
    const dataUri = await assetToDataUri(assetSrc, vPath);
    if (dataUri) {
      text = text.slice(0, offset) + quote + dataUri + quote + text.slice(offset + length);
    }
  }

  const blob = new Blob([text], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob);
  _blobCache[vPath] = url;
  termLog('sys', '  ✓ bundled: ' + (vPath.split('/').pop() || vPath) + ' → blob:');
  return url;
}

// Inline all <link rel=stylesheet> and <script src> in HTML
// Also handles <img src>, <source src>, CSS url(), and import chains
async function fullyInlineHTML(html, htmlVPath) {
  _blobCache = {}; // reset per-run cache

  // ── 1. Inline <link rel="stylesheet" href="..."> ──────────────
  html = await replaceAsync(html,
    /<link([^>]*\brel\s*=\s*["']stylesheet["'][^>]*)>/gi,
    async (full, attrs) => {
      const hm = /\bhref\s*=\s*["']([^"']+)["']/.exec(attrs);
      if (!hm) return full;
      const src = hm[1];
      if (/^https?:|^data:|^blob:/.test(src)) return full;
      let css = await readRawText(resolveSrc(src, htmlVPath));
      if (css === null) return full;
      css = await inlineCssUrls(css, resolveSrc(src, htmlVPath));
      termLog('sys', '  ✓ css: ' + src.split('/').pop());
      return '<style>/* ' + src.split('/').pop() + ' */\n' + css + '\n</style>';
    }
  );

  // ── 2. Inline <script src="..."> ─────────────────────────────
  // Match full <script ...>...<[/]script> blocks so we can replace the whole thing
  html = await replaceAsync(html,
    new RegExp('<script([^>]*)>' + '<' + '/script>|<script([^>]*)>\\s*' + '<' + '/script>', 'gi'),
    async (full, attrs1, attrs2) => {
      const attrs = attrs1 || attrs2 || '';
      const sm = /\bsrc\s*=\s*["']([^"']+)["']/.exec(attrs);
      if (!sm) return full;
      const src = sm[1];
      if (/^https?:|^data:|^blob:/.test(src)) return full;
      const isModule = /\btype\s*=\s*["']module["']/i.test(attrs);
      if (isModule) {
        const blobUrl = await bundleModule(src, htmlVPath);
        return '<script type="module">import ' + JSON.stringify(blobUrl) + ';<' + '/script>';
      }
      const text = await readRawText(resolveSrc(src, htmlVPath));
      if (text === null) return full;
      termLog('sys', '  ✓ script: ' + src.split('/').pop());
      return '<script>\n' + text + '\n<' + '/script>';
    }
  );
  // Also handle <script src="..."> that is NOT self-closing (has content between tags)
  html = await replaceAsync(html,
    new RegExp('<script([^>]+src\\s*=\\s*["\'][^"\']+["\'][^>]*)>([\\s\\S]*?)' + '<' + '/script>', 'gi'),
    async (full, attrs, _inner) => {
      const sm = /\bsrc\s*=\s*["']([^"']+)["']/.exec(attrs);
      if (!sm) return full;
      const src = sm[1];
      if (/^https?:|^data:|^blob:/.test(src)) return full;
      const isModule = /\btype\s*=\s*["']module["']/i.test(attrs);
      if (isModule) {
        const blobUrl = await bundleModule(src, htmlVPath);
        return '<script type="module">import ' + JSON.stringify(blobUrl) + ';<' + '/script>';
      }
      const text = await readRawText(resolveSrc(src, htmlVPath));
      if (text === null) return full;
      termLog('sys', '  ✓ script: ' + src.split('/').pop());
      return '<script>\n' + text + '\n<' + '/script>';
    }
  );

  // ── 3. Inline <img src>, <source src>, <video poster> etc. ───
  html = await replaceAsync(html,
    /(<(?:img|source|video|audio|track|input)[^>]*)\s(src|poster|srcset)\s*=\s*["']([^"']+)["']/gi,
    async (full, tagStart, attr, src) => {
      if (/^https?:|^data:|^blob:/.test(src)) return full;
      const ext = src.split('.').pop().split('?')[0].toLowerCase();
      if (!BIN_EXTS.has(ext)) return full;
      const dataUri = await assetToDataUri(src, htmlVPath);
      if (!dataUri) return full;
      termLog('sys', '  ✓ img: ' + src.split('/').pop());
      return tagStart + ' ' + attr + '="' + dataUri + '"';
    }
  );

  // ── 4. Inline CSS url() in <style> blocks ────────────────────
  html = await replaceAsync(html,
    /(<style[^>]*>)([\s\S]*?)(<\/style>)/gi,
    async (full, open, css, close) => {
      const inlined = await inlineCssUrls(css, htmlVPath);
      return open + inlined + close;
    }
  );

  // ── 5. Inline inline style attributes with url() ─────────────
  html = await replaceAsync(html,
    /\bstyle\s*=\s*["']([^"']*url\([^)]+\)[^"']*)["']/gi,
    async (full, styleVal) => {
      const inlined = await inlineCssUrls(styleVal, htmlVPath);
      return 'style="' + inlined + '"';
    }
  );

  // ── 6. Handle any remaining file:// refs (absolute paths left in HTML) ──
  html = await replaceAsync(html,
    /(['"])file:\/\/([^'"]+)\1/g,
    async (full, q, path) => {
      const ext = path.split('.').pop().toLowerCase();
      if (BIN_EXTS.has(ext)) {
        const dataUri = await assetToDataUri('file://' + path, htmlVPath);
        if (dataUri) return q + dataUri + q;
      } else if (TEXT_EXTS.has(ext)) {
        // For remaining text file:// refs (e.g. in fetch() calls, handled by bridge)
        return full; // fetch bridge will serve from VFS/sharedMap
      }
      return full;
    }
  );

  return html;
}

// Helper: async version of String.replace
async function replaceAsync(str, re, asyncFn) {
  const matches = [];
  let m;
  const reCopy = new RegExp(re.source, re.flags);
  while ((m = reCopy.exec(str)) !== null) {
    matches.push({ index: m.index, length: m[0].length, args: m });
    if (!re.global) break;
  }
  // Process all matches in parallel
  const results = await Promise.all(matches.map(({ args }) => asyncFn(...args)));
  // Rebuild string in reverse
  let out = str;
  for (let i = matches.length - 1; i >= 0; i--) {
    const { index, length } = matches[i];
    out = out.slice(0, index) + results[i] + out.slice(index + length);
  }
  return out;
}

// ── Resolve a relative path against a vPath ───────────────────────
function resolveRelVPath(basePath, rel) {
  const base = basePath.split('/').slice(0, -1);
  const parts = rel.split('/');
  const stack = [...base];
  for (const p of parts) {
    if (p === '..') stack.pop();
    else if (p !== '.') stack.push(p);
  }
  return stack.join('/');
}

// Find the vPath of an HTML file in sharedFileMap
function findHtmlVPath(htmlPath) {
  const name = htmlPath.split('/').filter(Boolean).pop();
  for (const [vp] of sharedFileMap) {
    if (vp.endsWith('/' + name) || vp === name) return vp;
  }
  return htmlPath.replace(/^\/+/, '');
}

// ── Main runHTML ──────────────────────────────────────────────────
async function runHTML(htmlPath) {
  if (ideSettings && ideSettings.autoPreview) switchPanelTab('preview');
  else switchPanelTab('preview');
  termLog('sys', 'Running: ' + htmlPath);
  try {
    // Read the source HTML — from shared handle if available, else VFS
    const strippedPath = htmlPath.replace(/^\/+/, '');
    const srcEntry = sharedMapLookup(strippedPath);
    let html;
    if (srcEntry) {
      html = await (await srcEntry.handle.getFile()).text();
    } else {
      html = await fsReadFile(htmlPath);
    }

    // Determine the HTML file's vPath in sharedFileMap for accurate relative resolution
    const htmlVPath = sharedFileMap.size > 0 ? findHtmlVPath(htmlPath) : strippedPath;

    termLog('sys', 'Bundling assets for: ' + (htmlVPath || htmlPath));

    // Fully inline all local assets (recursive, no file:// URLs emitted)
    html = await fullyInlineHTML(html, htmlVPath);

    // Inject console bridge + postMessage fetch bridge
    const CT = '<' + '/script>';
    const consoleSrc = '(function(){'
      + 'var _={log:console.log,warn:console.warn,error:console.error,info:console.info};'
      + 'function p(l,a){try{parent.postMessage({__void:true,level:l,msg:a.map(function(x){'
      + 'try{return typeof x==="object"?JSON.stringify(x,null,2):String(x);}catch(ee){return String(x);}'
      + '}).join(" ")},"*");}catch(ee){}}'
      + 'console.log=function(){_.log.apply(console,arguments);p("log",[].slice.call(arguments));};'
      + 'console.warn=function(){_.warn.apply(console,arguments);p("warn",[].slice.call(arguments));};'
      + 'console.error=function(){_.error.apply(console,arguments);p("error",[].slice.call(arguments));};'
      + 'console.info=function(){_.info.apply(console,arguments);p("info",[].slice.call(arguments));};'
      + 'window.onerror=function(m,s,l){p("error",["Uncaught: "+m+" (line "+l+")"]);};'
      + 'window.addEventListener("unhandledrejection",function(e){p("error",["Promise: "+String(e.reason)]);});'
      + '})();';

    const bridges = '<script>' + consoleSrc + CT + '<script>' + buildFetchBridge() + CT;

    if (/<head[\s>]/i.test(html)) {
      html = html.replace(/(<head[^>]*>)/i, '$1' + bridges);
    } else if (/<body[\s>]/i.test(html)) {
      html = html.replace(/(<body[^>]*>)/i, '$1' + bridges);
    } else {
      html = bridges + html;
    }

    document.getElementById('preview-frame').srcdoc = html;
    termLog('info', 'Preview ready ✓');
  } catch(e) {
    termLog('error', 'Run failed: ' + e.message);
    console.error(e);
  }
}

// ── Popout preview (also uses fully inlined HTML) ─────────────────
async function popoutPreview() {
  const popup = window.open('about:blank', '_blank',
    'width=900,height=650,toolbar=0,menubar=0,location=0,status=0,scrollbars=1,resizable=1');
  if (!popup) { termLog('warn', 'Popup blocked — allow popups for this page.'); return; }

  const frame = document.getElementById('preview-frame');
  if (frame && frame.srcdoc) {
    const html = frame.srcdoc.replace(/parent\.postMessage/g, '(window.opener||window.parent).postMessage');
    popup.document.open();
    popup.document.write(html);
    popup.document.close();
    termLog('sys', 'Preview opened in popup window.');
  } else if (activeTab) {
    await saveCurrentFile();
    const ext = activeTab.split('.').pop().toLowerCase();
    if (ext === 'html') {
      try {
        const strippedPath = activeTab.replace(/^\/+/, '');
        const srcEntry = sharedMapLookup(strippedPath);
        let html = srcEntry
          ? await (await srcEntry.handle.getFile()).text()
          : await fsReadFile(activeTab);
        const htmlVPath = sharedFileMap.size > 0 ? findHtmlVPath(activeTab) : strippedPath;
        html = await fullyInlineHTML(html, htmlVPath);
        popup.document.open();
        popup.document.write(html);
        popup.document.close();
        termLog('sys', 'Popup preview ready ✓');
      } catch(e) { termLog('error', 'Popout failed: ' + e.message); }
    } else {
      termLog('info', 'Popup opened (no HTML active).');
    }
  } else {
    termLog('info', 'Popup opened (no file open).');
  }
}

// ── Scan for file:// refs (still useful to detect them for logging) ──
function scanForFileUrls(text) {
  const found = new Set();
  const re = /file:\/\/([^\s"'<>)]+)/g;
  let m;
  while ((m = re.exec(text)) !== null) found.add('file://' + m[1].replace(/[,;)'">\s]+$/, ''));
  return [...found];
}

// ── Project directory (disk path) for about:blank native loading ──
// When set, Run opens a real window with <base href="file:///..."> so
// relative imports like ./benchmark-runner.mjs resolve natively.
let knownProjectDir = null; // e.g. "/home/villa/Downloads/browserbench.org/Speedometer3.1"

// Normalize a disk path → file:// base URL ending with /
function diskPathToFileUrl(p) {
  p = p.replace(/\\/g, '/').replace(/\/+$/, '');
  if (/^[a-zA-Z]:/.test(p)) return 'file:///' + p + '/';   // Windows
  return 'file://' + p + '/';                               // Unix/Mac
}

// Try to auto-detect the project dir from file:// URLs already in the HTML
function guessProjectDir(html) {
  const urls = scanForFileUrls(html);
  if (!urls.length) return null;
  // Take the first file:// URL's directory
  const p = urls[0].replace(/^file:\/\/\//, '/').replace(/^file:\/\//, '/');
  return p.replace(/\/[^/]+$/, ''); // strip filename
}

// Show a dialog asking the user for their project directory path
function askProjectDir(prefill, onSet) {
  let subtitleEl = document.getElementById('dialog-subtitle');
  if (!subtitleEl) {
    subtitleEl = document.createElement('p');
    subtitleEl.id = 'dialog-subtitle';
    subtitleEl.style.cssText = 'font-size:11px;color:var(--text-dim);margin-bottom:12px;';
    document.getElementById('dialog').insertBefore(subtitleEl, document.querySelector('.dialog-btns'));
  }
  subtitleEl.style.display = '';
  subtitleEl.innerHTML =
    'Enter the <b>absolute path</b> to the project folder on disk.<br>' +
    'The IDE will open runs in a real window using <span style="color:var(--accent)">file://</span> — ' +
    'all relative imports resolve natively.<br>' +
    '<span style="color:var(--text-faint);font-size:10px">' +
    'e.g.&nbsp; /home/me/myproject &nbsp;or&nbsp; C:/Users/me/myproject</span>';

  document.getElementById('dialog-title').textContent = '📁 Set Project Directory';
  document.getElementById('dialog-ok').textContent = 'Set & Run';
  const inp = document.getElementById('dialog-input');
  inp.value = prefill || knownProjectDir || '';
  inp.placeholder = '/home/me/myproject';
  inp.style.display = '';
  document.getElementById('dialog-overlay').classList.add('visible');
  inp.focus(); inp.select();

  dialogCallback = async (val) => {
    val = val.trim().replace(/[/\\]+$/, '');
    if (!val) return;
    knownProjectDir = val;
    subtitleEl.style.display = 'none';
    document.getElementById('dialog-ok').textContent = 'Create';
    termLog('sys', 'Project dir: ' + knownProjectDir);
    updateDirButtonUI();
    if (onSet) onSet(knownProjectDir);
  };
}

// ── Run in about:blank with file:// base ─────────────────────────
// Opens a real browser window, writes raw HTML + <base> tag.
// No bundling needed — the browser resolves all relative paths natively.
async function runInBlank(htmlPath, projectDir) {
  const strippedPath = htmlPath.replace(/^\/+/, '');
  const srcEntry = sharedMapLookup(strippedPath);
  let html;
  if (srcEntry) {
    html = await (await srcEntry.handle.getFile()).text();
  } else {
    html = await fsReadFile(htmlPath);
  }

  const baseUrl = diskPathToFileUrl(projectDir);
  const baseTag = '<base href="' + baseUrl + '">';

  // Inject base tag at top of <head>, or prepend if no <head>
  if (/<head[\s>]/i.test(html)) {
    html = html.replace(/(<head[^>]*>)/i, '$1' + baseTag);
  } else if (/<html[\s>]/i.test(html)) {
    html = html.replace(/(<html[^>]*>)/i, '$1<head>' + baseTag + '</head>');
  } else {
    html = baseTag + html;
  }

  const popup = window.open('about:blank', '_blank',
    'width=1024,height=768,toolbar=1,menubar=0,location=1,status=0,scrollbars=1,resizable=1');
  if (!popup) {
    termLog('warn', 'Popup blocked — allow popups for this site and try again.');
    return;
  }
  popup.document.open();
  popup.document.write(html);
  popup.document.close();
  termLog('info', 'Opened in window: ' + baseUrl + pathBasename(htmlPath));
}

// ── Smart Run: use about:blank+file:// if project dir known, else srcdoc bundler ──
async function runProject(htmlPath) {
  if (!htmlPath) {
    // fallback: find active HTML tab
    if (!activeTab) { termLog('warn', 'No file open.'); return; }
    htmlPath = activeTab;
  }
  const ext = htmlPath.split('.').pop().toLowerCase();
  if (ext !== 'html' && ext !== 'htm') { await runJS(htmlPath); return; }

  // Check if the HTML has file:// refs we can use to auto-detect project dir
  let html;
  try {
    const strippedPath = htmlPath.replace(/^\/+/, '');
    const srcEntry = sharedMapLookup(strippedPath);
    html = srcEntry
      ? await (await srcEntry.handle.getFile()).text()
      : await fsReadFile(htmlPath);
  } catch(e) { html = ''; }

  // Auto-detect project dir from file:// refs in source if not already set
  if (!knownProjectDir) {
    const guessed = guessProjectDir(html);
    if (guessed) { knownProjectDir = guessed; updateDirButtonUI(); }
  }

  if (knownProjectDir) {
    // We know the dir — open natively in about:blank with file:// base
    await runInBlank(htmlPath, knownProjectDir);
  } else {
    // No dir known: check if there are unresolvable file:// refs → ask user
    const fileUrls = scanForFileUrls(html);
    const hasUnresolved = fileUrls.some(u => !sharedMapLookup(u));
    const hasRelModules = /import\s*['"]\.\.?\//.test(html) || /type\s*=\s*["']module["']/.test(html);

    if (hasUnresolved || hasRelModules) {
      // Ask for project dir, then open in blank
      const guessed = guessProjectDir(html);
      askProjectDir(guessed, async (dir) => {
        await runInBlank(htmlPath, dir);
      });
    } else {
      // No external refs — safe to use srcdoc bundler inline
      await runHTML(htmlPath);
    }
  }
}

// ── ensureSharedMapForFileUrls: stub (kept for compat) ──
async function ensureSharedMapForFileUrls(fileUrls, relPaths) {
  relPaths = relPaths || [];
  const unresolvedFile = fileUrls.filter(u => !sharedMapLookup(u));
  if (!unresolvedFile.length) return true;
  termLog('warn', unresolvedFile.length + ' file:// ref(s) not in Shared Files — open the folder via 🖥️ panel to grant access');
  return false;
}

// Update the Dir button UI to reflect current knownProjectDir
function updateDirButtonUI() {
  const btn = document.getElementById('btn-project-dir');
  const ptabBtn = document.getElementById('ptab-btn-dir');
  const runBtn = document.getElementById('btn-run');
  if (!btn) return;
  if (knownProjectDir) {
    const short = knownProjectDir.split(/[/\\]/).pop();
    btn.textContent = '📂 ' + short;
    btn.classList.add('dir-set');
    btn.title = 'Project dir: ' + knownProjectDir + '\nClick to change';
    if (ptabBtn) { ptabBtn.textContent = '📂 ' + short; ptabBtn.classList.add('dir-set'); }
    if (runBtn) runBtn.title = 'Run in window (file://' + knownProjectDir + ')';
  } else {
    btn.textContent = '📂 Dir';
    btn.classList.remove('dir-set');
    btn.title = 'Set project directory for native file:// loading';
    if (ptabBtn) { ptabBtn.textContent = '📂 dir'; ptabBtn.classList.remove('dir-set'); }
    if (runBtn) runBtn.title = 'Run (Ctrl+Enter) — set project dir to open in native window';
  }
}

// Show the Set Project Dir dialog (manual trigger from menu/button)
function promptSetProjectDir() {
  askProjectDir(knownProjectDir || '', (dir) => {
    updateDirButtonUI();
  });
}


// pathBasename: extract filename from any path or URL
function pathBasename(src) {
  return src.replace(/[?#].*$/, '').split('/').filter(Boolean).pop() || '';
}

// Resolve a file:// or relative src against sharedFileMap by trying:
// 1. Exact vPath match (stripped)
// 2. Tail/filename match across all shared entries
// Returns { entry, isBinary } or null
function sharedMapLookup(src) {
  if (!sharedFileMap || sharedFileMap.size === 0) return null;
  // Normalize: strip file:// prefix or leading slashes
  const stripped = src.replace(/^file:\/\//, '').replace(/^\/+/, '');
  // 1. Exact
  if (sharedFileMap.has(stripped)) return sharedFileMap.get(stripped);
  // 2. Tail match — longest suffix match wins
  const parts = stripped.split('/');
  for (let i = 0; i < parts.length; i++) {
    const tail = parts.slice(i).join('/');
    for (const [vp, entry] of sharedFileMap) {
      if (vp === tail || vp.endsWith('/' + tail)) return entry;
    }
  }
  // 3. Basename only
  const base = parts[parts.length - 1];
  for (const [vp, entry] of sharedFileMap) {
    if (vp === base || vp.endsWith('/' + base)) return entry;
  }
  return null;
}


async function runJS(jsPath) {
  switchPanelTab('terminal');
  termLog('sys', 'Executing: ' + jsPath);
  // Live editor first, then VFS
  const liveTab = openTabs.find(t => t.path === jsPath);
  let code;
  if (liveTab) { code = liveTab.model.getValue(); }
  else {
    try { code = await fsReadFile(jsPath); }
    catch(e) { termLog('error', 'Could not read: ' + jsPath); return; }
  }
  // Base64-encode so no raw <[/]script> can appear in the srcdoc
  const b64 = btoa(unescape(encodeURIComponent(code)));
  const fname = jsPath.split('/').pop();
  const CT = '<' + '/script>';
  const consoleSrc = '(function(){'
    + 'var _={log:console.log,warn:console.warn,error:console.error,info:console.info};'
    + 'function p(l,a){try{parent.postMessage({__void:true,level:l,msg:a.map(function(x){'
    + 'try{return typeof x==="object"?JSON.stringify(x,null,2):String(x);}catch(ee){return String(x);}'
    + '}).join(" ")},"*");}catch(ee){}}'
    + 'console.log=function(){_.log.apply(console,arguments);p("log",[].slice.call(arguments));};'
    + 'console.warn=function(){_.warn.apply(console,arguments);p("warn",[].slice.call(arguments));};'
    + 'console.error=function(){_.error.apply(console,arguments);p("error",[].slice.call(arguments));};'
    + 'console.info=function(){_.info.apply(console,arguments);p("info",[].slice.call(arguments));};'
    + 'window.onerror=function(m,s,l){p("error",["Uncaught: "+m+" (line "+l+")"]);};'
    + 'window.addEventListener("unhandledrejection",function(e){p("error",["Promise: "+String(e.reason)]);});'
    + '})();';
  const evalSrc = '(function(){'
    + 'var raw=atob("' + b64 + '");'
    + 'var src=decodeURIComponent(escape(raw));'
    + 'var blob=new Blob([src],{type:"text/javascript"});'
    + 'var url=URL.createObjectURL(blob);'
    + 'import(url).catch(function(e){console.error("Runtime error: "+e.message);});'
    + '})();';
  const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>' + fname + CT
    + '</title></head><body>'
    + '<script>' + consoleSrc + CT
    + '<script>' + buildFetchBridge() + CT
    + '<script type="module">' + evalSrc + CT
    + '</body></html>';
  document.getElementById('preview-frame').srcdoc = html;
}

// Receive console messages from iframe
window.addEventListener('message', e => {
  const d = e.data;
  if (!d||!d.__void) return;
  const l = d.level||'log';
  termLog(l, d.msg);
});

// ═══════════════════════════════════════════════════════════════════
//  TERMINAL OUTPUT
// ═══════════════════════════════════════════════════════════════════
function ts() { return new Date().toLocaleTimeString('en-US',{hour12:false}); }

function termLog(level, msg) {
  const out = document.getElementById('terminal-output');
  const el  = document.createElement('div');
  el.className = 'term-line';
  const msgCls = (level==='error'?'error':level==='warn'?'warn':'');
  el.innerHTML =
    `<span class="term-ts">${ts()}</span>` +
    `<span class="term-tag ${level}">${level.toUpperCase()}</span>` +
    `<span class="term-msg ${msgCls}">${escH(String(msg))}</span>`;
  out.appendChild(el);
  out.scrollTop = out.scrollHeight;
}

function escH(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function clearTerminal() { document.getElementById('terminal-output').innerHTML=''; }

// ═══════════════════════════════════════════════════════════════════
//  PANEL TABS + RESIZE
// ═══════════════════════════════════════════════════════════════════
function switchPanelTab(name) {
  document.querySelectorAll('.panel-view').forEach(v=>v.classList.remove('active'));
  document.querySelectorAll('.ptab').forEach(t=>t.classList.remove('active'));
  document.getElementById('view-'+name).classList.add('active');
  document.getElementById('ptab-'+name).classList.add('active');
  if (name === 'shell') {
    setTimeout(() => {
      initZshTerminal();
      if (zshTerm && zshFitAddon) {
        try { zshFitAddon.fit(); } catch(e) {}
        zshTerm.focus();
      }
    }, 30);
  }
  if (name === 'hex') {
    setTimeout(() => {
      if (HEX.data) hexRender();
      const bc = document.getElementById('hex-bytes-col');
      if (bc) bc.focus();
    }, 30);
  }
}

function togglePanel() {
  const pa = document.getElementById('panel-area');
  const pr = document.getElementById('panel-resize');
  const hidden = pa.style.display==='none';
  pa.style.display  = hidden ? '' : 'none';
  pr.style.display  = hidden ? '' : 'none';
}

// Panel resize drag
(function(){
  const handle = document.getElementById('panel-resize');
  const panel  = document.getElementById('panel-area');
  let dragging = false, startY, startH;
  handle.addEventListener('mousedown', e => {
    dragging=true; startY=e.clientY; startH=panel.offsetHeight;
    handle.classList.add('dragging');
    e.preventDefault();
  });
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const delta = startY - e.clientY;
    const newH  = Math.min(Math.max(startH+delta, 80), window.innerHeight*0.75);
    panel.style.height = newH+'px';
  });
  document.addEventListener('mouseup', ()=>{ dragging=false; handle.classList.remove('dragging'); });
})();

// Sidebar resize drag
(function(){
  const handle  = document.getElementById('sidebar-resize');
  const sidebar = document.getElementById('sidebar');
  let dragging=false, startX, startW;
  handle.addEventListener('mousedown', e => {
    dragging=true; startX=e.clientX; startW=sidebar.offsetWidth;
    handle.classList.add('dragging'); e.preventDefault();
  });
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const newW = Math.min(Math.max(startW+(e.clientX-startX), 120), 500);
    sidebar.style.width = newW+'px';
    document.documentElement.style.setProperty('--sidebar-w', newW+'px');
  });
  document.addEventListener('mouseup', ()=>{ dragging=false; handle.classList.remove('dragging'); });
})();

function toggleSidebar() {
  const sb = document.getElementById('sidebar');
  const sr = document.getElementById('sidebar-resize');
  const ab = document.getElementById('activitybar');
  const hidden = sb.style.display==='none';
  sb.style.display = hidden?'':'none';
  sr.style.display = hidden?'':'none';
}

// ═══════════════════════════════════════════════════════════════════
//  CONTEXT MENU
// ═══════════════════════════════════════════════════════════════════
function showCtxMenu(x, y, path, isDir) {
  ctxTarget = { path, isDir };
  const menu = document.getElementById('ctx-menu');
  menu.style.left = Math.min(x, window.innerWidth-180)+'px';
  menu.style.top  = Math.min(y, window.innerHeight-200)+'px';
  menu.classList.add('visible');
  document.getElementById('ctx-open').style.display    = isDir?'none':'flex';
  document.getElementById('ctx-newfile').style.display  = isDir?'flex':'flex';
  document.getElementById('ctx-newfolder').style.display= isDir?'flex':'flex';
}

document.addEventListener('click', ()=>document.getElementById('ctx-menu').classList.remove('visible'));

document.getElementById('ctx-open').addEventListener('click', ()=>{
  if (ctxTarget && !ctxTarget.isDir) openFile(ctxTarget.path);
});
document.getElementById('ctx-rename').addEventListener('click', async ()=>{
  if (!ctxTarget) return;
  const curName = ctxTarget.path.split('/').pop();
  const dir = ctxTarget.path.split('/').slice(0,-1).join('/') || '/';
  showDialog('Rename', curName, 'Rename', async newName => {
    if (!newName || newName === curName) return;
    const newPath = joinPath(dir, newName);
    try {
      await fsRename(ctxTarget.path, newPath);
      // Update open tabs
      const tab = openTabs.find(t=>t.path===ctxTarget.path);
      if (tab) { tab.path = newPath; if (activeTab===ctxTarget.path) activeTab=newPath; }
      renderTabs(); refreshTree();
    } catch(e) { termLog('error','Rename failed: '+e.message); }
  });
});
document.getElementById('ctx-delete').addEventListener('click', async ()=>{
  if (!ctxTarget) return;
  showConfirm('Delete ' + ctxTarget.path + '?', '', async () => {
    try {
      if (ctxTarget.isDir) await fsRmdirR(ctxTarget.path);
      else { await fsUnlink(ctxTarget.path); closeTab(ctxTarget.path); }
      refreshTree();
      termLog('sys', `Deleted: ${ctxTarget.path}`);
    } catch(e) { termLog('error','Delete failed: '+e.message); }
  });
});
document.getElementById('ctx-newfile').addEventListener('click', ()=>{
  if (!ctxTarget) return;
  const dir = ctxTarget.isDir ? ctxTarget.path : ctxTarget.path.split('/').slice(0,-1).join('/')||'/';
  showNewFileDialog(dir);
});
document.getElementById('ctx-newfolder').addEventListener('click', ()=>{
  if (!ctxTarget) return;
  const dir = ctxTarget.isDir ? ctxTarget.path : ctxTarget.path.split('/').slice(0,-1).join('/')||'/';
  showNewFolderDialog(dir);
});

// ═══════════════════════════════════════════════════════════════════
//  DIALOGS
// ═══════════════════════════════════════════════════════════════════
let dialogCallback = null;

function showDialog(title, placeholder, okLabel, cb) {
  document.getElementById('dialog-title').textContent = title;
  document.getElementById('dialog-input').value = '';
  document.getElementById('dialog-input').placeholder = placeholder;
  document.getElementById('dialog-ok').textContent = okLabel;
  document.getElementById('dialog-overlay').classList.add('visible');
  document.getElementById('dialog-input').focus();
  dialogCallback = cb;
}

function closeDialog() {
  document.getElementById('dialog-overlay').classList.remove('visible');
  dialogCallback = null;
  _restoreDialog();
}

// ── Confirm dialog (replaces window.confirm) ──────────────────────
let _confirmOk = null, _confirmCancel = null;

function showConfirm(title, subtitle, onOk, onCancel) {
  _confirmOk = onOk || null;
  _confirmCancel = onCancel || null;
  document.getElementById('dialog-title').textContent = title;

  const inp = document.getElementById('dialog-input');
  inp.style.display = 'none';

  let subtitleEl = document.getElementById('dialog-subtitle');
  if (!subtitleEl) {
    subtitleEl = document.createElement('p');
    subtitleEl.id = 'dialog-subtitle';
    subtitleEl.style.cssText = 'font-size:11px;color:var(--text-dim);margin-bottom:12px;';
    document.getElementById('dialog').insertBefore(subtitleEl, document.querySelector('.dialog-btns'));
  }
  subtitleEl.textContent = subtitle || '';
  subtitleEl.style.display = subtitle ? '' : 'none';

  document.getElementById('dialog-ok').textContent = 'OK';
  document.getElementById('dialog-overlay').classList.add('visible');
  inp.focus();
}

// ── Folder access modal (for ensureSharedMapForFileUrls) ──────────
function _restoreDialog() {
  _confirmOk = null; _confirmCancel = null;
  document.getElementById('dialog-input').style.display = '';
  document.getElementById('dialog-ok').textContent = 'Create';
  const sub = document.getElementById('dialog-subtitle');
  if (sub) sub.style.display = 'none';
}

document.getElementById('dialog-ok').addEventListener('click', async ()=>{
  // Confirm/modal mode
  if (_confirmOk) {
    const fn = _confirmOk;
    document.getElementById('dialog-overlay').classList.remove('visible');
    _restoreDialog();
    await fn();
    return;
  }
  // Normal dialog mode
  if (!dialogCallback) return;
  const val = document.getElementById('dialog-input').value.trim();
  if (!val) { closeDialog(); return; }
  await dialogCallback(val);
  closeDialog();
});

document.getElementById('dialog-input').addEventListener('keydown', e=>{
  if (e.key==='Enter') document.getElementById('dialog-ok').click();
  if (e.key==='Escape') closeDialog();
});

document.getElementById('dialog-overlay').addEventListener('click', e=>{
  if (e.target===document.getElementById('dialog-overlay')) {
    const fn = _confirmCancel;
    closeDialog();
    if (fn) fn();
  }
});

function showNewFileDialog(dir='/') {
  showDialog('New File', 'filename.js', 'Create', async name=>{
    const path = joinPath(dir, name);
    try {
      await fsWriteFileSafe(path, '');
      termLog('sys', 'Created: '+path);
      await refreshTree();
      await openFile(path);
    } catch(e) { termLog('error','Create failed: '+e.message); }
  });
}

function showNewFolderDialog(dir='/') {
  showDialog('New Folder', 'folder-name', 'Create', async name=>{
    const path = joinPath(dir, name);
    try {
      await fsMkdirP(path);
      treeExpanded.add(path);
      termLog('sys', 'Created folder: '+path);
      await refreshTree();
    } catch(e) { termLog('error','Create failed: '+e.message); }
  });
}

// ═══════════════════════════════════════════════════════════════════
//  ACTIVITY BAR
// ═══════════════════════════════════════════════════════════════════
function setActivity(name) {
  document.querySelectorAll('.act-btn').forEach(b=>b.classList.remove('active'));
  document.getElementById('act-'+name).classList.add('active');
  document.getElementById('sidebar-explorer').style.display = name==='files'  ? '' : 'none';
  document.getElementById('sidebar-search').style.display   = name==='search' ? '' : 'none';
  document.getElementById('sidebar-shared').style.display   = name==='shared' ? '' : 'none';
  if (name==='shared') sharedRender();
}

// ═══════════════════════════════════════════════════════════════════
//  SEARCH
// ═══════════════════════════════════════════════════════════════════
async function doSearch(query) {
  const out = document.getElementById('search-results');
  if (!query.trim()) { out.innerHTML=''; return; }
  out.innerHTML = '<span style="color:var(--text-faint)">Searching…</span>';
  const results = [];
  await searchDir('/', query.toLowerCase(), results);
  if (!results.length) { out.innerHTML='<span style="color:var(--text-faint)">No results</span>'; return; }
  out.innerHTML = results.slice(0,50).map(r=>`
    <div style="padding:4px 0;cursor:pointer;border-bottom:1px solid var(--border)"
         onclick="openFile('${r.path}')">
      <div style="color:var(--text);font-size:11px">${r.path.split('/').pop()}</div>
      <div style="color:var(--text-faint);font-size:10px">${escH(r.line)}</div>
    </div>`).join('');
}

async function searchDir(dir, query, results) {
  const items = await fsReaddir(dir).catch(()=>[]);
  for (const item of items) {
    const path = joinPath(dir, item);
    const stat = await fsStat(path).catch(()=>null);
    if (!stat) continue;
    if (stat.isDirectory()) { await searchDir(path, query, results); continue; }
    try {
      const content = await fsReadFile(path);
      const lines   = content.split('\n');
      for (const line of lines) {
        if (line.toLowerCase().includes(query)) {
          results.push({ path, line: line.trim().slice(0,60) });
          break;
        }
      }
    } catch {}
  }
}

// ═══════════════════════════════════════════════════════════════════
//  IMPORT / EXPORT
// ═══════════════════════════════════════════════════════════════════
function importFile() {
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='*/*';
  inp.onchange = async () => {
    const file = inp.files[0]; if (!file) return;
    const path = '/' + file.name;
    const isBinary = /\.(png|jpg|jpeg|gif|webp|bmp|ico|woff2?|ttf|otf|mp3|mp4|wav|ogg|pdf|zip|gz|wasm|avif)$/i.test(file.name);
    const reader = new FileReader();
    reader.onload = async e => {
      await fsWriteFileSafe(path, e.target.result);
      termLog('sys', 'Imported: ' + path);
      refreshTree(); openFile(path);
    };
    if (isBinary) reader.readAsDataURL(file); else reader.readAsText(file);
  };
  inp.click();
}

function exportFile() {
  if (!activeTab) return;
  const tab = openTabs.find(t=>t.path===activeTab);
  if (!tab) return;
  const content = tab.model.getValue();
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = activeTab.split('/').pop();
  a.click();
  termLog('sys', `Exported: ${activeTab}`);
}

// ═══════════════════════════════════════════════════════════════════
//  RESET FS
// ═══════════════════════════════════════════════════════════════════
async function resetFS() {
  showConfirm('Reset filesystem?', 'All files will be lost.', async () => {
    // Close all tabs
    openTabs.forEach(t=>t.model.dispose());
    openTabs=[]; activeTab=null;
    monacoEditor.setModel(null);
    document.getElementById('empty-state').style.display='flex';
    renderTabs();
    // Delete everything under /
    const topItems = await fsReaddir('/').catch(()=>[]);
    for (const item of topItems) {
      if (item.startsWith('.')) continue;
      const p = '/' + item;
      const s = await fsStat(p).catch(()=>null);
      if (!s) continue;
      if (s.isDirectory()) await fsRmdirR(p);
      else await fsUnlink(p).catch(()=>{});
    }
    // Re-seed with defaults
    for (const [path, content] of Object.entries(DEFAULT_FILES)) {
      await fsWriteFileSafe(path, content);
    }
    termLog('sys','Filesystem reset. Default files restored.');
    await refreshTree();
    if (await fsExists('/index.html')) await openFile('/index.html');
  });
}

// ═══════════════════════════════════════════════════════════════════
//  SETTINGS
// ═══════════════════════════════════════════════════════════════════
const DEFAULT_SETTINGS = {
  fontSize: 13, tabSize: 4, wordWrap: false, minimap: true,
  lineNumbers: true, cursorBlinking: 'smooth', cursorStyle: 'line',
  autoSave: false, formatOnSave: false, bracketColorization: true,
  smoothScrolling: true, scanlines: true, uiFontSize: 13,
  panelHeight: 200, fetchPreload: true, fetchDepth: 3,
  autoPreview: true, iframeSandbox: 'allow-scripts allow-forms allow-modals allow-popups allow-same-origin',
  liveDebounce: 500, accentColor: '#00d4ff', webpackCompat: true,
  theme: 'void', sidebarWidth: 220, tabStyle: 'default', sbStyle: 'accent',
  glow: true, animations: true, compact: false, actLabels: false, indentGuides: true,
  uiFontFamily: "'JetBrains Mono', monospace",
  // v0.21 new settings
  lineHighlight: 'line', letterSpacing: 0, lineHeight: 1.5,
  borderRadius: 3, cursorColor: '#00d4ff', showEncoding: true,
};
let ideSettings = { ...DEFAULT_SETTINGS };

// Theme palette definitions
const THEMES = {
  void:    { bg0:'#080b0f', bg1:'#0d1117', bg2:'#111820', bg3:'#161f2b', bg4:'#1c2736', border:'#1e2d3d', border2:'#253545', accent:'#00d4ff', accentDim:'#0099bb', text:'#cdd9e5', textDim:'#768a9e', textFaint:'#3d5266', green:'#3ddc84', red:'#ff4c6a', yellow:'#f0c040', purple:'#c792ea' },
  midnight:{ bg0:'#0a0a1a', bg1:'#0f0f24', bg2:'#14142e', bg3:'#1a1a3a', bg4:'#202048', border:'#2a2a5a', border2:'#35357a', accent:'#7c6fcd', accentDim:'#5a4fa0', text:'#c8c5e8', textDim:'#7070a8', textFaint:'#404068', green:'#56d364', red:'#ff4c6a', yellow:'#f0c040', purple:'#c792ea' },
  forest:  { bg0:'#0d1a0d', bg1:'#101f10', bg2:'#152515', bg3:'#1a2e1a', bg4:'#1f381f', border:'#1e3b1e', border2:'#254a25', accent:'#3ddc84', accentDim:'#2aaa65', text:'#c8e5c8', textDim:'#6a8a6a', textFaint:'#3a5a3a', green:'#3ddc84', red:'#ff6b6b', yellow:'#f0c040', purple:'#c792ea' },
  rose:    { bg0:'#120a10', bg1:'#170d15', bg2:'#1e1020', bg3:'#251428', bg4:'#2e1a32', border:'#3d1a38', border2:'#4d2448', accent:'#ff4c6a', accentDim:'#cc3355', text:'#e5c0d0', textDim:'#907080', textFaint:'#503840', green:'#3ddc84', red:'#ff4c6a', yellow:'#f0c040', purple:'#ff79c6' },
  amber:   { bg0:'#110d00', bg1:'#181200', bg2:'#201800', bg3:'#281f00', bg4:'#322800', border:'#3d3000', border2:'#4d3c00', accent:'#ffb347', accentDim:'#cc8800', text:'#e8d5a0', textDim:'#907850', textFaint:'#554530', green:'#3ddc84', red:'#ff4c6a', yellow:'#ffb347', purple:'#c792ea' },
  ice:     { bg0:'#071018', bg1:'#0b1620', bg2:'#101e2c', bg3:'#152536', bg4:'#1a2e42', border:'#1e3a50', border2:'#254865', accent:'#86e1fb', accentDim:'#55b8e0', text:'#c8e8f5', textDim:'#6a9ab0', textFaint:'#354a5a', green:'#8be9fd', red:'#ff79c6', yellow:'#f1fa8c', purple:'#bd93f9' },
  dracula: { bg0:'#1e1f29', bg1:'#282a36', bg2:'#2f3140', bg3:'#363846', bg4:'#414354', border:'#44475a', border2:'#565970', accent:'#bd93f9', accentDim:'#9668d0', text:'#f8f8f2', textDim:'#8892a0', textFaint:'#44475a', green:'#50fa7b', red:'#ff5555', yellow:'#f1fa8c', purple:'#bd93f9' },
  monokai: { bg0:'#1c1c1c', bg1:'#272822', bg2:'#2f2f2a', bg3:'#363631', bg4:'#3e3e38', border:'#49483e', border2:'#5a5a50', accent:'#a6e22e', accentDim:'#80b820', text:'#f8f8f2', textDim:'#90908a', textFaint:'#49483e', green:'#a6e22e', red:'#f92672', yellow:'#e6db74', purple:'#ae81ff' },
};

function applyTheme(name, cardEl) {
  const t = THEMES[name];
  if (!t) return;
  const r = document.documentElement.style;
  r.setProperty('--bg0', t.bg0);
  r.setProperty('--bg1', t.bg1);
  r.setProperty('--bg2', t.bg2);
  r.setProperty('--bg3', t.bg3);
  r.setProperty('--bg4', t.bg4);
  r.setProperty('--border', t.border);
  r.setProperty('--border2', t.border2);
  r.setProperty('--accent', t.accent);
  r.setProperty('--accent-dim', t.accentDim);
  r.setProperty('--text', t.text);
  r.setProperty('--text-dim', t.textDim);
  r.setProperty('--text-faint', t.textFaint);
  r.setProperty('--green', t.green);
  r.setProperty('--red', t.red);
  r.setProperty('--yellow', t.yellow);
  r.setProperty('--purple', t.purple);
  // Derive accent-rgb from accent hex
  const hex = t.accent.replace('#','');
  const rgb = [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)].join(',');
  r.setProperty('--accent-rgb', rgb);
  // Update glow
  r.setProperty('--glow', `0 0 12px rgba(${rgb},0.3)`);
  r.setProperty('--glow-sm', `0 0 6px rgba(${rgb},0.2)`);
  r.setProperty('--glow-lg', `0 0 28px rgba(${rgb},0.45)`);
  ideSettings.theme = name;
  ideSettings.accentColor = t.accent;
  // Update swatch selection
  document.querySelectorAll('.set-theme-card').forEach(c => c.classList.toggle('selected', c.dataset.theme === name));
  document.querySelectorAll('.set-swatch').forEach(s => s.classList.toggle('selected', s.dataset.color === t.accent));
  // Sync Monaco if open
  if (window.monacoEditor) {
    monacoEditor.updateOptions({});
  }
  saveSettings();
}

function toggleAppearanceFx(fx, el) {
  el.classList.toggle('on');
  ideSettings[fx] = el.classList.contains('on');
  applyAppearanceFx();
  saveSettings();
}

function applyAppearanceFx() {
  const r = document.documentElement.style;
  // Glow
  if (!ideSettings.glow) {
    r.setProperty('--glow', 'none');
    r.setProperty('--glow-sm', 'none');
    r.setProperty('--glow-lg', 'none');
  }
  // Animations
  const noAnim = document.getElementById('void-no-anim-style') || (() => { const s = document.createElement('style'); s.id='void-no-anim-style'; document.head.appendChild(s); return s; })();
  noAnim.textContent = ideSettings.animations ? '' : '*{transition:none!important;animation:none!important}';
  // Compact mode
  const compact = document.getElementById('void-compact-style') || (() => { const s = document.createElement('style'); s.id='void-compact-style'; document.head.appendChild(s); return s; })();
  compact.textContent = ideSettings.compact ? ':root{--tab-h:26px;--title-h:32px;--status-h:22px}.set-row{padding:6px 0}.act-btn{height:28px;width:28px}.tree-item{padding:1px 0 1px 0}' : '';
  // Activity labels
  const actBtns = document.querySelectorAll('.act-btn');
  actBtns.forEach(b => { if (ideSettings.actLabels) b.style.height='50px'; else b.style.height=''; });
}

function applyStatusBarStyle(style) {
  ideSettings.sbStyle = style;
  const sb = document.getElementById('statusbar');
  if (!sb) return;
  const sbStyleEl = document.getElementById('void-sb-style') || (() => { const s = document.createElement('style'); s.id='void-sb-style'; document.head.appendChild(s); return s; })();
  const styles = {
    accent: '#statusbar{background:var(--accent)}',
    dark: '#statusbar{background:var(--bg1);border-top:1px solid var(--border)}#statusbar,#statusbar *{color:var(--text-dim)!important}#sb-branch-area{background:rgba(var(--accent-rgb),.15)}',
    glass: '#statusbar{background:rgba(var(--accent-rgb),.12);backdrop-filter:blur(8px);border-top:1px solid rgba(var(--accent-rgb),.2)}#statusbar,#statusbar *{color:var(--text)!important}',
    gradient: '#statusbar{background:linear-gradient(90deg,var(--accent),var(--accent-dim) 40%,var(--bg2) 100%)}',
  };
  sbStyleEl.textContent = styles[style] || styles.accent;
  saveSettings();
}

function loadSettings() {
  try {
    const saved = localStorage.getItem('void-settings-v1');
    if (saved) ideSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
  } catch(e) {}
  applyAllSettings();
}

function saveSettings() {
  try { localStorage.setItem('void-settings-v1', JSON.stringify(ideSettings)); } catch(e) {}
}

function applyAllSettings() {
  // Editor options
  if (window.monacoEditor) {
    monacoEditor.updateOptions({
      fontSize: ideSettings.fontSize,
      tabSize: ideSettings.tabSize,
      wordWrap: ideSettings.wordWrap ? 'on' : 'off',
      minimap: { enabled: ideSettings.minimap },
      lineNumbers: ideSettings.lineNumbers ? 'on' : 'off',
      cursorBlinking: ideSettings.cursorBlinking,
      cursorStyle: ideSettings.cursorStyle,
      bracketPairColorization: { enabled: ideSettings.bracketColorization },
      smoothScrolling: ideSettings.smoothScrolling,
      guides: { indentation: ideSettings.indentGuides },
      renderLineHighlight: ideSettings.lineHighlight || 'line',
      letterSpacing: ideSettings.letterSpacing || 0,
      lineHeight: ideSettings.lineHeight || 0,
    });
  }
  // Theme
  if (ideSettings.theme && ideSettings.theme !== 'void') {
    applyTheme(ideSettings.theme, null);
  }
  // Accent color override (if not from theme)
  if (ideSettings.accentColor) {
    document.documentElement.style.setProperty('--accent', ideSettings.accentColor);
    const hex = ideSettings.accentColor.replace('#','');
    if (hex.length === 6) {
      const rgb = [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)].join(',');
      document.documentElement.style.setProperty('--accent-rgb', rgb);
    }
  }
  // Scanlines
  let s = document.getElementById('void-no-scanlines-style');
  if (!s) { s = document.createElement('style'); s.id='void-no-scanlines-style'; document.head.appendChild(s); }
  s.textContent = ideSettings.scanlines ? '' : 'body::after{display:none!important}';
  // UI font size
  document.documentElement.style.fontSize = ideSettings.uiFontSize + 'px';
  // UI font family
  if (ideSettings.uiFontFamily) {
    const uff = document.getElementById('void-ui-font-style') || (() => { const el = document.createElement('style'); el.id='void-ui-font-style'; document.head.appendChild(el); return el; })();
    uff.textContent = `body, .sidebar-header, .tree-item, .ptab, .tbtn, #statusbar, #hex-toolbar { font-family: ${ideSettings.uiFontFamily}; }`;
  }
  // Panel height
  document.documentElement.style.setProperty('--panel-h', ideSettings.panelHeight + 'px');
  // Sidebar width
  if (ideSettings.sidebarWidth) document.documentElement.style.setProperty('--sidebar-w', ideSettings.sidebarWidth + 'px');
  // Tab style
  applyTabStyle(ideSettings.tabStyle || 'default');
  // Status bar style
  applyStatusBarStyle(ideSettings.sbStyle || 'accent');
  // Appearance effects
  applyAppearanceFx();
  // iframe sandbox
  const frame = document.getElementById('preview-frame');
  if (frame) frame.setAttribute('sandbox', ideSettings.iframeSandbox);
  // live debounce
  LIVE_DEBOUNCE_MS = ideSettings.liveDebounce || 500;
  // webpack compat
  _webpackCompatEnabled = ideSettings.webpackCompat !== false;
  // border radius
  if (ideSettings.borderRadius !== undefined) applyBorderRadius(String(ideSettings.borderRadius));
  // cursor color
  if (ideSettings.cursorColor) setCursorColor(ideSettings.cursorColor, null);
}

function applyTabStyle(style) {
  const tabStyleEl = document.getElementById('void-tab-style') || (() => { const s = document.createElement('style'); s.id='void-tab-style'; document.head.appendChild(s); return s; })();
  const styles = {
    default: '', // existing styles
    filled: '.tab.active{background:var(--accent);color:#000!important}.tab.active .tab-close{color:#000}.tab-dot{background:#000}',
    minimal: '.tab{border-top:none!important}.tab.active{border-bottom:2px solid var(--accent)!important;background:transparent}',
    pill: '#tabs-bar{padding:3px 6px;gap:3px}.tab{border-radius:6px;border:none!important;margin:0}.tab.active{background:rgba(var(--accent-rgb),.15)}.tab.active::before{content:"";position:absolute;inset:0;border-radius:6px;border:1px solid var(--accent)}'
  };
  tabStyleEl.textContent = styles[style] || '';
}

function applySettingLive(key, value) {
  ideSettings[key] = value;

  // Direct Monaco editor option updates — no full reload needed
  switch (key) {
    case 'fontSize':
      applyEditorOption({ fontSize: value });
      _syncSettingSlider('set-font-size', 'set-font-size-val', value, 'px');
      return saveSettings();

    case 'tabSize':
      applyEditorOption({ tabSize: value });
      return saveSettings();

    case 'wordWrap':
      applyEditorOption({ wordWrap: value ? 'on' : 'off' });
      return saveSettings();

    case 'minimap':
      applyEditorOption({ minimap: { enabled: value } });
      return saveSettings();

    case 'lineNumbers':
      applyEditorOption({ lineNumbers: value ? 'on' : 'off' });
      return saveSettings();

    case 'cursorBlinking':
      applyEditorOption({ cursorBlinking: value });
      return saveSettings();

    case 'cursorStyle':
      applyEditorOption({ cursorStyle: value });
      return saveSettings();

    case 'bracketColorization':
      applyEditorOption({ bracketPairColorization: { enabled: value } });
      return saveSettings();

    case 'smoothScrolling':
      applyEditorOption({ smoothScrolling: value });
      return saveSettings();

    case 'indentGuides':
      applyEditorOption({ guides: { indentation: value } });
      return saveSettings();

    case 'lineHighlight':
      applyEditorOption({ renderLineHighlight: value });
      return saveSettings();

    case 'letterSpacing':
      applyEditorOption({ letterSpacing: value });
      return saveSettings();

    case 'lineHeight':
      applyEditorOption({ lineHeight: value });
      return saveSettings();

    // UI-level settings — fast, no Monaco involved
    case 'uiFontSize':
      document.documentElement.style.fontSize = value + 'px';
      _syncSettingSlider('set-ui-font', 'set-ui-font-val', value, 'px');
      return saveSettings();

    case 'uiFontFamily': {
      const uff = document.getElementById('void-ui-font-style') ||
        (() => { const el = document.createElement('style'); el.id='void-ui-font-style'; document.head.appendChild(el); return el; })();
      uff.textContent = `body,.sidebar-header,.tree-item,.ptab,.tbtn,#statusbar,#hex-toolbar{font-family:${value}}`;
      return saveSettings();
    }

    case 'panelHeight':
      document.documentElement.style.setProperty('--panel-h', value + 'px');
      return saveSettings();

    case 'sidebarWidth':
      document.documentElement.style.setProperty('--sidebar-w', value + 'px');
      return saveSettings();

    case 'tabStyle':
      applyTabStyle(value);
      return saveSettings();

    case 'sbStyle':
      applyStatusBarStyle(value);
      return saveSettings();

    case 'scanlines': {
      let s = document.getElementById('void-no-scanlines-style');
      if (!s) { s = document.createElement('style'); s.id='void-no-scanlines-style'; document.head.appendChild(s); }
      s.textContent = value ? '' : 'body::after{display:none!important}';
      return saveSettings();
    }

    case 'accentColor': {
      document.documentElement.style.setProperty('--accent', value);
      const hex = value.replace('#','');
      if (hex.length === 6) {
        const r = parseInt(hex.slice(0,2),16), g = parseInt(hex.slice(2,4),16), b = parseInt(hex.slice(4,6),16);
        const rgb = r+','+g+','+b;
        document.documentElement.style.setProperty('--accent-rgb', rgb);
        document.documentElement.style.setProperty('--glow',    `0 0 12px rgba(${rgb},0.3)`);
        document.documentElement.style.setProperty('--glow-sm', `0 0 6px rgba(${rgb},0.2)`);
        document.documentElement.style.setProperty('--glow-lg', `0 0 28px rgba(${rgb},0.45)`);
      }
      return saveSettings();
    }

    case 'borderRadius':
      applyBorderRadius(String(value));
      return saveSettings();

    case 'cursorColor':
      setCursorColor(value, null);
      return saveSettings();

    case 'iframeSandbox': {
      const f = document.getElementById('preview-frame');
      if (f) f.setAttribute('sandbox', value);
      return saveSettings();
    }

    case 'liveDebounce':
      LIVE_DEBOUNCE_MS = value;
      return saveSettings();

    case 'webpackCompat':
      _webpackCompatEnabled = value;
      return saveSettings();

    case 'autoSave':
      // autoSave is handled by the Monaco content change listener — just save the setting
      return saveSettings();

    case 'formatOnSave':
      // formatOnSave is checked in saveCurrentFile — just save the setting
      return saveSettings();

    case 'fetchPreload':
    case 'fetchDepth':
    case 'autoPreview':
      return saveSettings();

    default:
      // For any unknown key, just save
      return saveSettings();
  }
}

function toggleSettingToggle(el, key) {
  el.classList.toggle('on');
  const value = el.classList.contains('on');
  applySettingLive(key, value);
}

function setAccentColor(color, swatchEl) {
  document.querySelectorAll('.set-swatch').forEach(s => s.classList.remove('selected'));
  if (swatchEl) swatchEl.classList.add('selected');
  applySettingLive('accentColor', color);
}

function openSettings(section) {
  // Sync UI state from ideSettings
  document.getElementById('set-font-size').value = ideSettings.fontSize;
  document.getElementById('set-font-size-val').textContent = ideSettings.fontSize + 'px';
  document.getElementById('set-tab-size').value = ideSettings.tabSize;
  document.getElementById('set-word-wrap').classList.toggle('on', ideSettings.wordWrap);
  document.getElementById('set-minimap').classList.toggle('on', ideSettings.minimap);
  document.getElementById('set-line-numbers').classList.toggle('on', ideSettings.lineNumbers);
  document.getElementById('set-cursor-blink').value = ideSettings.cursorBlinking;
  document.getElementById('set-cursor-style').value = ideSettings.cursorStyle;
  document.getElementById('set-auto-save').classList.toggle('on', ideSettings.autoSave);
  document.getElementById('set-fmt-save').classList.toggle('on', ideSettings.formatOnSave);
  document.getElementById('set-bracket-color').classList.toggle('on', ideSettings.bracketColorization);
  document.getElementById('set-smooth-scroll').classList.toggle('on', ideSettings.smoothScrolling);
  document.getElementById('set-scanlines').classList.toggle('on', ideSettings.scanlines);
  document.getElementById('set-ui-font').value = ideSettings.uiFontSize;
  document.getElementById('set-ui-font-val').textContent = ideSettings.uiFontSize + 'px';
  document.getElementById('set-panel-h').value = ideSettings.panelHeight;
  document.getElementById('set-panel-h-val').textContent = ideSettings.panelHeight + 'px';
  document.getElementById('set-fetch-preload').classList.toggle('on', ideSettings.fetchPreload);
  document.getElementById('set-fetch-depth').value = ideSettings.fetchDepth;
  document.getElementById('set-auto-preview').classList.toggle('on', ideSettings.autoPreview);
  document.getElementById('set-sandbox').value = ideSettings.iframeSandbox;
  document.getElementById('set-live-debounce').value = ideSettings.liveDebounce;
  document.getElementById('set-live-debounce-val').textContent = ideSettings.liveDebounce + 'ms';
  const wcEl = document.getElementById('set-webpack-compat');
  if (wcEl) wcEl.classList.toggle('on', ideSettings.webpackCompat !== false);
  const bdBtn = document.getElementById('set-basedir-btn');
  if (bdBtn) bdBtn.textContent = '📂 ' + (_preloadBaseDir ? '/' + _preloadBaseDir.slice(-12) : 'Set…');
  // accent swatches
  document.querySelectorAll('.set-swatch').forEach(s => {
    s.classList.toggle('selected', s.dataset.color === ideSettings.accentColor);
  });
  // theme cards
  document.querySelectorAll('.set-theme-card').forEach(c => {
    c.classList.toggle('selected', c.dataset.theme === (ideSettings.theme || 'void'));
  });
  // new appearance controls
  const trySet = (id, val, attr='value') => { const el = document.getElementById(id); if (el) el[attr] = val; };
  const tryToggle = (id, val) => { const el = document.getElementById(id); if (el) el.classList.toggle('on', !!val); };
  tryToggle('set-glow', ideSettings.glow !== false);
  tryToggle('set-animations', ideSettings.animations !== false);
  tryToggle('set-compact', !!ideSettings.compact);
  tryToggle('set-act-labels', !!ideSettings.actLabels);
  tryToggle('set-indent-guides', ideSettings.indentGuides !== false);
  tryToggle('set-show-encoding', ideSettings.showEncoding !== false);
  trySet('set-ui-font-family', ideSettings.uiFontFamily || "'JetBrains Mono', monospace");
  trySet('set-tab-style', ideSettings.tabStyle || 'default');
  trySet('set-sb-style', ideSettings.sbStyle || 'accent');
  trySet('set-sidebar-w', ideSettings.sidebarWidth || 220);
  trySet('set-border-radius', String(ideSettings.borderRadius || 3));
  trySet('set-line-highlight', ideSettings.lineHighlight || 'line');
  trySet('set-letter-spacing', ideSettings.letterSpacing || 0);
  trySet('set-line-height', ideSettings.lineHeight || 1.5);
  const lsVal = document.getElementById('set-letter-spacing-val');
  if (lsVal) lsVal.textContent = (ideSettings.letterSpacing || 0) + 'px';
  const lhVal = document.getElementById('set-line-height-val');
  if (lhVal) lhVal.textContent = (ideSettings.lineHeight || 1.5);
  const swVal = document.getElementById('set-sidebar-w-val');
  if (swVal) swVal.textContent = (ideSettings.sidebarWidth || 220) + 'px';
  // about storage
  const sm = document.getElementById('set-about-storage');
  if (sm) sm.textContent = _idb ? 'IndexedDB' : 'LocalStorage/Memory';
  // keybinds
  renderKeybindList();
  // Show modal
  document.getElementById('settings-overlay').classList.add('visible');
  if (section) showSettingsSection(section);
}

function closeSettings() {
  document.getElementById('settings-overlay').classList.remove('visible');
  saveSettings();
}

function showSettingsSection(sec) {
  document.querySelectorAll('.setnav-item').forEach(n => n.classList.toggle('active', n.dataset.sec === sec));
  document.querySelectorAll('.settings-section').forEach(s => s.classList.toggle('active', s.id === 'set-sec-' + sec));
  if (sec === 'advanced') advBuildPanel();
}

// ═══════════════════════════════════════════════════════════════════
//  ADVANCED MONACO CONFIG — about:config style
// ═══════════════════════════════════════════════════════════════════

// The master schema: every Monaco IEditorOptions key, its type, default,
// allowed values (for enums), category, and description.
const ADV_SCHEMA = [
  // ── Font ──────────────────────────────────────────────────────────
  { k:'fontSize',               cat:'font',    type:'number',  def:13,         min:6,  max:40,  step:1,   desc:'Editor font size in pixels' },
  { k:'lineHeight',             cat:'font',    type:'number',  def:0,          min:0,  max:80,  step:0.5, desc:'Line height (0 = auto from font size)' },
  { k:'letterSpacing',          cat:'font',    type:'number',  def:0,          min:-4, max:10,  step:0.5, desc:'Letter spacing in pixels' },
  { k:'fontLigatures',          cat:'font',    type:'boolean', def:true,                                  desc:'Enable font ligatures' },
  { k:'fontWeight',             cat:'font',    type:'select',  def:'normal',   opts:['normal','bold','100','200','300','400','500','600','700','800','900'], desc:'Font weight' },
  { k:'disableMonospaceOptimizations', cat:'font', type:'boolean', def:false,                             desc:'Disable monospace font optimizations (use if font looks wrong)' },

  // ── Cursor ────────────────────────────────────────────────────────
  { k:'cursorStyle',            cat:'cursor',  type:'select',  def:'line',     opts:['line','block','underline','line-thin','block-outline','underline-thin'], desc:'Shape of the cursor' },
  { k:'cursorBlinking',         cat:'cursor',  type:'select',  def:'blink',    opts:['blink','smooth','phase','expand','solid'], desc:'Cursor animation style' },
  { k:'cursorWidth',            cat:'cursor',  type:'number',  def:2,          min:1,  max:10,  step:1,   desc:'Width of the cursor (line style only)' },
  { k:'cursorSmoothCaretAnimation', cat:'cursor', type:'select', def:'off',    opts:['off','explicit','on'], desc:'Smooth caret animation' },
  { k:'multiCursorModifier',    cat:'cursor',  type:'select',  def:'alt',      opts:['ctrlCmd','alt'], desc:'Modifier key for adding multiple cursors' },
  { k:'multiCursorMergeOverlapping', cat:'cursor', type:'boolean', def:true,                              desc:'Merge overlapping multi-cursors' },
  { k:'multiCursorPaste',       cat:'cursor',  type:'select',  def:'spread',   opts:['spread','full'], desc:'Paste behavior with multiple cursors' },

  // ── Scroll ────────────────────────────────────────────────────────
  { k:'scrollBeyondLastLine',   cat:'scroll',  type:'boolean', def:true,                                  desc:'Allow scrolling past the last line' },
  { k:'scrollBeyondLastColumn', cat:'scroll',  type:'number',  def:5,          min:0,  max:20,  step:1,   desc:'Columns to scroll past last character' },
  { k:'smoothScrolling',        cat:'scroll',  type:'boolean', def:false,                                 desc:'Animate editor scroll' },
  { k:'fastScrollSensitivity',  cat:'scroll',  type:'number',  def:5,          min:1,  max:20,  step:1,   desc:'Scroll speed multiplier with Alt held' },
  { k:'mouseWheelScrollSensitivity', cat:'scroll', type:'number', def:1,        min:0.1,max:5,  step:0.1, desc:'Mouse wheel scroll speed multiplier' },
  { k:'mouseWheelZoom',         cat:'scroll',  type:'boolean', def:false,                                 desc:'Ctrl+scroll to zoom editor font size' },
  { k:'stickyScroll',           cat:'scroll',  type:'object',  def:{enabled:false},                       desc:'Show sticky scope headers while scrolling', jsonKey:'stickyScroll' },

  // ── Indent & Whitespace ───────────────────────────────────────────
  { k:'tabSize',                cat:'indent',  type:'number',  def:4,          min:1,  max:16,  step:1,   desc:'Number of spaces a tab counts for' },
  { k:'insertSpaces',           cat:'indent',  type:'boolean', def:true,                                  desc:'Insert spaces when pressing Tab' },
  { k:'detectIndentation',      cat:'indent',  type:'boolean', def:true,                                  desc:'Detect file indentation and override tabSize' },
  { k:'trimAutoWhitespace',     cat:'indent',  type:'boolean', def:true,                                  desc:'Trim auto-inserted trailing whitespace' },
  { k:'renderWhitespace',       cat:'indent',  type:'select',  def:'selection',opts:['none','boundary','selection','trailing','all'], desc:'Render whitespace characters' },
  { k:'renderControlCharacters',cat:'indent',  type:'boolean', def:true,                                  desc:'Render control characters' },
  { k:'indentSize',             cat:'indent',  type:'string',  def:'tabSize',                             desc:'"tabSize" or a number of spaces' },
  { k:'useTabStops',            cat:'indent',  type:'boolean', def:true,                                  desc:'Insert/delete characters in tab stop positions' },

  // ── Word Wrap ─────────────────────────────────────────────────────
  { k:'wordWrap',               cat:'render',  type:'select',  def:'off',      opts:['off','on','wordWrapColumn','bounded'], desc:'Word wrap mode' },
  { k:'wordWrapColumn',         cat:'render',  type:'number',  def:80,         min:20, max:500, step:1,   desc:'Column to wrap at (wordWrapColumn/bounded mode)' },
  { k:'wrappingIndent',         cat:'render',  type:'select',  def:'same',     opts:['none','same','indent','deepIndent'], desc:'Indent wrapped lines' },
  { k:'wrappingStrategy',       cat:'render',  type:'select',  def:'simple',   opts:['simple','advanced'], desc:'Wrapping calculation algorithm' },
  { k:'wordWrapOverride1',      cat:'render',  type:'select',  def:'inherit',  opts:['off','on','inherit'], desc:'wordWrap override layer 1' },

  // ── Rendering ─────────────────────────────────────────────────────
  { k:'renderLineHighlight',    cat:'render',  type:'select',  def:'line',     opts:['none','gutter','line','all'], desc:'Highlight style for current line' },
  { k:'renderLineHighlightOnlyWhenFocus', cat:'render', type:'boolean', def:false,                         desc:'Only highlight current line when editor is focused' },
  { k:'lineNumbers',            cat:'render',  type:'select',  def:'on',       opts:['on','off','relative','interval'], desc:'Line number display style' },
  { k:'lineNumbersMinChars',    cat:'render',  type:'number',  def:5,          min:1,  max:10,  step:1,   desc:'Minimum characters reserved for line number gutter' },
  { k:'glyphMargin',            cat:'render',  type:'boolean', def:true,                                  desc:'Show glyph margin (breakpoint area)' },
  { k:'folding',                cat:'folding', type:'boolean', def:true,                                  desc:'Enable code folding' },
  { k:'foldingStrategy',        cat:'folding', type:'select',  def:'auto',     opts:['auto','indentation'], desc:'Code folding strategy' },
  { k:'foldingHighlight',       cat:'folding', type:'boolean', def:true,                                  desc:'Highlight folded regions' },
  { k:'foldingImportsByDefault',cat:'folding', type:'boolean', def:false,                                 desc:'Fold import blocks on file open' },
  { k:'showFoldingControls',    cat:'folding', type:'select',  def:'mouseover',opts:['always','never','mouseover'], desc:'When to show folding controls' },
  { k:'unfoldOnClickAfterEndOfLine', cat:'folding', type:'boolean', def:false,                            desc:'Unfold by clicking after the fold line' },
  { k:'bracketPairColorization',cat:'render',  type:'object',  def:{enabled:true,independentColorPoolPerBracketType:false}, jsonKey:'bracketPairColorization', desc:'Colorize matching bracket pairs' },
  { k:'matchBrackets',          cat:'render',  type:'select',  def:'always',   opts:['never','near','always'], desc:'When to highlight matching brackets' },
  { k:'selectionHighlight',     cat:'render',  type:'boolean', def:true,                                  desc:'Highlight all occurrences of the selection' },
  { k:'occurrencesHighlight',   cat:'render',  type:'select',  def:'singleFile',opts:['off','singleFile','multiFile'], desc:'Highlight symbol occurrences' },
  { k:'hideCursorInOverviewRuler', cat:'render', type:'boolean', def:false,                               desc:'Hide cursor indicator in overview ruler' },
  { k:'overviewRulerBorder',    cat:'render',  type:'boolean', def:true,                                  desc:'Show a border on the overview ruler' },
  { k:'overviewRulerLanes',     cat:'render',  type:'number',  def:3,          min:0,  max:3,   step:1,   desc:'Number of lanes in overview ruler (0–3)' },
  { k:'rulers',                 cat:'render',  type:'string',  def:'[]',                                  desc:'Column rulers as JSON array, e.g. [80, 120]' },
  { k:'wordSeparators',         cat:'render',  type:'string',  def:'`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?', desc:'Characters treated as word separators' },
  { k:'colorDecorators',        cat:'render',  type:'boolean', def:true,                                  desc:'Show inline color decorators (CSS color preview)' },
  { k:'colorDecoratorsLimit',   cat:'render',  type:'number',  def:500,        min:1,  max:5000,step:50,  desc:'Max color decorators per file' },
  { k:'unicodeHighlight',       cat:'render',  type:'object',  def:{ambiguousCharacters:true}, jsonKey:'unicodeHighlight', desc:'Highlight ambiguous/invisible unicode characters' },
  { k:'renderValidationDecorations', cat:'render', type:'select', def:'editable', opts:['editable','on','off'], desc:'When to render validation decorations (squiggles)' },
  { k:'showDeprecated',         cat:'render',  type:'boolean', def:true,                                  desc:'Strike through deprecated variables' },

  // ── Minimap ───────────────────────────────────────────────────────
  { k:'minimap',                cat:'minimap', type:'object',  def:{enabled:true,side:'right',size:'proportional',showSlider:'mouseover',renderCharacters:true,maxColumn:120,scale:1}, jsonKey:'minimap', desc:'Minimap configuration object' },

  // ── Suggest / IntelliSense ────────────────────────────────────────
  { k:'suggest',                cat:'suggest', type:'object',  def:{insertMode:'insert',filterGraceful:true,snippetsPreventQuickSuggestions:true,localityBonus:false,shareSuggestSelections:false,showIcons:true,showStatusBar:false,preview:false,previewMode:'subwordSmart',showInlineDetails:true,showMethods:true,showFunctions:true,showConstructors:true,showDeprecated:true,showFields:true,showVariables:true,showClasses:true,showStructs:true,showInterfaces:true,showModules:true,showProperties:true,showEvents:true,showOperators:true,showUnits:true,showValues:true,showConstants:true,showEnums:true,showEnumMembers:true,showKeywords:true,showWords:true,showColors:true,showFiles:true,showReferences:true,showFolders:true,showTypeParameters:true,showSnippets:true,showUsers:true,showIssues:true}, jsonKey:'suggest', desc:'IntelliSense suggest widget options' },
  { k:'quickSuggestions',       cat:'suggest', type:'object',  def:{other:'on',comments:'off',strings:'off'}, jsonKey:'quickSuggestions', desc:'Quick suggestions trigger mode per context' },
  { k:'quickSuggestionsDelay',  cat:'suggest', type:'number',  def:10,         min:0,  max:2000,step:10,  desc:'Delay in ms before quick suggestions appear' },
  { k:'acceptSuggestionOnEnter',cat:'suggest', type:'select',  def:'on',       opts:['on','smart','off'], desc:'Accept suggestion with Enter key' },
  { k:'acceptSuggestionOnCommitCharacter', cat:'suggest', type:'boolean', def:true,                      desc:'Accept suggestion when typing a commit character' },
  { k:'snippetSuggestions',     cat:'suggest', type:'select',  def:'inline',   opts:['top','bottom','inline','none'], desc:'Where to show snippet suggestions' },
  { k:'tabCompletion',          cat:'suggest', type:'select',  def:'off',      opts:['on','off','onlySnippets'], desc:'Tab completion mode' },
  { k:'suggestOnTriggerCharacters', cat:'suggest', type:'boolean', def:true,                             desc:'Open suggestions when typing trigger characters' },
  { k:'suggestSelection',       cat:'suggest', type:'select',  def:'first',    opts:['first','recentlyUsed','recentlyUsedByPrefix'], desc:'How to pre-select suggestions' },
  { k:'wordBasedSuggestions',   cat:'suggest', type:'select',  def:'matchingDocuments', opts:['off','currentDocument','matchingDocuments','allDocuments'], desc:'Word-based suggestions scope' },
  { k:'inlineSuggest',          cat:'suggest', type:'object',  def:{enabled:true,mode:'subwordSmart',showToolbar:'onHover',keepOnBlur:false}, jsonKey:'inlineSuggest', desc:'Inline (ghost-text) suggestions' },
  { k:'parameterHints',         cat:'suggest', type:'object',  def:{enabled:true,cycle:false}, jsonKey:'parameterHints', desc:'Show parameter hints (signature help)' },
  { k:'hover',                  cat:'suggest', type:'object',  def:{enabled:true,delay:300,sticky:true,hidingDelay:300,above:true}, jsonKey:'hover', desc:'Hover information popup configuration' },

  // ── Find ──────────────────────────────────────────────────────────
  { k:'find',                   cat:'find',    type:'object',  def:{cursorMoveOnType:true,seedSearchStringFromSelection:'always',autoFindInSelection:'never',addExtraSpaceOnTop:true,loop:true}, jsonKey:'find', desc:'Find widget configuration' },
  { k:'links',                  cat:'find',    type:'boolean', def:true,                                  desc:'Make URLs clickable in the editor' },

  // ── Code Actions & Editing ────────────────────────────────────────
  { k:'formatOnType',           cat:'other',   type:'boolean', def:false,                                 desc:'Auto-format the line after typing a trigger character' },
  { k:'formatOnPaste',          cat:'other',   type:'boolean', def:false,                                 desc:'Auto-format pasted content' },
  { k:'autoIndent',             cat:'indent',  type:'select',  def:'full',     opts:['none','keep','brackets','advanced','full'], desc:'Auto indent on newline' },
  { k:'autoClosingBrackets',    cat:'other',   type:'select',  def:'languageDefined', opts:['always','languageDefined','beforeWhitespace','never'], desc:'Auto close brackets' },
  { k:'autoClosingComments',    cat:'other',   type:'select',  def:'languageDefined', opts:['always','languageDefined','never'], desc:'Auto close comments' },
  { k:'autoClosingDelete',      cat:'other',   type:'select',  def:'auto',     opts:['always','auto','never'], desc:'Auto delete closing character when deleting opening char' },
  { k:'autoClosingOvertype',    cat:'other',   type:'select',  def:'auto',     opts:['always','auto','never'], desc:'Overtype closing brackets instead of inserting' },
  { k:'autoSurround',           cat:'other',   type:'select',  def:'languageDefined', opts:['languageDefined','quotes','brackets','never'], desc:'Auto surround selection' },
  { k:'bracketPairGuides',      cat:'indent',  type:'object',  def:{active:'true',background:'true',indentation:'true',highlightActive:true,highlightActiveBracketPair:true}, jsonKey:'bracketPairGuides', desc:'Bracket pair indent guides' },
  { k:'guides',                 cat:'indent',  type:'object',  def:{bracketPairs:false,bracketPairsHorizontal:'active',highlightActiveBracketPair:true,indentation:true,highlightActiveIndentation:true}, jsonKey:'guides', desc:'Guide lines for indentation and bracket pairs' },
  { k:'definitionLinkOpensInPeek', cat:'other', type:'boolean', def:false,                               desc:'Ctrl+Click definition opens in peek view' },
  { k:'gotoLocation',           cat:'other',   type:'object',  def:{multiple:'peek',multipleDefinitions:'peek',multipleTypeDefinitions:'peek',multipleDeclarations:'peek',multipleImplementations:'peek',multipleReferences:'peek',alternativeDefinitionCommand:'editor.action.goToReferences',alternativeTypeDefinitionCommand:'editor.action.goToReferences',alternativeDeclarationCommand:'editor.action.goToReferences',alternativeImplementationCommand:'editor.action.goToReferences',alternativeReferenceCommand:''}, jsonKey:'gotoLocation', desc:'Go-to definition behavior' },
  { k:'codeLens',               cat:'other',   type:'boolean', def:true,                                 desc:'Show code lens annotations above definitions' },
  { k:'codeLensFontFamily',     cat:'other',   type:'string',  def:'',                                   desc:'Font for code lens (empty = inherit editor font)' },
  { k:'codeLensFontSize',       cat:'other',   type:'number',  def:0,          min:0,  max:40,  step:1,  desc:'Font size for code lens (0 = auto)' },
  { k:'lightbulb',              cat:'other',   type:'object',  def:{enabled:'onCode'}, jsonKey:'lightbulb', desc:'Lightbulb code action widget' },
  { k:'inlayHints',             cat:'other',   type:'object',  def:{enabled:'on',fontSize:0,fontFamily:'',padding:false}, jsonKey:'inlayHints', desc:'Inlay hints (type annotations, param names)' },
  { k:'codeActionsOnSaveTimeout', cat:'other', type:'number',  def:750,        min:100,max:5000,step:50, desc:'Timeout in ms for code actions on save' },
  { k:'renameOnType',           cat:'other',   type:'boolean', def:false,                                desc:'Rename symbol as you type (experimental)' },

  // ── Performance ───────────────────────────────────────────────────
  { k:'maxTokenizationLineLength', cat:'perf', type:'number',  def:20000,      min:100,max:100000,step:1000, desc:'Lines longer than this are not tokenized (perf)' },
  { k:'stopRenderingLineAfter', cat:'perf',    type:'number',  def:10000,      min:100,max:100000,step:1000, desc:'Stop rendering a line after this many characters' },
  { k:'largeFileOptimizations', cat:'perf',    type:'boolean', def:true,                                  desc:'Special optimizations for large files' },
  { k:'accessibilityPageSize',  cat:'perf',    type:'number',  def:10,         min:1,  max:500,  step:1,   desc:'Number of lines in the accessibility model page' },

  // ── Other ──────────────────────────────────────────────────────────
  { k:'readOnly',               cat:'other',   type:'boolean', def:false,                                 desc:'Make editor read-only' },
  { k:'readOnlyMessage',        cat:'other',   type:'object',  def:{value:''}, jsonKey:'readOnlyMessage', desc:'Message shown when editor is read-only' },
  { k:'domReadOnly',            cat:'other',   type:'boolean', def:false,                                 desc:'Make editor DOM read-only (no IME, clipboard)' },
  { k:'dragAndDrop',            cat:'other',   type:'boolean', def:true,                                  desc:'Drag and drop text in the editor' },
  { k:'emptySelectionClipboard',cat:'other',   type:'boolean', def:true,                                  desc:'Copy entire line when nothing is selected' },
  { k:'copyWithSyntaxHighlighting', cat:'other', type:'boolean', def:true,                                desc:'Copy with syntax highlighting (rich clipboard)' },
  { k:'columnSelection',        cat:'other',   type:'boolean', def:false,                                 desc:'Enable column selection mode' },
  { k:'autoDetectHighContrast', cat:'other',   type:'boolean', def:true,                                  desc:'Auto switch to high contrast when OS uses it' },
  { k:'mouseStyle',             cat:'cursor',  type:'select',  def:'text',     opts:['text','default','copy'], desc:'Mouse cursor style over editor' },
  { k:'selectOnLineNumbers',    cat:'render',  type:'boolean', def:true,                                  desc:'Select line by clicking on its number' },
  { k:'lineDecorationsWidth',   cat:'render',  type:'number',  def:10,         min:0,  max:50,  step:1,   desc:'Width of the line decorations gutter in px' },
  { k:'revealHorizontalRightPadding', cat:'scroll', type:'number', def:30,     min:0,  max:200, step:5,   desc:'Padding on the right when revealing cursor horizontally' },
  { k:'extraEditorClassName',   cat:'other',   type:'string',  def:'',                                   desc:'Extra CSS class name added to the editor' },
  { k:'showUnused',             cat:'render',  type:'boolean', def:true,                                  desc:'Fade out unused code / imports' },
  { k:'scrollbar',              cat:'scroll',  type:'object',  def:{vertical:'auto',horizontal:'auto',useShadows:true,verticalHasArrows:false,horizontalHasArrows:false,arrowSize:11,scrollByPage:false,verticalScrollbarSize:14,horizontalScrollbarSize:12}, jsonKey:'scrollbar', desc:'Scrollbar configuration' },
  { k:'experimentalWhitespaceRendering', cat:'render', type:'select', def:'svg', opts:['svg','canvas','off'], desc:'Whitespace rendering implementation' },
];

// Store for user overrides
let _advConfig = {};
let _advShowModifiedOnly = false;
let _advBuilt = false;

function advBuildPanel() {
  // Only build once; subsequent opens just refresh values
  const container = document.getElementById('adv-options-list');
  if (!container) return;

  // Merge any previously set values from monacoEditor
  if (window.monacoEditor) {
    try {
      const opts = monacoEditor.getOptions();
      // We'll read live values via getOption when rendering
    } catch(e) {}
  }

  // Build rows
  container.innerHTML = '';
  for (const schema of ADV_SCHEMA) {
    container.appendChild(_advMakeRow(schema));
  }
  _advBuilt = true;
  advFilter('');
  advUpdateCount();
}

function _advGetLiveValue(schema) {
  // Try to get current value from Monaco
  if (window.monacoEditor) {
    try {
      const EditorOption = monaco.editor.EditorOption;
      // Map key name to option enum
      const enumKey = Object.keys(EditorOption).find(k => k === schema.k || k.toLowerCase() === schema.k.toLowerCase());
      if (enumKey !== undefined) {
        const val = monacoEditor.getOption(EditorOption[enumKey]);
        return val;
      }
    } catch(e) {}
  }
  // Fall back to _advConfig override or schema default
  return _advConfig.hasOwnProperty(schema.k) ? _advConfig[schema.k] : schema.def;
}

function _advIsModified(schema) {
  return _advConfig.hasOwnProperty(schema.k);
}

function _advMakeRow(schema) {
  const row = document.createElement('div');
  row.className = 'adv-row' + (_advIsModified(schema) ? ' adv-modified' : '');
  row.dataset.key = schema.k;
  row.dataset.cat = schema.cat;
  row.dataset.desc = (schema.desc || '').toLowerCase();

  // Dot indicator
  const dot = document.createElement('div');
  dot.className = 'adv-modified-dot';
  dot.style.opacity = _advIsModified(schema) ? '1' : '0';
  dot.title = 'Modified from default';

  // Key + desc
  const keyDiv = document.createElement('div');
  keyDiv.className = 'adv-key';
  const catBadge = `<span class="adv-key-cat">${schema.cat}</span>`;
  keyDiv.innerHTML = `<div class="adv-key-name">${schema.k}${catBadge}</div><div class="adv-key-desc">${schema.desc || ''}</div>`;

  // Value control
  const valWrap = document.createElement('div');
  valWrap.className = 'adv-val-wrap';
  const ctrl = _advMakeControl(schema);
  valWrap.appendChild(ctrl);

  // Reset button
  const resetBtn = document.createElement('button');
  resetBtn.className = 'adv-reset-btn';
  resetBtn.title = 'Reset to default';
  resetBtn.textContent = '↺';
  resetBtn.onclick = () => advResetKey(schema.k);

  row.appendChild(dot);
  row.appendChild(keyDiv);
  row.appendChild(valWrap);
  row.appendChild(resetBtn);
  return row;
}

function _advMakeControl(schema) {
  const liveVal = _advGetLiveValue(schema);

  if (schema.type === 'boolean') {
    const wrap = document.createElement('div');
    wrap.className = 'adv-bool';
    const btn = document.createElement('div');
    btn.className = 'adv-bool-btn' + (liveVal ? ' on' : '');
    btn.dataset.key = schema.k;
    btn.title = liveVal ? 'true' : 'false';
    btn.onclick = function() {
      const newVal = !this.classList.contains('on');
      this.classList.toggle('on', newVal);
      this.title = newVal ? 'true' : 'false';
      advApplyOption(schema.k, newVal);
      _advMarkModified(schema.k, newVal !== schema.def);
    };
    const label = document.createElement('span');
    label.style.cssText = 'font-size:10px;color:var(--text-dim);min-width:32px';
    label.textContent = liveVal ? 'true' : 'false';
    btn.addEventListener('click', () => { label.textContent = btn.classList.contains('on') ? 'true' : 'false'; }, true);
    wrap.appendChild(btn);
    wrap.appendChild(label);
    return wrap;
  }

  if (schema.type === 'number') {
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.className = 'adv-num';
    inp.value = typeof liveVal === 'number' ? liveVal : schema.def;
    if (schema.min !== undefined) inp.min = schema.min;
    if (schema.max !== undefined) inp.max = schema.max;
    if (schema.step !== undefined) inp.step = schema.step;
    inp.dataset.key = schema.k;
    inp.oninput = function() {
      const v = parseFloat(this.value);
      if (!isNaN(v)) {
        advApplyOption(schema.k, v);
        _advMarkModified(schema.k, v !== schema.def);
      }
    };
    return inp;
  }

  if (schema.type === 'select') {
    const sel = document.createElement('select');
    sel.className = 'adv-sel';
    sel.dataset.key = schema.k;
    const curStr = typeof liveVal === 'object' ? JSON.stringify(liveVal) : String(liveVal);
    (schema.opts || []).forEach(opt => {
      const o = document.createElement('option');
      o.value = opt;
      o.textContent = opt;
      if (String(opt) === curStr || opt === liveVal) o.selected = true;
      sel.appendChild(o);
    });
    sel.onchange = function() {
      advApplyOption(schema.k, this.value);
      _advMarkModified(schema.k, this.value !== String(schema.def));
    };
    return sel;
  }

  if (schema.type === 'object') {
    // Render as a compact JSON textarea
    const wrap = document.createElement('div');
    wrap.style.cssText = 'width:100%;display:flex;flex-direction:column;gap:3px';
    const valStr = (() => {
      try { return JSON.stringify(typeof liveVal === 'object' ? liveVal : schema.def, null, 0); }
      catch(e) { return JSON.stringify(schema.def, null, 0); }
    })();
    const ta = document.createElement('textarea');
    ta.value = valStr;
    ta.rows = 2;
    ta.spellcheck = false;
    ta.style.cssText = 'width:100%;background:var(--bg0);border:1px solid var(--border2);color:var(--text);font-family:"JetBrains Mono",monospace;font-size:10px;padding:4px 6px;border-radius:3px;outline:none;resize:vertical;min-height:36px;max-height:100px;line-height:1.4;tab-size:2';
    ta.dataset.key = schema.k;
    const errSpan = document.createElement('span');
    errSpan.style.cssText = 'font-size:9px;color:var(--red);min-height:12px;font-family:"JetBrains Mono",monospace';
    ta.addEventListener('focus', () => { ta.style.borderColor = 'var(--accent)'; });
    ta.addEventListener('blur', () => { ta.style.borderColor = 'var(--border2)'; });
    ta.oninput = function() {
      try {
        const parsed = JSON.parse(this.value);
        errSpan.textContent = '';
        advApplyOption(schema.k, parsed);
        _advMarkModified(schema.k, JSON.stringify(parsed) !== JSON.stringify(schema.def));
      } catch(e) {
        errSpan.textContent = '✕ ' + e.message;
      }
    };
    wrap.appendChild(ta);
    wrap.appendChild(errSpan);
    return wrap;
  }

  // String fallback
  const inp = document.createElement('input');
  inp.type = 'text';
  inp.className = 'adv-str';
  inp.value = typeof liveVal === 'string' ? liveVal : String(schema.def);
  inp.dataset.key = schema.k;
  inp.oninput = function() {
    // Try to parse as JSON for things like rulers: [80, 120]
    let parsed = this.value;
    try { parsed = JSON.parse(this.value); } catch(e) {}
    advApplyOption(schema.k, parsed);
    _advMarkModified(schema.k, this.value !== String(schema.def));
  };
  return inp;
}

function _advMarkModified(key, isModified) {
  const row = document.querySelector(`.adv-row[data-key="${key}"]`);
  if (!row) return;
  const dot = row.querySelector('.adv-modified-dot');
  row.classList.toggle('adv-modified', isModified);
  if (dot) dot.style.opacity = isModified ? '1' : '0';
  advUpdateCount();
}

function advApplyOption(key, value) {
  //if (!window.monacoEditor) { termLog('warn', 'Editor not ready.'); return; } : this cuases settings to not be ajustable from menus
  try {
    monacoEditor.updateOptions({ [key]: value });
    _advConfig[key] = value;
    // Persist advanced config
    try { localStorage.setItem('void-adv-config', JSON.stringify(_advConfig)); } catch(e) {}
    termLog('sys', `monaco.${key} = ${JSON.stringify(value)}`);
  } catch(e) {
    termLog('error', `monaco.${key}: ${e.message}`);
  }
}

function advResetKey(key) {
  const schema = ADV_SCHEMA.find(s => s.k === key);
  if (!schema) return;
  delete _advConfig[key];
  // Re-apply default
  if (window.monacoEditor) {
    try { monacoEditor.updateOptions({ [key]: schema.def }); } catch(e) {}
  }
  // Rebuild just this row
  const row = document.querySelector(`.adv-row[data-key="${key}"]`);
  if (row) {
    const newRow = _advMakeRow(schema);
    row.parentNode.replaceChild(newRow, row);
    // Re-apply filter
    const filterVal = document.getElementById('adv-search')?.value || '';
    const catVal = document.getElementById('adv-category-filter')?.value || '';
    _advFilterRow(newRow, filterVal.toLowerCase(), catVal);
  }
  try { localStorage.setItem('void-adv-config', JSON.stringify(_advConfig)); } catch(e) {}
  advUpdateCount();
  termLog('sys', `monaco.${key} reset to default`);
}

function advResetAll() {
  showConfirm('Reset all advanced Monaco options to defaults?', 'This cannot be undone.', () => {
    const keys = Object.keys(_advConfig);
    _advConfig = {};
    if (window.monacoEditor) {
      const resetOpts = {};
      for (const schema of ADV_SCHEMA) {
        resetOpts[schema.k] = schema.def;
      }
      try { monacoEditor.updateOptions(resetOpts); } catch(e) {}
    }
    try { localStorage.removeItem('void-adv-config'); } catch(e) {}
    // Rebuild panel
    _advBuilt = false;
    advBuildPanel();
    termLog('sys', `Reset ${keys.length} advanced Monaco option(s) to defaults.`);
  });
}

function advFilter(searchVal) {
  const search = (searchVal || '').toLowerCase().trim();
  const cat = document.getElementById('adv-category-filter')?.value || '';
  const rows = document.querySelectorAll('.adv-row');
  let visible = 0;
  rows.forEach(row => {
    const show = _advFilterRow(row, search, cat);
    if (show) visible++;
  });
  document.getElementById('adv-no-results').style.display = visible === 0 ? 'block' : 'none';
  advUpdateCount(visible, rows.length);
}

function _advFilterRow(row, search, cat) {
  const key = row.dataset.key || '';
  const rowCat = row.dataset.cat || '';
  const desc = row.dataset.desc || '';
  const matchSearch = !search || key.toLowerCase().includes(search) || desc.includes(search);
  const matchCat = !cat || rowCat === cat;
  const matchModified = !_advShowModifiedOnly || row.classList.contains('adv-modified');
  const show = matchSearch && matchCat && matchModified;
  row.classList.toggle('adv-hidden', !show);
  return show;
}

function advShowOnlyModified() {
  _advShowModifiedOnly = !_advShowModifiedOnly;
  const btn = document.getElementById('adv-btn-modified');
  if (btn) {
    btn.style.color = _advShowModifiedOnly ? 'var(--yellow)' : 'var(--text-dim)';
    btn.style.borderColor = _advShowModifiedOnly ? 'rgba(240,192,64,0.4)' : 'var(--border2)';
    btn.style.background = _advShowModifiedOnly ? 'rgba(240,192,64,0.1)' : 'var(--bg0)';
  }
  advFilter(document.getElementById('adv-search')?.value || '');
}

function advUpdateCount(visible, total) {
  const el = document.getElementById('adv-count');
  if (!el) return;
  const modCount = Object.keys(_advConfig).length;
  const totalCount = total !== undefined ? total : ADV_SCHEMA.length;
  const visCount = visible !== undefined ? visible : ADV_SCHEMA.length;
  el.textContent = `${visCount}/${totalCount} options • ${modCount} modified`;
}

function advExportJSON() {
  // Collect all current non-default values
  const out = {};
  for (const schema of ADV_SCHEMA) {
    if (_advConfig.hasOwnProperty(schema.k)) {
      out[schema.k] = _advConfig[schema.k];
    }
  }
  const json = JSON.stringify(out, null, 2);
  // Save to VFS
  const filename = '/monaco-config.json';
  fsWriteFileSafe(filename, json).then(() => {
    termLog('sys', 'Exported Monaco config to ' + filename);
    openFile(filename);
  }).catch(e => termLog('error', 'Export failed: ' + e.message));
}

function advImportJSON() {
  showDialog('Paste Monaco config JSON', '{}', 'Import', (raw) => {
    try {
      const parsed = JSON.parse(raw);
      let count = 0;
      for (const [key, value] of Object.entries(parsed)) {
        const schema = ADV_SCHEMA.find(s => s.k === key);
        if (schema) {
          advApplyOption(key, value);
          count++;
        }
      }
      _advBuilt = false;
      advBuildPanel();
      termLog('sys', `Imported ${count} Monaco option(s).`);
    } catch(e) {
      termLog('error', 'JSON parse error: ' + e.message);
    }
  });
}

function advCopyJSON() {
  const out = {};
  for (const schema of ADV_SCHEMA) {
    if (_advConfig.hasOwnProperty(schema.k)) out[schema.k] = _advConfig[schema.k];
  }
  const json = JSON.stringify(out, null, 2);
  navigator.clipboard.writeText(json).then(() => {
    termLog('sys', 'Monaco config copied to clipboard.');
  }).catch(() => {
    // Fallback: show in dialog
    showDialog('Monaco Config JSON (copy manually)', json, 'OK', ()=>{});
  });
}

// Load persisted advanced config
function advLoadSaved() {
  try {
    const saved = localStorage.getItem('void-adv-config');
    if (saved) {
      _advConfig = JSON.parse(saved);
      // Apply to Monaco when it's ready
      if (window.monacoEditor && Object.keys(_advConfig).length) {
        try { monacoEditor.updateOptions(_advConfig); } catch(e) {}
      }
    }
  } catch(e) {}
}


function resetSettings() {
  showConfirm('Reset all settings to defaults?', 'This will reload editor options.', () => {
    ideSettings = { ...DEFAULT_SETTINGS };
    saveSettings();
    applyAllSettings();
    closeSettings();
    termLog('sys', 'Settings reset to defaults.');
  });
}

function renderKeybindList() {
  const binds = [
    ['Ctrl+Enter',       'Run current file'],
    ['Ctrl+Shift+Enter', 'Run index.html'],
    ['Ctrl+Shift+R',     'Run with Fetch Preloader'],
    ['Ctrl+S',           'Save current file'],
    ['Ctrl+Shift+S',     'Save all files'],
    ['Ctrl+N',           'New file'],
    ['Ctrl+B',           'Toggle sidebar'],
    ['Ctrl+`',           'Toggle panel'],
    ['Ctrl+W',           'Close active tab'],
    ['Ctrl+0',           'Reset font size'],
    ['Ctrl+=',           'Increase editor font size'],
    ['Ctrl+-',           'Decrease editor font size'],
    ['Ctrl+Shift+=',     'Increase UI font size'],
    ['Ctrl+Shift+-',     'Decrease UI font size'],
    ['Ctrl+Shift+O',     'Import ZIP'],
    ['Ctrl+Shift+E',     'Export ZIP'],
    ['Ctrl+Shift+B',     'Export Bundled HTML (Webpack)'],
    ['Ctrl+/',           'Toggle comment (Monaco)'],
    ['Ctrl+H',           'Find & Replace'],
    ['Ctrl+G',           'Go to line'],
    ['Shift+Alt+F',      'Format document'],
    ['Alt+Z',            'Toggle word wrap'],
    ['Alt+↑',            'Move lines up'],
    ['Alt+↓',            'Move lines down'],
  ];
  document.getElementById('keybind-list').innerHTML = binds.map(([k, d]) => `
    <div class="set-row">
      <div class="set-label"><div class="set-label-title">${d}</div></div>
      <div class="set-control"><span style="background:var(--bg0);border:1px solid var(--border2);padding:2px 8px;border-radius:3px;font-size:10px;color:var(--accent);white-space:nowrap">${k}</span></div>
    </div>`).join('');
}

// close settings on overlay click
document.getElementById('settings-overlay').addEventListener('click', e => {
  if (e.target === document.getElementById('settings-overlay')) closeSettings();
});


// ═══════════════════════════════════════════════════════════════════
//  MONACO EDITOR — ALL INTERACTIONS (v0.21 final)
//  applyEditorOption() — immediate live update without full reload
//  runEditorAction()   — safe action runner with focus + fallback
// ═══════════════════════════════════════════════════════════════════

function applyEditorOption(opt) {
  if (window.monacoEditor) monacoEditor.updateOptions(opt);
}

function runEditorAction(actionId, fallbackFn) {
  //if (!window.monacoEditor) { termLog('warn', 'Editor not ready.'); return; }
  monacoEditor.focus();
  const action = monacoEditor.getAction(actionId);
  if (action) {
    Promise.resolve(action.run()).catch(e => termLog('warn', 'Action failed: ' + e.message));
  } else if (typeof fallbackFn === 'function') {
    fallbackFn();
  } else {
    termLog('warn', 'Editor action not available: ' + actionId);
  }
}

// ── Font size (editor) ────────────────────────────────────────────
function increaseFontSize() {
  ideSettings.fontSize = Math.min((ideSettings.fontSize || 13) + 1, 28);
  applyEditorOption({ fontSize: ideSettings.fontSize });
  _syncSettingSlider('set-font-size', 'set-font-size-val', ideSettings.fontSize, 'px');
  saveSettings();
  termLog('sys', 'Editor font size: ' + ideSettings.fontSize + 'px');
}
function decreaseFontSize() {
  ideSettings.fontSize = Math.max((ideSettings.fontSize || 13) - 1, 8);
  applyEditorOption({ fontSize: ideSettings.fontSize });
  _syncSettingSlider('set-font-size', 'set-font-size-val', ideSettings.fontSize, 'px');
  saveSettings();
  termLog('sys', 'Editor font size: ' + ideSettings.fontSize + 'px');
}
function resetFontSize() {
  ideSettings.fontSize = DEFAULT_SETTINGS.fontSize;
  applyEditorOption({ fontSize: ideSettings.fontSize });
  _syncSettingSlider('set-font-size', 'set-font-size-val', ideSettings.fontSize, 'px');
  saveSettings();
  termLog('sys', 'Font size reset to ' + ideSettings.fontSize + 'px');
}

// ── UI font size ──────────────────────────────────────────────────
function increaseUIFontSize() {
  ideSettings.uiFontSize = Math.min((ideSettings.uiFontSize || 13) + 1, 20);
  document.documentElement.style.fontSize = ideSettings.uiFontSize + 'px';
  _syncSettingSlider('set-ui-font', 'set-ui-font-val', ideSettings.uiFontSize, 'px');
  saveSettings();
  termLog('sys', 'UI font size: ' + ideSettings.uiFontSize + 'px');
}
function decreaseUIFontSize() {
  ideSettings.uiFontSize = Math.max((ideSettings.uiFontSize || 13) - 1, 9);
  document.documentElement.style.fontSize = ideSettings.uiFontSize + 'px';
  _syncSettingSlider('set-ui-font', 'set-ui-font-val', ideSettings.uiFontSize, 'px');
  saveSettings();
  termLog('sys', 'UI font size: ' + ideSettings.uiFontSize + 'px');
}

// Helper: sync a slider + label to a value
function _syncSettingSlider(sliderId, labelId, value, suffix) {
  const sl = document.getElementById(sliderId);
  const lb = document.getElementById(labelId);
  if (sl) sl.value = value;
  if (lb) lb.textContent = value + (suffix || '');
}

// ── Page zoom ─────────────────────────────────────────────────────
let _pageZoom = 1;
function zoomIn()    { _pageZoom = Math.min(_pageZoom + 0.1, 2.0); document.documentElement.style.zoom = _pageZoom; if (window.monacoEditor) monacoEditor.layout(); termLog('sys', 'Zoom: ' + Math.round(_pageZoom*100) + '%'); }
function zoomOut()   { _pageZoom = Math.max(_pageZoom - 0.1, 0.5); document.documentElement.style.zoom = _pageZoom; if (window.monacoEditor) monacoEditor.layout(); termLog('sys', 'Zoom: ' + Math.round(_pageZoom*100) + '%'); }
function zoomReset() { _pageZoom = 1; document.documentElement.style.zoom = 1; if (window.monacoEditor) monacoEditor.layout(); termLog('sys', 'Zoom: 100%'); }

// ── Word wrap ─────────────────────────────────────────────────────
function toggleWordWrap() {
  ideSettings.wordWrap = !ideSettings.wordWrap;
  applyEditorOption({ wordWrap: ideSettings.wordWrap ? 'on' : 'off' });
  const el = document.getElementById('set-word-wrap');
  if (el) el.classList.toggle('on', ideSettings.wordWrap);
  saveSettings();
  termLog('sys', 'Word wrap: ' + (ideSettings.wordWrap ? 'ON' : 'OFF'));
}

// ── Minimap ───────────────────────────────────────────────────────
function toggleMinimap() {
  ideSettings.minimap = !ideSettings.minimap;
  applyEditorOption({ minimap: { enabled: ideSettings.minimap } });
  const el = document.getElementById('set-minimap');
  if (el) el.classList.toggle('on', ideSettings.minimap);
  saveSettings();
  termLog('sys', 'Minimap: ' + (ideSettings.minimap ? 'ON' : 'OFF'));
}

// ── Line numbers ──────────────────────────────────────────────────
function toggleLineNumbers() {
  ideSettings.lineNumbers = !ideSettings.lineNumbers;
  applyEditorOption({ lineNumbers: ideSettings.lineNumbers ? 'on' : 'off' });
  const el = document.getElementById('set-line-numbers');
  if (el) el.classList.toggle('on', ideSettings.lineNumbers);
  saveSettings();
  termLog('sys', 'Line numbers: ' + (ideSettings.lineNumbers ? 'ON' : 'OFF'));
}

// ── Breadcrumbs ───────────────────────────────────────────────────
let _breadcrumbsOn = false;
function toggleBreadcrumbs() {
  _breadcrumbsOn = !_breadcrumbsOn;
  applyEditorOption({ breadcrumbs: { enabled: _breadcrumbsOn } });
  termLog('sys', 'Breadcrumbs: ' + (_breadcrumbsOn ? 'ON' : 'OFF'));
}

// ── Format / comment / duplicate ─────────────────────────────────
function formatCode() {
  runEditorAction('editor.action.formatDocument');
}
function commentLine() {
  // Try line comment first, fall back to block comment
  runEditorAction('editor.action.commentLine', () => {
    runEditorAction('editor.action.blockComment');
  });
}
function duplicateLine() {
  runEditorAction('editor.action.copyLinesDownAction');
}

// ── Move lines ────────────────────────────────────────────────────
function moveLinesUp() {
  runEditorAction('editor.action.moveLinesUpAction');
}
function moveLinesDown() {
  runEditorAction('editor.action.moveLinesDownAction');
}

// ── Find & Replace ────────────────────────────────────────────────
function findReplace() {
 // if (!window.monacoEditor) { termLog('warn', 'Editor not ready.'); return; }
  monacoEditor.focus();
  // startFindReplaceAction is the correct action ID in Monaco 0.44
  runEditorAction('editor.action.startFindReplaceAction', () => {
    // Fallback: just open find
    runEditorAction('actions.find');
  });
}

// ── Go to Line ────────────────────────────────────────────────────
function goToLine() {
  //if (!window.monacoEditor) { termLog('warn', 'Editor not ready.'); return; }
  monacoEditor.focus();
  runEditorAction('editor.action.gotoLine');
}

// ── Go to Symbol ──────────────────────────────────────────────────
function goToSymbol() {
  //if (!window.monacoEditor) { termLog('warn', 'Editor not ready.'); return; }
  monacoEditor.focus();
  runEditorAction('editor.action.quickOutline', () => {
    termLog('info', 'Symbol search not available. Try Ctrl+Shift+O in the editor.');
  });
}

// ── Sort Lines ────────────────────────────────────────────────────
function sortLinesAsc() {
  if (!window.monacoEditor) return;
  const model = monacoEditor.getModel();
  if (!model) return;
  const sel = monacoEditor.getSelection();
  const hasSelection = sel && !sel.isEmpty();
  const startLine = hasSelection ? sel.startLineNumber : 1;
  const endLine   = hasSelection ? sel.endLineNumber   : model.getLineCount();
  const lines = [];
  for (let i = startLine; i <= endLine; i++) lines.push(model.getLineContent(i));
  const sorted = [...lines].sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
  const range = new monaco.Range(startLine, 1, endLine, model.getLineMaxColumn(endLine));
  monacoEditor.pushUndoStop();
  monacoEditor.executeEdits('sortLines', [{ range, text: sorted.join('\n') }]);
  monacoEditor.pushUndoStop();
  termLog('sys', 'Sorted ' + lines.length + ' lines ascending.');
}

function sortLinesDesc() {
  if (!window.monacoEditor) return;
  const model = monacoEditor.getModel();
  if (!model) return;
  const sel = monacoEditor.getSelection();
  const hasSelection = sel && !sel.isEmpty();
  const startLine = hasSelection ? sel.startLineNumber : 1;
  const endLine   = hasSelection ? sel.endLineNumber   : model.getLineCount();
  const lines = [];
  for (let i = startLine; i <= endLine; i++) lines.push(model.getLineContent(i));
  const sorted = [...lines].sort((a, b) => b.localeCompare(a, undefined, { sensitivity: 'base' }));
  const range = new monaco.Range(startLine, 1, endLine, model.getLineMaxColumn(endLine));
  monacoEditor.pushUndoStop();
  monacoEditor.executeEdits('sortLines', [{ range, text: sorted.join('\n') }]);
  monacoEditor.pushUndoStop();
  termLog('sys', 'Sorted ' + lines.length + ' lines descending.');
}

// ── Trim Trailing Whitespace ──────────────────────────────────────
function trimTrailingWhitespace() {
  if (!window.monacoEditor) return;
  const action = monacoEditor.getAction('editor.action.trimTrailingWhitespace');
  if (action) {
    Promise.resolve(action.run()).then(() => termLog('sys', 'Trimmed trailing whitespace.'));
    return;
  }
  // Manual fallback
  const model = monacoEditor.getModel();
  if (!model) return;
  const edits = [];
  for (let i = 1; i <= model.getLineCount(); i++) {
    const line = model.getLineContent(i);
    const trimmed = line.replace(/[\t ]+$/, '');
    if (trimmed !== line) {
      edits.push({ range: new monaco.Range(i, trimmed.length + 1, i, line.length + 1), text: '' });
    }
  }
  if (edits.length) {
    monacoEditor.pushUndoStop();
    monacoEditor.executeEdits('trimWhitespace', edits);
    monacoEditor.pushUndoStop();
    termLog('sys', 'Trimmed trailing whitespace from ' + edits.length + ' line(s).');
  } else {
    termLog('sys', 'No trailing whitespace found.');
  }
}

// ── File Info ─────────────────────────────────────────────────────
async function showFileInfo() {
  if (!activeTab) { termLog('warn', 'No file open.'); return; }
  try {
    const tab = openTabs.find(t => t.path === activeTab);
    const content = tab ? tab.model.getValue() : await fsReadFile(activeTab);
    const bytes = new TextEncoder().encode(content).length;
    const lineCount = content.split('\n').length;
    const words = content.trim() ? content.trim().split(/\s+/).length : 0;
    const chars = content.length;
    const ext = activeTab.split('.').pop();
    switchPanelTab('terminal');
    termLog('info', '━━ File Stats: ' + activeTab);
    termLog('info', '   Lines: ' + lineCount + '  |  Words: ' + words + '  |  Chars: ' + chars + '  |  Bytes: ' + bytes);
    termLog('info', '   Type: .' + ext + '  |  Encoding: ' + _currentEncoding);
  } catch(e) { termLog('error', 'File info error: ' + e.message); }
}

// ── Run in New Window ─────────────────────────────────────────────
async function runInNewWindow() {
  await saveCurrentFile();
  if (!activeTab) { termLog('warn', 'No file open.'); return; }
  const ext = activeTab.split('.').pop().toLowerCase();
  if (ext !== 'html' && ext !== 'htm') { termLog('warn', 'Run in New Window requires an HTML file.'); return; }
  try {
    const strippedPath = activeTab.replace(/^\/+/, '');
    const srcEntry = sharedMapLookup(strippedPath);
    let html = srcEntry ? await (await srcEntry.handle.getFile()).text() : await fsReadFile(activeTab);
    const htmlVPath = sharedFileMap.size > 0 ? findHtmlVPath(activeTab) : strippedPath;
    html = await fullyInlineHTML(html, htmlVPath);
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const w = window.open(url, '_blank', 'width=1024,height=768,toolbar=1,menubar=0,resizable=1');
    if (!w) termLog('warn', 'Popup blocked — allow popups and try again.');
    else termLog('info', 'Opened in new window ✓');
    setTimeout(() => URL.revokeObjectURL(url), 60000);
  } catch(e) { termLog('error', 'Run in New Window failed: ' + e.message); }
}

// ── Clear Preview ─────────────────────────────────────────────────
function clearPreview() {
  const frame = document.getElementById('preview-frame');
  if (frame) { frame.srcdoc = ''; frame.src = 'about:blank'; }
  termLog('sys', 'Preview cleared.');
}

// ── Encoding ──────────────────────────────────────────────────────
let _currentEncoding = 'UTF-8';
let _encodingPopupOpen = false;

function showEncodingPicker() {
  const popup = document.getElementById('sb-encoding-popup');
  if (!popup) return;
  _encodingPopupOpen = !_encodingPopupOpen;
  popup.style.display = _encodingPopupOpen ? 'block' : 'none';
  // Mark active encoding
  popup.querySelectorAll('[data-enc]').forEach(el => {
    el.classList.toggle('active', el.dataset.enc === _currentEncoding);
  });
}

function setFileEncoding(e, encoding) {
  if (e && e.stopPropagation) e.stopPropagation();
  _currentEncoding = encoding;
  const lbl = document.getElementById('sb-encoding-label');
  if (lbl) lbl.textContent = encoding;
  const popup = document.getElementById('sb-encoding-popup');
  if (popup) {
    popup.style.display = 'none';
    popup.querySelectorAll('[data-enc]').forEach(el => el.classList.toggle('active', el.dataset.enc === encoding));
  }
  _encodingPopupOpen = false;
  termLog('sys', 'Encoding: ' + encoding + ' (applies on next save/export)');
}

async function convertEncoding() {
  if (!activeTab) { termLog('warn', 'No file open.'); return; }
  showDialog('Convert to Encoding', _currentEncoding, 'Convert', async (targetEnc) => {
    const enc = targetEnc.trim().toUpperCase() || 'UTF-8';
    setFileEncoding(null, enc);
    await saveCurrentFile();
    termLog('sys', 'File saved with encoding declaration: ' + enc);
  });
}

async function reloadWithEncoding() {
  if (!activeTab) { termLog('warn', 'No file open.'); return; }
  showDialog('Reload with Encoding', _currentEncoding, 'Reload', async (enc) => {
    enc = enc.trim().toUpperCase() || 'UTF-8';
    setFileEncoding(null, enc);
    await openFile(activeTab);
    termLog('sys', 'Reloaded with encoding: ' + enc);
  });
}

document.addEventListener('click', (e) => {
  if (_encodingPopupOpen && !e.target.closest('#sb-encoding')) {
    const popup = document.getElementById('sb-encoding-popup');
    if (popup) popup.style.display = 'none';
    _encodingPopupOpen = false;
  }
});

// ── Border radius ─────────────────────────────────────────────────
function applyBorderRadius(val) {
  ideSettings.borderRadius = +val;
  const style = document.getElementById('void-border-radius-style') ||
    (() => { const s = document.createElement('style'); s.id = 'void-border-radius-style'; document.head.appendChild(s); return s; })();
  if (val === '0') {
    style.textContent = `* { border-radius: 0 !important; }`;
  } else if (val === '10') {
    style.textContent = `.menu-dropdown{border-radius:8px}.tbtn{border-radius:8px}#dialog{border-radius:12px}.ctx-menu{border-radius:8px}`;
  } else if (val === '6') {
    style.textContent = `.menu-dropdown{border-radius:6px}.tbtn{border-radius:6px}#dialog{border-radius:8px}.ctx-menu{border-radius:6px}`;
  } else {
    style.textContent = '';
  }
  saveSettings();
}

// ── Cursor color ──────────────────────────────────────────────────
function setCursorColor(color, el) {
  if (el && el !== document.querySelector('input[type=color]')) {
    document.querySelectorAll('#set-cursor-swatches .set-swatch:not(input)').forEach(s => s.classList.remove('selected'));
    if (el.classList) el.classList.add('selected');
  }
  const style = document.getElementById('void-cursor-color-style') ||
    (() => { const s = document.createElement('style'); s.id = 'void-cursor-color-style'; document.head.appendChild(s); return s; })();
  style.textContent = `.monaco-editor .cursor { background-color: ${color} !important; border-color: ${color} !important; }`;
  ideSettings.cursorColor = color;
  saveSettings();
}


// ═══════════════════════════════════════════════════════════════════
//  PRELOAD BASE DIRECTORY
//  When the preloader can't find a file relative to the HTML, it
//  tries again relative to this base dir. Useful when assets live
//  in a subdirectory like /public or /dist.
// ═══════════════════════════════════════════════════════════════════
let _preloadBaseDir = '';   // e.g. '' or 'public' or 'src/assets'

function promptSetBaseDir() {
  showDialog('Set Preload Base Dir', _preloadBaseDir || '/', 'Set', async val => {
    _preloadBaseDir = val.replace(/^\/+|\/+$/g,'');
    const label = _preloadBaseDir || '(root)';
    termLog('fetch', 'Preload base dir: /' + label);
    document.getElementById('url-bar-basedir').textContent = '📂 /' + (_preloadBaseDir ? _preloadBaseDir.slice(-14) : '');
    // persist
    try { localStorage.setItem('void-preload-basedir', _preloadBaseDir); } catch(e) {}
  });
}

// Resolve a path using base dir fallback
async function resolveSrcWithBase(raw, contextVPath) {
  const primary = resolveSrc(raw, contextVPath);
  // Check primary first
  if (await fsExists('/' + primary).catch(() => false)) return primary;
  if (sharedMapLookup(primary)) return primary;
  // Try base dir
  if (_preloadBaseDir) {
    const withBase = resolveSrc(raw, _preloadBaseDir + '/index');
    if (await fsExists('/' + withBase).catch(() => false)) return withBase;
    if (sharedMapLookup(withBase)) return withBase;
    // Also try joining base dir directly
    const direct = _preloadBaseDir + '/' + raw.replace(/^\.?\//,'');
    if (await fsExists('/' + direct).catch(() => false)) return direct;
    if (sharedMapLookup(direct)) return direct;
  }
  return primary; // return primary even if not found
}

// Load base dir preference
(function() {
  try {
    const saved = localStorage.getItem('void-preload-basedir');
    if (saved !== null) {
      _preloadBaseDir = saved;
      const btn = document.getElementById('url-bar-basedir');
      if (btn) btn.textContent = '📂 /' + (saved ? saved.slice(-14) : '');
    }
  } catch(e) {}
})();

// ═══════════════════════════════════════════════════════════════════
//  WEBPACK / COMMONJS COMPAT SHIM
//  Injected at the top of every rewritten JS blob when webpack mode
//  is enabled. Makes module.exports / require() / __webpack_require__
//  work inside blob: URLs (which normally have no module system).
//
//  Also handles:
//   - __webpack_require__.r() — marks ES module namespace
//   - __webpack_require__.n() — getDefaultExport helper
//   - __webpack_require__.d() — define getter properties
//   - __webpack_require__.o() — hasOwnProperty helper
//   - define() / AMD loader shim
//   - UMD wrapper detection (factory pattern)
// ═══════════════════════════════════════════════════════════════════
let _webpackCompatEnabled = true;   // on by default for preloader

function buildWebpackShim(moduleRegistry) {
  // moduleRegistry is a JS expression string (e.g. a JSON map) or 'window.__VOID_MODULES__'
  return `(function(){
if(typeof __voidShimmed!=='undefined')return;
var __voidShimmed=true;
// ── Module registry ────────────────────────────────────────
var __reg=window.__VOID_MODULES__=window.__VOID_MODULES__||{};
// ── module / exports ───────────────────────────────────────
if(typeof module==='undefined'){window.module={exports:{}};}
if(typeof exports==='undefined'){window.exports=module.exports;}
// ── require() — looks up blob registry first ───────────────
function __voidRequire(id){
  if(__reg[id])return __reg[id];
  // try stripping leading ./ or /
  var stripped=id.replace(/^\\.\\//,'').replace(/^\\/+/,'');
  if(__reg[stripped])return __reg[stripped];
  // fallback: try window globals
  var parts=id.split('/');
  var name=parts[parts.length-1].replace(/\\.[^.]+$/,'');
  if(window[name])return window[name];
  console.warn('[void-wp] require: module not found:',id);
  return {};
}
if(typeof require==='undefined')window.require=__voidRequire;
// ── __webpack_require__ ────────────────────────────────────
var __wr=function(id){return __voidRequire(id);};
__wr.r=function(exp){
  if(typeof Symbol!=='undefined'&&Symbol.toStringTag)
    Object.defineProperty(exp,'__esModule',{value:true});
  else exp.__esModule=true;
};
__wr.n=function(mod){
  var getter=mod&&mod.__esModule?function(){return mod['default'];}:function(){return mod;};
  __wr.d(getter,'a',getter);return getter;
};
__wr.d=function(exp,name,getter){
  if(!__wr.o(exp,name))Object.defineProperty(exp,name,{enumerable:true,get:getter});
};
__wr.o=function(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);};
__wr.e=function(){return Promise.resolve();}; // chunk loading stub
__wr.p=''; // publicPath
if(typeof __webpack_require__==='undefined')window.__webpack_require__=__wr;
// ── AMD define() shim ─────────────────────────────────────
if(typeof define==='undefined'){
  window.define=function(id,deps,factory){
    if(typeof id!=='string'){factory=deps;deps=id;id=null;}
    if(!Array.isArray(deps)){factory=deps;deps=[];}
    var resolved=deps.map(function(d){
      if(d==='require')return __voidRequire;
      if(d==='exports')return module.exports;
      if(d==='module')return module;
      return __voidRequire(d);
    });
    var result=typeof factory==='function'?factory.apply(null,resolved):factory;
    if(result!==undefined&&id)__reg[id]=result;
    else if(result!==undefined)Object.assign(module.exports,result);
  };
  window.define.amd={};
}
})();`;
}

// Wrap a single rewritten JS source with the webpack shim + self-registration
function wrapWithWebpackShim(src, vPath) {
  if (!_webpackCompatEnabled) return src;
  const shim = buildWebpackShim();
  // After execution, register the module's exports in the global registry
  const register = `\n(function(){
var __k=${JSON.stringify(vPath)};
var __k2=${JSON.stringify(vPath.split('/').pop())};
window.__VOID_MODULES__=window.__VOID_MODULES__||{};
window.__VOID_MODULES__[__k]=module.exports;
window.__VOID_MODULES__[__k2]=module.exports;
// also expose named exports
if(module.exports&&typeof module.exports==='object'){
  Object.keys(module.exports).forEach(function(name){
    if(!(name in window))try{window[name]=module.exports[name];}catch(e){}
  });
}
})();`;
  return shim + '\n' + src + register;
}

// ═══════════════════════════════════════════════════════════════════
//  URL BAR — load any URL through the preloader
// ═══════════════════════════════════════════════════════════════════
let _urlWebpackEnabled = false;
let _urlBarHistory = [];
let _urlBarHistoryIdx = -1;

function toggleUrlBar() {
  const bar = document.getElementById('preview-url-bar');
  const isVisible = bar.classList.toggle('visible');
  if (isVisible) {
    switchPanelTab('preview');
    document.getElementById('url-bar-input').focus();
    document.getElementById('ptab-btn-url').style.color = 'var(--accent)';
  } else {
    document.getElementById('ptab-btn-url').style.color = '';
  }
}

function toggleUrlWebpack(btn) {
  _urlWebpackEnabled = !_urlWebpackEnabled;
  btn.classList.toggle('on', _urlWebpackEnabled);
  termLog('fetch', 'URL webpack shim: ' + (_urlWebpackEnabled ? 'ON' : 'OFF'));
}

async function urlBarGo() {
  let url = document.getElementById('url-bar-input').value.trim();
  if (!url) return;
  // Auto-prefix https:// if no scheme
  if (!/^(https?:|blob:|data:|about:|\/|\.\.?\/)/.test(url)) url = 'https://' + url;
  switchPanelTab('preview');

  // Local VFS path?
  if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
    const localPath = url.startsWith('/') ? url : '/' + url.replace(/^\.\//,'');
    await runLocalPath(localPath);
    return;
  }

  // External URL — try to load it through fetch and blob it
  termLog('fetch', '━━ URL load: ' + url);
  try {
    const resp = await fetch(url, { mode: 'cors' }).catch(async () => {
      // CORS blocked — try CORS proxy
      termLog('warn', '  CORS blocked, trying proxy…');
      return fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
    });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const contentType = resp.headers.get('content-type') || 'text/html';
    const isHtml = /html/.test(contentType);
    let text = await resp.text();

    if (isHtml && _urlWebpackEnabled) {
      // Apply webpack shim to all inline scripts in the HTML
      text = text.replace(/<script([^>]*)>([\s\S]*?)<\/script>/gi, (m, attrs, src) => {
        if (/\bsrc\s*=/.test(attrs)) return m;
        return `<script${attrs}>${buildWebpackShim()}\n${src}<` + `/script>`;
      });
      termLog('fetch', '  Webpack shim injected into inline scripts');
    }

    if (isHtml) {
      // Fix relative URLs in the loaded HTML to point back to origin
      const origin = new URL(url).origin;
      const base = url.replace(/[^/]+$/, '');
      text = text.replace(/<head([^>]*)>/i, `<head$1><base href="${base}">`);
      // Inject into iframe
      document.getElementById('preview-frame').srcdoc = text;
    } else {
      // Non-HTML: create blob and load
      const blob = new Blob([text], { type: contentType });
      const blobUrl = URL.createObjectURL(blob);
      document.getElementById('preview-frame').src = blobUrl;
    }
    _urlBarHistory.push(url);
    _urlBarHistoryIdx = _urlBarHistory.length - 1;
    termLog('fetch', '━━ URL loaded ✓');
  } catch(e) {
    termLog('error', 'URL load failed: ' + e.message);
  }
}

async function runLocalPath(localPath) {
  // Run a local VFS path through the fetch preloader
  const exists = await fsExists(localPath).catch(() => false);
  if (!exists) { termLog('warn', 'Local path not found: ' + localPath); return; }
  // Temporarily set activeTab to that path and run
  const prevTab = activeTab;
  const ext = localPath.split('.').pop().toLowerCase();
  if (ext === 'html' || ext === 'htm') {
    activeTab = localPath;
    await runWithFetchPreload();
    activeTab = prevTab;
  } else {
    // Non-HTML local file: show in preview as blob
    const mime = getMime(ext);
    const isBin = BIN_EXTS.has(ext);
    let blobUrl;
    if (isBin) {
      const buf = await readRawBytes(localPath);
      blobUrl = URL.createObjectURL(new Blob([buf], { type: mime }));
    } else {
      const text = await fsReadFile(localPath);
      blobUrl = URL.createObjectURL(new Blob([text], { type: mime }));
    }
    document.getElementById('preview-frame').src = blobUrl;
    termLog('fetch', 'Local file loaded as blob: ' + localPath);
  }
}

function urlBarBack() {
  if (_urlBarHistoryIdx > 0) {
    _urlBarHistoryIdx--;
    document.getElementById('url-bar-input').value = _urlBarHistory[_urlBarHistoryIdx];
    urlBarGo();
  }
}

function urlBarReload() {
  urlBarGo();
}

// ═══════════════════════════════════════════════════════════════════
//  JS EXECUTION TREE + FETCH PRE-LOADER
//
//  How it works:
//  1. Starting from HTML, collect every <script src> and inline script.
//  2. For each JS file, recursively walk ALL imports (static & dynamic)
//     building a dependency tree — each node knows its vPath, its
//     source text, its imports, and all fetch()/XHR URLs it calls.
//  3. Bottom-up (leaves first), rewrite each JS file's source:
//       a. Every fetch('local/path') string literal → fetch('blob:...')
//          where the blob contains the actual file content from VFS.
//       b. Every import './dep.js' → import 'blob:...' pointing to the
//          already-rewritten dep blob (ensures deps are processed first).
//       c. If webpack compat is ON, each JS blob is wrapped with the
//          module/exports/require/__webpack_require__ shim.
//  4. The rewritten source is itself turned into a blob: URL.
//  5. HTML <script src="..."> tags are swapped to the root blob: URLs.
//  6. Result: a fully self-contained document where every local JS
//     dependency and every fetch() target is a blob — no network needed.
// ═══════════════════════════════════════════════════════════════════

// ── Regex helpers ─────────────────────────────────────────────────

// Detect if a string looks like a local file path (not external, not data/blob)
// Accepts paths with or without extensions, relative or root-relative
function _isLocalPath(s) {
  if (!s || s.length < 1) return false;
  if (/^(https?:|blob:|data:|javascript:|mailto:|tel:)/.test(s)) return false;
  if (/^#/.test(s)) return false;                 // anchor only
  if (/\s/.test(s) && !/[./]/.test(s)) return false; // spaces but no path sep = not a path
  if (s.length > 512) return false;               // too long to be a real path
  // Must look like a path: starts with ./ ../ / or has a . in the last segment
  return /^\.\.?\//         .test(s)   // relative: ./foo or ../foo
      || /^\/[^/]/          .test(s)   // root-relative: /foo
      || /^[^/: ]+\.[a-z0-9]{1,10}$/i .test(s)   // bare name with ext: foo.json
      || /^[^/: ]+\//.test(s);         // has a slash (path segment)
}

// All static import/export-from specifiers in a JS source string
function _jsStaticImports(src) {
  // Match: import ... from 'spec'  /  export ... from 'spec'
  const re = /\b(?:import|export)\b[^;'"` \n]*?(?:\{[^}]*\}|[\w*]+|\*\s+as\s+\w+)?\s*(?:,\s*(?:\{[^}]*\}|\*\s+as\s+\w+|\w+))?\s*from\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/gm;
  const re2 = /\bimport\s+(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/gm; // side-effect import
  const out = [];
  let m;
  while ((m = re.exec(src))  !== null) out.push({ raw: m[2], quote: m[1], full: m[0] });
  while ((m = re2.exec(src)) !== null) out.push({ raw: m[2], quote: m[1], full: m[0] });
  return out.filter(o => _isLocalPath(o.raw));
}

// Dynamic import() calls
function _jsDynImports(src) {
  const re = /\bimport\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1\s*\)/g;
  const out = [];
  let m;
  while ((m = re.exec(src)) !== null) {
    if (_isLocalPath(m[2])) out.push({ raw: m[2], quote: m[1], full: m[0], offset: m.index, len: m[0].length });
  }
  return out;
}

// ── Comprehensive local-file reference extractor ───────────────────
//
// Catches every conceivable pattern in JS/HTML that references a local
// file, regardless of file type (including unknown/non-MIME extensions).
//
// Patterns covered:
//   fetch('path'), fetch(new Request('path'))
//   xhr.open('METHOD', 'path')
//   new Worker('path'), new SharedWorker('path'), new URL('path', ...)
//   require('path'), require.resolve('path')
//   import('path')  [handled separately but also caught here for inline scripts]
//   WebAssembly.instantiateStreaming(fetch('path'))
//   loadScript('path'), loadCSS('path'), loadFile('path'), getFile('path')
//   $.get('path'), $.post('path'), $.ajax({url:'path'})
//   axios.get('path'), axios.post('path'), axios({ url: 'path' })
//   d3.json('path'), d3.csv('path'), d3.tsv('path'), d3.text('path'), d3.xml('path')
//   Papa.parse('path'), papaparse url field
//   EventSource('path'), WebSocket('path')  [local ws:// excluded]
//   document.createElement('script').src = 'path'
//   image.src = 'path', video.src = 'path', audio.src = 'path'
//   link.href = 'path', script.src = 'path'
//   Any string ending in a file extension (all known + unknown) used in a call arg
//   CSS url('path') inside JS strings
//   loadModule('path'), System.import('path'), requirejs(['path'])
//   Blob constructor with string path references
//   fs.readFile('path'), fs.readFileSync('path'), Deno.readFile('path')
//   Any quoted string that looks like a local path with an extension
//
// Returns: [{raw, quote, offset, len, full}] — all referring to the
// same quoted-string replacement target inside the source.

function _jsFetchUrls(src) {
  const hits = [];
  const seen = new Set();

  function add(raw, quote, offset, fullMatch) {
    if (!_isLocalPath(raw)) return;
    const key = offset + ':' + raw;
    if (seen.has(key)) return;
    seen.add(key);
    hits.push({ raw, quote, offset, len: fullMatch.length, full: fullMatch });
  }

  // Helper: run a regex and capture group [quoteGroup] = quote, [urlGroup] = url
  function scan(re, quoteGroup, urlGroup) {
    let m;
    const reCopy = new RegExp(re.source, re.flags);
    while ((m = reCopy.exec(src)) !== null) {
      const raw = m[urlGroup];
      const quote = m[quoteGroup];
      if (raw) add(raw, quote, m.index, m[0]);
    }
  }

  // ── Network/fetch APIs ──────────────────────────────────────────
  // fetch('url')  fetch("url")  fetch(`url`)
  scan(/\bfetch\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // fetch(new Request('url'))
  scan(/\bnew\s+Request\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // xhr.open('METHOD', 'url', ...)
  scan(/\.open\s*\(\s*['"`]\w*['"`]\s*,\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // xhr.open, also catch uppercase METHOD
  scan(/XMLHttpRequest[^;]*?\.open\s*\(\s*['"`][A-Z]+['"`]\s*,\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── Worker APIs ─────────────────────────────────────────────────
  scan(/\bnew\s+Worker\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\bnew\s+SharedWorker\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\bnew\s+ServiceWorker\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // navigator.serviceWorker.register('url')
  scan(/\.register\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── new URL('path', ...) ────────────────────────────────────────
  scan(/\bnew\s+URL\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── WebAssembly ─────────────────────────────────────────────────
  scan(/WebAssembly\.(?:instantiate|instantiateStreaming|compileStreaming|compile)\s*\(\s*(?:fetch\s*\(\s*)?(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── require / CommonJS ──────────────────────────────────────────
  scan(/\brequire\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1\s*\)/g, 1, 2);
  scan(/\brequire\.resolve\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1\s*\)/g, 1, 2);
  // requirejs / AMD
  scan(/\brequirejs?\s*\(\s*\[(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // define(['dep1','dep2'], ...)
  scan(/\bdefine\s*\(\s*\[\s*(['"`])((?!https?:|blob:|data:)[^'"`\n\]]+)\1/g, 1, 2);
  // System.import('path')
  scan(/\bSystem\.import\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── jQuery / Axios / superagent / got ───────────────────────────
  scan(/\$\.(?:get|post|getJSON|getScript|load)\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\$\.ajax\s*\(\s*\{[^}]*?url\s*:\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\baxios\s*\.\s*(?:get|post|put|patch|delete|head|options|request)\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\baxios\s*\(\s*\{[^}]*?url\s*:\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\brequest\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // got, node-fetch, superagent
  scan(/\bgot\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── D3 / data loading libs ───────────────────────────────────────
  scan(/\bd3\s*\.\s*(?:json|csv|tsv|text|xml|html|svg|image|blob|buffer|dsv|autoType)\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\bPapa(?:parse)?\s*\.parse\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // crossfilter, topojson, etc — generic loadXxx('path')
  scan(/\b(?:load|read|get|fetch|import|open|parse|request)(?:[A-Z][a-zA-Z0-9]*)?\s*\(\s*(['"`])((?!https?:|blob:|data:)[./][^'"`\n]+)\1/g, 1, 2);

  // ── EventSource / WebSocket (local) ─────────────────────────────
  scan(/\bnew\s+EventSource\s*\(\s*(['"`])((?!https?:|blob:|data:|wss?:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\bnew\s+WebSocket\s*\(\s*(['"`])((?!https?:|blob:|data:|wss?:)[^'"`\n]+)\1/g, 1, 2);

  // ── DOM property assignments ─────────────────────────────────────
  // el.src = 'path'   el.href = 'path'   el.data = 'path'   el.action = 'path'
  scan(/\.\s*(?:src|href|data|action|poster|manifest)\s*=\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  // setAttribute('src', 'path')
  scan(/\.setAttribute\s*\(\s*['"`](?:src|href|data|poster|action|manifest)['"`]\s*,\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── CSS url() inside JS strings ──────────────────────────────────
  // Catches: "url('./image.png')" or `background: url(${path})` etc.
  scan(/url\(\s*(['"`]?)((?!https?:|blob:|data:|#)[^'"`)\n]+)\1\s*\)/g, 1, 2);

  // ── Node / Deno FS APIs (for completeness, might appear in bundled code)
  scan(/\bfs\.(?:readFile|readFileSync|createReadStream|stat|watch)\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);
  scan(/\bDeno\.(?:readFile|readTextFile|open|stat|readDir)\s*\(\s*(['"`])((?!https?:|blob:|data:)[^'"`\n]+)\1/g, 1, 2);

  // ── Catch-all: ANY quoted string that looks like a local path ────
  // This is the broadest pass — any single/double/backtick quoted string
  // that starts with ./ or ../ or / and has a file extension, OR is a
  // bare filename with any extension (including unknown extensions like
  // .bin, .dat, .raw, .custom, .wasm, .glb, .gltf, .mtl, .obj, etc.)
  // We only add if not already seen.
  const catchAllRe = /(['"`])((?:\.\.?\/|\/)[^'"`\n?#]{2,}|[a-zA-Z0-9_-]+\.[a-zA-Z0-9]{1,12})\1/g;
  let cm;
  while ((cm = catchAllRe.exec(src)) !== null) {
    const raw = cm[2];
    const quote = cm[1];
    if (!_isLocalPath(raw)) continue;
    // Skip if it looks like a CSS color, version string, or other non-path
    if (/^#[0-9a-f]{3,8}$/i.test(raw)) continue;         // CSS hex color
    if (/^\d+\.\d+\.\d+/.test(raw)) continue;             // semver
    if (/^[a-z]+-[a-z]+-[a-z]+$/.test(raw)) continue;    // word-word-word pattern
    if (raw.split('/').pop().split('.')[0].length < 1) continue; // no basename
    add(raw, quote, cm.index, cm[0]);
  }

  return hits;
}

// ── Execution Tree Node ────────────────────────────────────────────
// {
//   vPath        : string       — canonical vPath (e.g. "src/app.js")
//   src          : string|null  — raw source text (null if unresolvable)
//   imports      : string[]     — vPaths of JS imports (static + dynamic)
//   fetchTargets : {raw, resolved, quote, offset, len, full}[]
//                               — every local file reference found in src
//   blobUrl      : string|null  — set during bottom-up rewrite phase
//   external     : bool         — true if https/blob/data (pass-through)
//   isJsLike     : bool         — true if this file should be parsed for imports
// }

// File extensions we treat as JS-parseable (recurse into for imports)
const JS_EXTS = new Set(['js','mjs','cjs','jsx','ts','tsx','coffee','ls','es']);

function _isJsLike(vPath) {
  const ext = vPath.split('.').pop().toLowerCase();
  return JS_EXTS.has(ext);
}

let _execTreeCache = {};   // vPath → node (for dedup within one run)

async function _buildExecNode(vPath, htmlVPath, visiting) {
  if (_execTreeCache[vPath]) return _execTreeCache[vPath];

  const isJsLike = _isJsLike(vPath);
  const node = { vPath, src: null, imports: [], fetchTargets: [], blobUrl: null, external: false, isJsLike };
  _execTreeCache[vPath] = node;

  if (visiting.has(vPath)) return node;
  visiting.add(vPath);

  // Only read text for JS-like files (binary files have no imports/fetches to scan)
  if (isJsLike) {
    const src = await readRawText(vPath);
    if (src === null) {
      termLog('warn', '[tree] not found: ' + vPath);
      visiting.delete(vPath);
      return node;
    }
    node.src = src;

    // ── Collect static imports ──
    const staticImps = _jsStaticImports(src);
    // ── Collect dynamic imports ──
    const dynImps = _jsDynImports(src);
    // ── Collect ALL local file references (fetch, XHR, require, src=, etc.)
    const fetchHits = _jsFetchUrls(src);

    // Resolve import specifiers and recurse concurrently
    const importSpecifiers = [
      ...staticImps.map(i => i.raw),
      ...dynImps.map(i => i.raw),
    ];

    const childPromises = importSpecifiers.map(async spec => {
      const childVPath = await resolveSrcWithBase(spec, vPath);
      if (/^(https?:|blob:|data:)/.test(childVPath)) return null;
      return _buildExecNode(childVPath, htmlVPath, visiting);
    });
    const childNodes = await Promise.all(childPromises);

    const specToVPath = {};
    importSpecifiers.forEach((spec, i) => {
      const child = childNodes[i];
      if (child) specToVPath[spec] = child.vPath;
    });
    node.imports = Object.values(specToVPath).filter(Boolean);

    // Store full hit objects so _rewriteNode can do precise offset-based replacement
    const resolvedTargets = await Promise.all(fetchHits.map(async f => ({
      ...f,
      resolved: await resolveSrcWithBase(f.raw, vPath)
    })));
    node.fetchTargets = resolvedTargets.filter(f => !/^(https?:|blob:|data:)/.test(f.resolved));

    // Also recurse into any JS files referenced via fetch/require (e.g. dynamic script loading)
    const jsSubDeps = node.fetchTargets.filter(f => _isJsLike(f.resolved));
    await Promise.all(jsSubDeps.map(f => _buildExecNode(f.resolved, htmlVPath, visiting)));
  }

  visiting.delete(vPath);
  return node;
}

// ── Make a blob URL from any local file (text, binary, or unknown) ─
async function _makeFileBlobUrl(vPath) {
  const ext = vPath.split('.').pop().split('?')[0].toLowerCase();
  const mime = getMime(ext); // falls back to 'application/octet-stream' for unknown
  const isBin = BIN_EXTS.has(ext);

  // For unknown/non-MIME-mapped extensions, try text first, then binary
  if (isBin) {
    const buf = await readRawBytes(vPath);
    if (!buf) return null;
    return URL.createObjectURL(new Blob([buf], { type: mime }));
  }

  // Try text read first (covers .json, .glsl, .obj, .mtl, .csv, .dat, .txt,
  // .wgsl, .vert, .frag, .glb needs binary — but unknown exts we try text)
  const textContent = await readRawText(vPath);
  if (textContent !== null) {
    // For JS-like files that were rewritten, use their blobUrl if available
    const node = _execTreeCache[vPath];
    if (node && node.blobUrl) return node.blobUrl;
    return URL.createObjectURL(new Blob([textContent], { type: mime }));
  }

  // Fallback: binary read
  const buf = await readRawBytes(vPath);
  if (!buf) return null;
  return URL.createObjectURL(new Blob([buf], { type: mime }));
}

// ── Bottom-up rewrite: leaves → roots ─────────────────────────────
async function _rewriteNode(node, fetchBlobCache, rewritten) {
  if (rewritten.has(node.vPath)) return;
  rewritten.add(node.vPath);

  if (!node.src) return; // non-JS or unresolvable

  // 1. Recursively rewrite all import dependencies first (concurrent)
  const importNodes = node.imports
    .map(vp => _execTreeCache[vp])
    .filter(Boolean);
  await Promise.all(importNodes.map(n => _rewriteNode(n, fetchBlobCache, rewritten)));

  // 2. Pre-load ALL fetch/file targets as blobs (concurrent)
  await Promise.all(node.fetchTargets.map(async target => {
    const vPath = target.resolved;
    if (fetchBlobCache[vPath]) return;
    try {
      // If the target is itself a JS file with a rewritten blob, use that
      const childNode = _execTreeCache[vPath];
      if (childNode && childNode.blobUrl) {
        fetchBlobCache[vPath] = childNode.blobUrl;
        return;
      }
      const blobUrl = await _makeFileBlobUrl(vPath);
      if (!blobUrl) { termLog('warn', '[fetch] not found: ' + vPath); return; }
      fetchBlobCache[vPath] = blobUrl;
      termLog('fetch', '  ✓ ' + vPath.split('/').pop() + ' → blob:');
    } catch(e) {
      termLog('warn', '[fetch] failed: ' + vPath + ' — ' + e.message);
    }
  }));

  // 3. Collect all replacements and apply them to the source
  //    We work with {offset, len, newText} tuples covering:
  //      a) import specifiers  → child blobUrl
  //      b) dynamic import()   → child blobUrl
  //      c) fetch/XHR/require/src= targets → fetchBlobCache blobUrl
  const replacements = [];

  // 3a. Static imports — replace the quoted specifier
  for (const imp of _jsStaticImports(node.src)) {
    const childVPath = resolveSrc(imp.raw, node.vPath);
    const childNode = _execTreeCache[childVPath];
    if (!childNode || !childNode.blobUrl) continue;
    // Find the exact position of the quoted specifier within the full match
    const stmtIdx = node.src.indexOf(imp.full);
    if (stmtIdx === -1) continue;
    const specPattern = imp.quote + imp.raw + imp.quote;
    const specIdx = imp.full.lastIndexOf(specPattern);
    if (specIdx === -1) continue;
    replacements.push({
      offset: stmtIdx + specIdx,
      len: specPattern.length,
      newText: imp.quote + childNode.blobUrl + imp.quote,
    });
  }

  // 3b. Dynamic imports — find offset inside source and replace quoted specifier
  for (const imp of _jsDynImports(node.src)) {
    const childVPath = resolveSrc(imp.raw, node.vPath);
    const childNode = _execTreeCache[childVPath];
    if (!childNode || !childNode.blobUrl) continue;
    const specPattern = imp.quote + imp.raw + imp.quote;
    const specIdx = imp.full.indexOf(specPattern);
    if (specIdx === -1) continue;
    replacements.push({
      offset: imp.offset + specIdx,
      len: specPattern.length,
      newText: imp.quote + childNode.blobUrl + imp.quote,
    });
  }

  // 3c. ALL fetch/file targets — replace the quoted URL string in place
  for (const target of node.fetchTargets) {
    const blobUrl = fetchBlobCache[target.resolved];
    if (!blobUrl) continue;
    // The hit's offset points to the start of the full matched text (e.g. `fetch(`)
    // We need to find the quoted specifier within it
    const specPattern = target.quote + target.raw + target.quote;
    const specIdx = target.full.indexOf(specPattern);
    if (specIdx === -1) continue;
    replacements.push({
      offset: target.offset + specIdx,
      len: specPattern.length,
      newText: target.quote + blobUrl + target.quote,
    });
  }

  // 4. Apply replacements in reverse order (highest offset first)
  replacements.sort((a, b) => b.offset - a.offset);

  // Deduplicate overlapping replacements
  let rewrittenSrc = node.src;
  let prevEnd = Infinity;
  for (const r of replacements) {
    const end = r.offset + r.len;
    if (end > prevEnd) continue; // overlapping, skip
    rewrittenSrc = rewrittenSrc.slice(0, r.offset) + r.newText + rewrittenSrc.slice(end);
    prevEnd = r.offset;
  }

  // 5. Turn rewritten JS into a blob (wrapped with webpack shim if enabled)
  const finalSrc = _webpackCompatEnabled ? wrapWithWebpackShim(rewrittenSrc, node.vPath) : rewrittenSrc;
  node.blobUrl = URL.createObjectURL(new Blob([finalSrc], { type: 'text/javascript' }));

  const rewroteCount = replacements.length;
  termLog('fetch', '  ✓ ' + node.vPath.split('/').pop()
    + (rewroteCount ? ' [' + rewroteCount + ' ref' + (rewroteCount > 1 ? 's' : '') + ' → blob]' : '')
    + ' → blob:');
}

// ── Entry point: build full exec tree for an HTML file ───────────
// Returns: { rootNodes: [{vPath, blobUrl, isModule}], inlinePatched: string[] }
// where inlinePatched are blob: URLs for inline scripts that had fetch calls.
async function buildExecTree(html, htmlVPath) {
  _execTreeCache = {};  // reset per run
  const fetchBlobCache = {};
  const rewritten = new Set();

  termLog('fetch', '━━ Building JS execution tree…');

  // ── Phase 1: discover all JS entry points from HTML ──────────────

  // External <script src="...">
  const scriptSrcRe = /<script([^>]*)>/gi;
  const entryNodes = [];   // { specifier, vPath, isModule, isInline, inlineSrc, tagOffset, tagLen }
  let sm;
  while ((sm = scriptSrcRe.exec(html)) !== null) {
    const attrs = sm[1];
    const srcM = /\bsrc\s*=\s*["']([^"']+)["']/.exec(attrs);
    const isModule = /\btype\s*=\s*["']module["']/i.test(attrs);
    if (srcM) {
      const raw = srcM[1];
      if (/^(https?:|blob:|data:)/.test(raw)) continue;
      const vp = resolveSrc(raw, htmlVPath);
      entryNodes.push({ specifier: raw, vPath: vp, isModule, isInline: false });
    }
  }

  // Inline <script> blocks (no src)
  const inlineScriptRe = /<script([^>]*)>([\s\S]*?)<\/script>/gi;
  const inlineEntries = [];
  let im;
  while ((im = inlineScriptRe.exec(html)) !== null) {
    if (/\bsrc\s*=/.test(im[1])) continue; // has src, skip
    const isModule = /\btype\s*=\s*["']module["']/i.test(im[1]);
    const inlineSrc = im[2];
    if (!inlineSrc.trim()) continue;
    inlineEntries.push({ inlineSrc, isModule, fullMatch: im[0], offset: im.index });
  }

  termLog('fetch', '  Found ' + entryNodes.length + ' external script(s), ' + inlineEntries.length + ' inline script(s)');

  // ── Phase 2: build tree nodes for all external scripts concurrently
  const visiting = new Set();
  await Promise.all(entryNodes.map(e => _buildExecNode(e.vPath, htmlVPath, visiting)));

  // ── Phase 3: for each inline script, collect fetch targets only
  //    (inline scripts become their own synthetic nodes)
  const inlineNodes = inlineEntries.map((ie, idx) => {
    const syntheticVPath = htmlVPath + '::inline:' + idx;
    const fetchHits = _jsFetchUrls(ie.inlineSrc);
    const fetchTargets = fetchHits
      .map(f => ({ ...f, resolved: resolveSrc(f.raw, htmlVPath) }))
      .filter(f => !/^(https?:|blob:|data:)/.test(f.resolved));
    const node = { vPath: syntheticVPath, src: ie.inlineSrc, imports: [], fetchTargets, blobUrl: null, external: false, isJsLike: true };
    _execTreeCache[syntheticVPath] = node;
    return { node, ie };
  });

  // ── Phase 4: bottom-up rewrite — leaves first, then roots ────────
  // Rewrite all external entry nodes (which recursively rewrites their deps)
  await Promise.all(entryNodes.map(e => {
    const node = _execTreeCache[e.vPath];
    if (node) return _rewriteNode(node, fetchBlobCache, rewritten);
  }));

  // Rewrite inline synthetic nodes (only fetch substitution, no import rewriting needed)
  await Promise.all(inlineNodes.map(async ({ node, ie }) => {
    // Pre-load all fetch targets concurrently
    await Promise.all(node.fetchTargets.map(async target => {
      const vPath = target.resolved;
      if (fetchBlobCache[vPath]) return;
      try {
        const childNode = _execTreeCache[vPath];
        if (childNode && childNode.blobUrl) { fetchBlobCache[vPath] = childNode.blobUrl; return; }
        const blobUrl = await _makeFileBlobUrl(vPath);
        if (!blobUrl) return;
        fetchBlobCache[vPath] = blobUrl;
        termLog('fetch', '  ✓ inline ref → blob: ' + vPath.split('/').pop());
      } catch(e) {}
    }));

    // Rewrite inline src: replace all matched URL strings in reverse offset order
    let rewrittenInline = ie.inlineSrc;
    // Gather replacements
    const reps = [];
    for (const target of node.fetchTargets) {
      const blobUrl = fetchBlobCache[target.resolved];
      if (!blobUrl) continue;
      const specPattern = target.quote + target.raw + target.quote;
      const specIdx = target.full.indexOf(specPattern);
      if (specIdx === -1) continue;
      reps.push({
        offset: target.offset + specIdx,
        len: specPattern.length,
        newText: target.quote + blobUrl + target.quote,
      });
    }
    // Apply in reverse
    reps.sort((a, b) => b.offset - a.offset);
    let prevEnd = Infinity;
    for (const r of reps) {
      if (r.offset + r.len > prevEnd) continue;
      rewrittenInline = rewrittenInline.slice(0, r.offset) + r.newText + rewrittenInline.slice(r.offset + r.len);
      prevEnd = r.offset;
    }
    node.rewrittenInlineSrc = rewrittenInline;
    if (reps.length) termLog('fetch', '  ✓ inline script: ' + reps.length + ' ref(s) → blob');
  }));

  // ── Phase 5: log tree summary ────────────────────────────────────
  const treeSize = Object.keys(_execTreeCache).length;
  const blobCount = Object.values(_execTreeCache).filter(n => n.blobUrl).length;
  const fetchCount = Object.keys(fetchBlobCache).length;
  termLog('fetch', '━━ Tree complete: ' + treeSize + ' JS nodes, '
    + blobCount + ' rewritten, ' + fetchCount + ' fetch blob(s) preloaded');

  return { entryNodes, inlineNodes, fetchBlobCache };
}

// ── Rewrite the full HTML using the exec tree results ─────────────
// Replaces <script src="..."> with blob: URLs and patches inline scripts.
async function applyExecTreeToHtml(html, htmlVPath) {
  const { entryNodes, inlineNodes } = await buildExecTree(html, htmlVPath);

  // Replace external <script src="..."> tags
  for (const entry of entryNodes) {
    const node = _execTreeCache[entry.vPath];
    if (!node || !node.blobUrl) continue;
    // Replace the src attribute value with the blob URL
    const escaped = entry.specifier.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const re = new RegExp('(<script[^>]+\\bsrc\\s*=\\s*["\'])' + escaped + '(["\'])');
    html = html.replace(re, '$1' + node.blobUrl + '$2');
    termLog('fetch', '  ✓ <script src="' + entry.specifier + '"> → blob:');
  }

  // Replace inline scripts with patched versions
  for (const { node, ie } of inlineNodes) {
    if (node.rewrittenInlineSrc && node.rewrittenInlineSrc !== ie.inlineSrc) {
      html = html.replace(ie.inlineSrc, node.rewrittenInlineSrc);
    }
  }

  return html;
}

// ── Analyze JS fetches (Tools menu) ──────────────────────────────
async function analyzeJSFetches() {
  termLog('fetch', '━━ Analyzing JS execution tree…');
  const htmlPath = activeTab && /\.(html|htm)$/i.test(activeTab) ? activeTab :
    (await fsExists('/index.html').catch(()=>false) ? '/index.html' : null);
  if (!htmlPath) { termLog('warn', 'Open an HTML file to analyze its JS.'); return; }

  const strippedPath = htmlPath.replace(/^\/+/, '');
  const srcEntry = sharedMapLookup(strippedPath);
  const html = srcEntry ? await (await srcEntry.handle.getFile()).text()
    : await fsReadFile(htmlPath).catch(() => '');
  const htmlVPath = sharedFileMap.size > 0 ? findHtmlVPath(htmlPath) : strippedPath;

  _execTreeCache = {};

  // Build the tree (dry run — no rewriting)
  const scriptSrcRe = /<script([^>]*)>/gi;
  const entryVPaths = [];
  let sm;
  while ((sm = scriptSrcRe.exec(html)) !== null) {
    const attrs = sm[1];
    const srcM = /\bsrc\s*=\s*["']([^"']+)["']/.exec(attrs);
    if (srcM && !/^(https?:|blob:|data:)/.test(srcM[1])) {
      entryVPaths.push(resolveSrc(srcM[1], htmlVPath));
    }
  }

  const visiting = new Set();
  await Promise.all(entryVPaths.map(vp => _buildExecNode(vp, htmlVPath, visiting)));

  const allNodes = Object.values(_execTreeCache);
  termLog('fetch', '  JS nodes in tree: ' + allNodes.length);

  for (const node of allNodes) {
    if (node.external || !node.src) continue;
    const name = node.vPath.includes('::inline:') ? '[inline script]' : node.vPath.split('/').pop();
    if (node.imports.length)
      termLog('fetch', '  ' + name + ' → imports: ' + node.imports.map(v => v.split('/').pop()).join(', '));
    if (node.fetchTargets.length) {
      const byType = {};
      for (const t of node.fetchTargets) {
        const ext = t.resolved.split('.').pop().toLowerCase() || 'unknown';
        (byType[ext] = byType[ext] || []).push(t.resolved.split('/').pop());
      }
      for (const [ext, names] of Object.entries(byType))
        termLog('fetch', '  ' + name + ' → [.' + ext + '] ' + names.join(', '));
    }
    if (!node.imports.length && !node.fetchTargets.length)
      termLog('fetch', '  ' + name + ' (no local deps/fetches detected)');
  }

  // Inline scripts
  const inlineRe = /<script([^>]*)>([\s\S]*?)<\/script>/gi;
  let im; let inlineIdx = 0;
  while ((im = inlineRe.exec(html)) !== null) {
    if (/\bsrc\s*=/.test(im[1])) continue;
    const hits = _jsFetchUrls(im[2]);
    const localHits = hits.filter(f => _isLocalPath(f.raw));
    if (localHits.length) {
      termLog('fetch', '  [inline#' + (++inlineIdx) + '] refs: ' + localHits.map(f => f.raw).join(', '));
    }
  }

  const totalRefs = allNodes.reduce((s, n) => s + n.fetchTargets.length + n.imports.length, 0);
  termLog('fetch', '━━ Analysis complete — ' + allNodes.length + ' JS files, ' + totalRefs + ' total local references');
}

// ── Run with full exec-tree preloader ────────────────────────────
async function runWithFetchPreload() {
  await saveAll();
  let htmlPath = null;
  if (activeTab && /\.(html|htm)$/i.test(activeTab)) htmlPath = activeTab;
  else if (await fsExists('/index.html').catch(()=>false)) htmlPath = '/index.html';
  if (!htmlPath) { termLog('warn', 'No HTML file to run.'); return; }

  if (ideSettings.autoPreview) switchPanelTab('preview');
  termLog('fetch', '━━ Fetch Preloader: ' + htmlPath);

  try {
    const strippedPath = htmlPath.replace(/^\/+/, '');
    const srcEntry = sharedMapLookup(strippedPath);
    let html = srcEntry ? await (await srcEntry.handle.getFile()).text() : await fsReadFile(htmlPath);
    const htmlVPath = sharedFileMap.size > 0 ? findHtmlVPath(htmlPath) : strippedPath;

    // ── Step 1: build exec tree, rewrite all JS blobs with patched fetch URLs
    html = await applyExecTreeToHtml(html, htmlVPath);

    // ── Step 2: standard asset inlining (CSS, images, fonts, etc.)
    html = await fullyInlineHTML(html, htmlVPath);

    // ── Step 3: inject console bridge + VFS fetch bridge
    const CT = '<' + '/script>';
    const consoleSrc = '(function(){'
      + 'var _={log:console.log,warn:console.warn,error:console.error,info:console.info};'
      + 'function p(l,a){try{parent.postMessage({__void:true,level:l,msg:a.map(function(x){'
      + 'try{return typeof x==="object"?JSON.stringify(x,null,2):String(x);}catch(ee){return String(x);}'
      + '}).join(" ")},"*");}catch(ee){}}'
      + 'console.log=function(){_.log.apply(console,arguments);p("log",[].slice.call(arguments));};'
      + 'console.warn=function(){_.warn.apply(console,arguments);p("warn",[].slice.call(arguments));};'
      + 'console.error=function(){_.error.apply(console,arguments);p("error",[].slice.call(arguments));};'
      + 'console.info=function(){_.info.apply(console,arguments);p("info",[].slice.call(arguments));};'
      + 'window.onerror=function(m,s,l){p("error",["Uncaught: "+m+" (line "+l+")"]);};'
      + 'window.addEventListener("unhandledrejection",function(e){p("error",["Promise: "+String(e.reason)]);});'
      + '})();';

    const bridges = '<script>' + consoleSrc + CT + '<script>' + buildFetchBridge() + CT;

    if (/<head[\s>]/i.test(html)) {
      html = html.replace(/(<head[^>]*>)/i, '$1' + bridges);
    } else {
      html = bridges + html;
    }

    document.getElementById('preview-frame').srcdoc = html;
    termLog('fetch', '━━ Preview ready — all JS/fetch blobs active ✓');
  } catch(e) {
    termLog('error', 'Fetch preload run failed: ' + e.message);
    console.error(e);
  }
}

// ═══════════════════════════════════════════════════════════════════
document.addEventListener('keydown', e => {
  if (e.ctrlKey || e.metaKey) {
    if (e.shiftKey && e.key==='Enter') { e.preventDefault(); runProjectIndex(); return; }
    if (e.shiftKey && e.key==='S')     { e.preventDefault(); saveAll(); return; }
    if (e.shiftKey && e.key==='O')     { e.preventDefault(); importZip(); return; }
    if (e.shiftKey && e.key==='E')     { e.preventDefault(); exportZip(); return; }
    if (e.shiftKey && e.key==='B')     { e.preventDefault(); exportWebpackBundle(); return; }
    if (e.shiftKey && e.key==='R')     { e.preventDefault(); runWithFetchPreload(); return; }
    if (e.key==='Enter') { e.preventDefault(); runCurrentFile(); return; }
    if (e.key==='s')     { e.preventDefault(); saveCurrentFile(); return; }
    if (e.key==='n')     { e.preventDefault(); showNewFileDialog(); return; }
    if (e.key==='b')     { e.preventDefault(); toggleSidebar(); return; }
    if (e.key==='`')     { e.preventDefault(); togglePanel(); return; }
    if (e.key==='w')     { e.preventDefault(); if (activeTab) closeTab(activeTab); return; }
    if (e.key==='=')     { e.preventDefault(); increaseFontSize(); return; }
    if (e.key==='-')     { e.preventDefault(); decreaseFontSize(); return; }
    if (e.key==='0')     { e.preventDefault(); resetFontSize(); return; }
    if (e.shiftKey && e.key==='=')  { e.preventDefault(); increaseUIFontSize(); return; }
    if (e.shiftKey && e.key==='-')  { e.preventDefault(); decreaseUIFontSize(); return; }
    if (e.key==='h')     { e.preventDefault(); findReplace(); return; }
    if (e.key==='g')     { e.preventDefault(); goToLine(); return; }
  }
  if (e.altKey) {
    if (e.key==='z') { e.preventDefault(); toggleWordWrap(); return; }
    if (e.shiftKey && e.key==='F') { e.preventDefault(); formatCode(); return; }
    if (e.shiftKey && e.key==='D') { e.preventDefault(); duplicateLine(); return; }
  }
});

// Close menus on Escape
document.addEventListener('keydown', e => {
  if (e.key==='Escape') {
    document.getElementById('ctx-menu').classList.remove('visible');
    document.querySelectorAll('.menu-item').forEach(m=>m.classList.remove('open'));
  }
});

// ═══════════════════════════════════════════════════════════════════
//  INLINE RENAME (dblclick)
// ═══════════════════════════════════════════════════════════════════
function startRename(el, path) {
  const nameEl = el.querySelector('.tree-name');
  const old    = nameEl.textContent;
  nameEl.contentEditable = 'true';
  nameEl.classList.add('editing');
  nameEl.focus();
  const range = document.createRange(); range.selectNodeContents(nameEl);
  window.getSelection().removeAllRanges(); window.getSelection().addRange(range);

  async function commit() {
    const newName = nameEl.textContent.trim();
    nameEl.contentEditable='false'; nameEl.classList.remove('editing');
    if (!newName || newName===old) { nameEl.textContent=old; return; }
    const dir = path.split('/').slice(0,-1).join('/')||'/';
    const newPath = joinPath(dir, newName);
    try {
      await fsRename(path, newPath);
      const tab = openTabs.find(t=>t.path===path);
      if (tab) { tab.path=newPath; if(activeTab===path) activeTab=newPath; updateStatusBar(newPath); }
      renderTabs(); refreshTree();
    } catch(e) { termLog('error','Rename failed: '+e.message); nameEl.textContent=old; refreshTree(); }
  }

  nameEl.addEventListener('blur', commit, {once:true});
  nameEl.addEventListener('keydown', e=>{
    if (e.key==='Enter') { e.preventDefault(); nameEl.blur(); }
    if (e.key==='Escape'){ nameEl.textContent=old; nameEl.blur(); }
  });
}

// ═══════════════════════════════════════════════════════════════════
//  MENU TOGGLE (click-to-open)
// ═══════════════════════════════════════════════════════════════════
function toggleMenu(el) {
  const isOpen = el.classList.contains('open');
  document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('open'));
  if (!isOpen) el.classList.add('open');
}

// Close menu when a dd-item is clicked
document.addEventListener('click', e => {
  if (e.target.closest('.dd-item')) {
    document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('open'));
  }
}, true);

// ═══════════════════════════════════════════════════════════════════
//  MENU CLICK OUTSIDE
// ═══════════════════════════════════════════════════════════════════
document.addEventListener('click', e=>{
  if (!e.target.closest('.menu-item')) {
    document.querySelectorAll('.menu-item').forEach(m=>m.classList.remove('open'));
  }
});

// ═══════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════
//  ZIP IMPORT / EXPORT
// ═══════════════════════════════════════════════════════════════════

function zipFmtBytes(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
  return (b / 1048576).toFixed(1) + ' MB';
}

function zipGetMime(ext) {
  var map = { png:'image/png', jpg:'image/jpeg', jpeg:'image/jpeg', gif:'image/gif',
    webp:'image/webp', bmp:'image/bmp', ico:'image/x-icon', svg:'image/svg+xml',
    woff:'font/woff', woff2:'font/woff2', ttf:'font/ttf', eot:'application/vnd.ms-fontobject',
    mp3:'audio/mpeg', mp4:'video/mp4', wav:'audio/wav', ogg:'audio/ogg', pdf:'application/pdf' };
  return map[ext] || 'application/octet-stream';
}

// progress modal
function zipModalShow(filename) {
  document.getElementById('zip-modal-filename').textContent = filename;
  document.getElementById('zip-progress-bar').style.width = '0%';
  document.getElementById('zip-progress-label').textContent = 'Reading archive…';
  document.getElementById('zip-file-list').innerHTML = '';
  document.getElementById('zip-modal-overlay').classList.add('visible');
}
function zipModalProgress(pct, label) {
  document.getElementById('zip-progress-bar').style.width = pct + '%';
  document.getElementById('zip-progress-label').textContent = label;
}
function zipModalAddFile(path, status, size) {
  var el  = document.createElement('div');
  el.className = 'zfl-item';
  var cls = status === 'ok' ? 'zfl-ok' : status === 'skip' ? 'zfl-skip' : 'zfl-err';
  var chr = status === 'ok' ? '✓'  : status === 'skip' ? '—'   : '✗';
  el.innerHTML = '<span class="' + cls + '">' + chr + '</span>'
    + '<span class="zfl-path">' + escH(path) + '</span>'
    + (size != null ? '<span class="zfl-size">' + zipFmtBytes(size) + '</span>' : '');
  var list = document.getElementById('zip-file-list');
  list.appendChild(el);
  list.scrollTop = list.scrollHeight;
}
function zipModalHide() {
  document.getElementById('zip-modal-overlay').classList.remove('visible');
}

// core handleZipFile
async function handleZipFile(file, opts) {
  opts = opts || {};
  var targetDir  = opts.targetDir  || '/';
  var clearFirst = opts.clearFirst || false;

  if (!file || !file.name.toLowerCase().endsWith('.zip')) {
    termLog('error', 'Not a ZIP file: ' + (file ? file.name : '?'));
    return;
  }
  zipModalShow(file.name);
  try {
    // read as arraybuffer
    var buf = await new Promise(function(res, rej) {
      var r = new FileReader();
      r.onload  = function(e) { res(e.target.result); };
      r.onerror = rej;
      r.readAsArrayBuffer(file);
    });
    zipModalProgress(10, 'Parsing ZIP…');
    var zip = await JSZip.loadAsync(buf);

    // collect entries
    var entries = [];
    zip.forEach(function(relPath, entry) { if (!entry.dir) entries.push({ relPath: relPath, entry: entry }); });
    termLog('sys', 'ZIP: "' + file.name + '" — ' + entries.length + ' file(s)');

    // optionally wipe FS first
    if (clearFirst) {
      zipModalProgress(15, 'Clearing filesystem…');
      var top = await fsReaddir('/').catch(function(){ return []; });
      for (var j = 0; j < top.length; j++) {
        if (top[j].charAt(0) === '.') continue;
        var tp = '/' + top[j];
        var ts = await fsStat(tp).catch(function(){ return null; });
        if (!ts) continue;
        if (ts.isDirectory()) await fsRmdirR(tp); else await fsUnlink(tp).catch(function(){});
      }
      openTabs.forEach(function(t){ t.model.dispose(); });
      openTabs = []; activeTab = null;
      monacoEditor.setModel(null);
      document.getElementById('empty-state').style.display = 'flex';
      renderTabs();
    }

    // detect & strip common root prefix
    var prefix = '';
    if (entries.length > 1) {
      var fp = entries[0].relPath.replace(/\\/g, '/');
      var si = fp.indexOf('/');
      if (si > 0) {
        var cand = fp.slice(0, si + 1);
        if (entries.every(function(e) { return e.relPath.replace(/\\/g,'/').startsWith(cand); }))
          prefix = cand;
      }
    }

    var BINARY = { png:1, jpg:1, jpeg:1, gif:1, webp:1, bmp:1, ico:1,
                   woff:1, woff2:1, ttf:1, eot:1, mp3:1, mp4:1, wav:1,
                   ogg:1, pdf:1, zip:1, gz:1 };
    var done = 0;
    for (var i = 0; i < entries.length; i++) {
      var rel  = entries[i].relPath.replace(/\\/g, '/').replace(/^\/+/, '');
      var ze   = entries[i].entry;
      if (prefix && rel.startsWith(prefix)) rel = rel.slice(prefix.length);
      if (!rel) continue;
      var dest = joinPath(targetDir, rel);
      var ext  = rel.split('.').pop().toLowerCase();
      try {
        var txt;
        if (BINARY[ext]) {
          var b64 = await ze.async('base64');
          txt = 'data:' + zipGetMime(ext) + ';base64,' + b64;
          zipModalAddFile(dest, 'ok', Math.round(b64.length * 0.75));
        } else {
          txt = await ze.async('string');
          zipModalAddFile(dest, 'ok', txt.length);
        }
        await fsWriteFileSafe(dest, txt);
        done++;
      } catch(e) {
        termLog('error', 'ZIP: failed ' + dest + ': ' + e.message);
        zipModalAddFile(dest, 'err', null);
      }
      zipModalProgress(20 + Math.round((done / entries.length) * 75),
        'Writing files… (' + done + '/' + entries.length + ')');
    }

    zipModalProgress(100, 'Done — ' + done + ' file(s) imported');
    termLog('sys', 'ZIP import complete: ' + done + '/' + entries.length + ' files');
    await refreshTree();

    // auto-open index.html or first file
    var opens = [ joinPath(targetDir, 'index.html') ];
    if (entries.length) opens.push(joinPath(targetDir, entries[0].relPath.replace(/\\/g,'/').replace(/^\/+/,'')));
    for (var k = 0; k < opens.length; k++) {
      if (opens[k] === '/') continue;
      if (await fsExists(opens[k])) {
        var st = await fsStat(opens[k]).catch(function(){ return null; });
        if (st && !st.isDirectory()) { await openFile(opens[k]); break; }
      }
    }
    setTimeout(zipModalHide, 1800);

  } catch(e) {
    zipModalHide();
    termLog('error', 'ZIP import failed: ' + e.message);
    console.error(e);
  }
}

// importZip — file picker
function importZip(targetDir) {
  targetDir = targetDir || '/';
  var inp = document.createElement('input');
  inp.type   = 'file';
  inp.accept = '.zip,application/zip,application/x-zip-compressed';
  inp.onchange = async function() {
    var file = inp.files[0]; if (!file) return;
    await handleZipFile(file, { clearFirst: false, targetDir: targetDir });
  };
  inp.click();
}

// exportZip — pack FS into downloadable zip
async function exportZip() {
  termLog('sys', 'Building ZIP archive…');
  var zip = new JSZip();

  async function addDir(dir, folder) {
    var items = await fsReaddir(dir).catch(function(){ return []; });
    for (var i = 0; i < items.length; i++) {
      if (items[i].charAt(0) === '.') continue;
      var p    = joinPath(dir, items[i]);
      var stat = await fsStat(p).catch(function(){ return null; });
      if (!stat) continue;
      if (stat.isDirectory()) {
        await addDir(p, folder.folder(items[i]));
      } else {
        try {
          var c = await fsReadFile(p);
          if (c.startsWith('data:') && c.indexOf(';base64,') !== -1) {
            folder.file(items[i], c.split(';base64,')[1], { base64: true });
          } else {
            folder.file(items[i], c);
          }
        } catch(e) { termLog('warn', 'ZIP export: skipped ' + p + ' (' + e.message + ')'); }
      }
    }
  }
  await addDir('/', zip);

  var blob = await zip.generateAsync(
    { type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } },
    function(m) { termLog('sys', 'Compressing… ' + m.percent.toFixed(0) + '%'); }
  );
  var name = 'void-project-' + new Date().toISOString().slice(0,10) + '.zip';
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  termLog('sys', 'ZIP exported: ' + name + ' (' + (blob.size/1024).toFixed(1) + ' KB)');
}

// drag-and-drop ZIP onto window
(function() {
  var overlay   = document.getElementById('zip-drop-overlay');
  var dragDepth = 0;
  function looksLikeZip(e) {
    return Array.from((e.dataTransfer || {items:[]}).items || []).some(function(i) {
      return i.kind === 'file' && (i.type.indexOf('zip') !== -1 || i.type === '');
    });
  }
  document.addEventListener('dragenter', function(e) {
    e.preventDefault(); dragDepth++;
    if (dragDepth === 1) {
      overlay.classList.remove('reject');
      overlay.classList.add('active');
      if (!looksLikeZip(e)) overlay.classList.add('reject');
    }
  });
  document.addEventListener('dragover', function(e) {
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
  });
  document.addEventListener('dragleave', function(e) {
    dragDepth--;
    if (dragDepth <= 0) { dragDepth = 0; overlay.classList.remove('active', 'reject'); }
  });
  document.addEventListener('drop', async function(e) {
    e.preventDefault(); dragDepth = 0;
    overlay.classList.remove('active', 'reject');
    var files = Array.from(e.dataTransfer.files);
    var zips  = files.filter(function(f) { return f.name.toLowerCase().endsWith('.zip'); });
    if (!zips.length) {
      termLog('warn', 'Dropped file is not a ZIP. Use File > Import File for individual files.');
      return;
    }
    for (var i = 0; i < zips.length; i++) { await handleZipFile(zips[i], { clearFirst: false }); }
  });
})();

// ═══════════════════════════════════════════════════════════════════
//  MIME TYPE MAP (full coverage)
// ═══════════════════════════════════════════════════════════════════
const MIME_MAP = {
  // Text
  html:'text/html', htm:'text/html', xhtml:'application/xhtml+xml',
  css:'text/css', js:'text/javascript', mjs:'text/javascript',
  ts:'text/typescript', jsx:'text/javascript', tsx:'text/javascript',
  json:'application/json', jsonld:'application/ld+json',
  xml:'application/xml', svg:'image/svg+xml',
  txt:'text/plain', md:'text/markdown', markdown:'text/markdown',
  csv:'text/csv', tsv:'text/tab-separated-values',
  yaml:'text/yaml', yml:'text/yaml', toml:'text/plain',
  ini:'text/plain', conf:'text/plain', sh:'text/x-shellscript',
  py:'text/x-python', rb:'text/x-ruby', php:'text/x-php',
  java:'text/x-java', c:'text/x-c', cpp:'text/x-c++', h:'text/x-c',
  rs:'text/x-rust', go:'text/x-go', swift:'text/x-swift',
  kt:'text/x-kotlin', dart:'text/x-dart', r:'text/x-r',
  sql:'text/x-sql', graphql:'application/graphql',
  wasm:'application/wasm',
  // Images
  png:'image/png', jpg:'image/jpeg', jpeg:'image/jpeg',
  gif:'image/gif', webp:'image/webp', avif:'image/avif',
  bmp:'image/bmp', ico:'image/x-icon', tiff:'image/tiff',
  // Fonts
  woff:'font/woff', woff2:'font/woff2', ttf:'font/ttf',
  otf:'font/otf', eot:'application/vnd.ms-fontobject',
  // Audio / Video
  mp3:'audio/mpeg', wav:'audio/wav', ogg:'audio/ogg',
  flac:'audio/flac', aac:'audio/aac', opus:'audio/opus',
  mp4:'video/mp4', webm:'video/webm', ogv:'video/ogg',
  avi:'video/x-msvideo', mov:'video/quicktime',
  // Documents / archives
  pdf:'application/pdf', zip:'application/zip',
  gz:'application/gzip', tar:'application/x-tar',
  // Data
  wasm:'application/wasm',
};
function getMime(ext) {
  return MIME_MAP[ext.toLowerCase()] || 'application/octet-stream';
}

// ═══════════════════════════════════════════════════════════════════
//  VIRTUAL FETCH SERVER
//  Injects a postMessage-based fetch() shim into the preview iframe
//  so user code can fetch('/any/vfs/file') and get real responses
//  with correct MIME types and binary support.
// ═══════════════════════════════════════════════════════════════════
// Build the fetch+XHR bridge as a plain string (NOT a template literal)
// so no ${} expressions or backticks can be accidentally interpolated when injected into srcdoc.
function buildFetchBridge() {
  return '(function(){'
    + 'var pf={},fi=0;'
    + 'window.addEventListener("message",function(e){'
    +   'var d=e.data;'
    +   'if(!d||d.__type!=="__voidFetchResp")return;'
    +   'var cb=pf[d.id];if(!cb)return;'
    +   'delete pf[d.id];'
    +   'if(d.error){cb.rej(new TypeError(d.error));return;}'
    +   'var body=d.base64?Uint8Array.from(atob(d.body),function(c){return c.charCodeAt(0);}).buffer:d.body;'
    +   'var resp=new Response(body,{status:d.status,headers:{"Content-Type":d.mime}});'
    +   'try{Object.defineProperty(resp,"url",{value:d.url});}catch(e){}'
    +   'cb.res(resp);'
    + '});'
    + 'var _f=window.fetch;'
    + 'window.fetch=function(url,opts){'
    +   'var us=typeof url==="string"?url:(url&&url.url?url.url:String(url));'
    +   'if(/^(https?|data|blob):/.test(us))return _f.apply(window,arguments);'
    +   'return new Promise(function(res,rej){'
    +     'var id=++fi;pf[id]={res:res,rej:rej};'
    +     'try{parent.postMessage({__type:"__voidFetchReq",id:id,url:us},"*");}catch(e){rej(new TypeError(e.message));}'
    +   '});'
    + '};'
    + 'var _X=XMLHttpRequest;'
    + 'window.XMLHttpRequest=function(){'
    +   'var xhr=new _X();'
    +   'var _o=xhr.open.bind(xhr),_s=xhr.send.bind(xhr),_vi;'
    +   'xhr.open=function(m,url,a){'
    +     'var us=String(url);'
    +     'if(/^(https?|data|blob):/.test(us)){_vi=null;return _o(m,url,a!==false);}' 
    +     '_vi=us;'
    +   '};'
    +   'xhr.send=function(b){'
    +     'if(!_vi)return _s(b);'
    +     'var u=_vi;_vi=null;'
    +     'window.fetch(u).then(function(r){'
    +       'return r.text().then(function(t){'
    +         'Object.defineProperty(xhr,"readyState",{get:function(){return 4;},configurable:true});'
    +         'Object.defineProperty(xhr,"status",{get:function(){return r.status;},configurable:true});'
    +         'Object.defineProperty(xhr,"responseText",{get:function(){return t;},configurable:true});'
    +         'Object.defineProperty(xhr,"response",{get:function(){return t;},configurable:true});'
    +         'if(typeof xhr.onreadystatechange==="function")xhr.onreadystatechange();'
    +         'if(typeof xhr.onload==="function")xhr.onload({target:xhr});'
    +       '});'
    +     '}).catch(function(e){'
    +       'Object.defineProperty(xhr,"readyState",{get:function(){return 4;},configurable:true});'
    +       'Object.defineProperty(xhr,"status",{get:function(){return 0;},configurable:true});'
    +       'if(typeof xhr.onerror==="function")xhr.onerror(e);'
    +     '});'
    +   '};'
    +   'return xhr;'
    + '};'
    + '})();';
}

// Handle fetch requests from the preview iframe
window.addEventListener('message', async function(e) {
  const d = e.data;
  if (!d || d.__type !== '__voidFetchReq') return;
  const { id, url } = d;
  const frame = document.getElementById('preview-frame');
  if (!frame.contentWindow || e.source !== frame.contentWindow) return;

  try {
    let path = url.split('?')[0].split('#')[0];
    if (!path.startsWith('/')) path = '/' + path;
    const ext = path.split('.').pop().toLowerCase();
    const mime = getMime(ext);
    const isBinary = /^(image|audio|video|font)\//.test(mime)
      || mime === 'application/pdf' || mime === 'application/zip' || mime === 'application/wasm';

    let body = null, base64 = false, size = 0;
    const stripped = path.replace(/^\/+/, '');

    // 0. Live editor — always freshest
    if (!isBinary) {
      const live = getLiveContent(path) ?? getLiveContent(stripped);
      if (live !== null) { body = live; size = live.length; }
    }

    // 1. Check shared file map
    if (body === null && sharedFileMap && sharedFileMap.size > 0) {
      let entry = sharedFileMap.get(stripped);
      if (!entry) {
        // Try tail match for relative-path fetches
        for (const [vp, ent] of sharedFileMap) {
          if (vp.endsWith('/' + stripped) || vp === stripped) { entry = ent; break; }
        }
      }
      if (entry) {
        try {
          const file = await entry.handle.getFile();
          if (isBinary) {
            const buf = await file.arrayBuffer();
            const bytes = new Uint8Array(buf);
            let b64 = '';
            const chunk = 8192;
            for (let i = 0; i < bytes.length; i += chunk)
              b64 += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i+chunk, bytes.length)));
            body = btoa(b64); base64 = true; size = file.size;
          } else {
            body = await file.text(); size = body.length;
          }
        } catch(e2) { body = null; }
      }
    }

    // 2. Fall back to VFS
    if (body === null) {
      const vfsPaths = [path, '/' + stripped];
      for (const vp of vfsPaths) {
        if (!await fsExists(vp)) continue;
        const content = await fsReadFile(vp);
        if (isBinary && content.startsWith('data:') && content.includes(';base64,')) {
          body = content.split(';base64,')[1]; base64 = true; size = Math.round(body.length * 0.75);
        } else {
          body = content; size = content.length;
        }
        break;
      }
    }

    if (body === null) {
      frame.contentWindow.postMessage({ __type:'__voidFetchResp', id, url, status:404, mime:'text/plain', body:'Not Found', base64:false, size:9 }, '*');
      return;
    }
    frame.contentWindow.postMessage({ __type:'__voidFetchResp', id, url, status:200, mime, body, base64, size }, '*');
  } catch(err) {
    try { e.source.postMessage({ __type:'__voidFetchResp', id, url, error: err.message }, '*'); } catch(_) {}
  }
});

// ═══════════════════════════════════════════════════════════════════
//  FILE SYSTEM ACCESS API — Shared Real Files
//  Key design:
//  - sharedRoots: array of { name, handle, kind:'dir'|'file' }
//  - sharedFileMap: Map of vPath → { handle, rootName } for ALL files
//  - sharedFiles: array of open file records (content cached in memory)
//  - file:// and relative url() refs resolved directly from handles
// ═══════════════════════════════════════════════════════════════════
const sharedFSAP = typeof window.showOpenFilePicker === 'function';

let sharedRoots    = [];          // top-level opened dirs/files
let sharedFileMap  = new Map();   // vPath → { handle, rootName, relPath }
let sharedFiles    = [];          // open file records with content
let sharedActiveId = null;
let sharedTreeExp  = new Set();   // expanded dir paths in tree

// ── Render the full tree ─────────────────────────────────────────
function sharedRender() {
  const list = document.getElementById('shared-files-list');
  const warn = document.getElementById('shared-api-warning');
  if (!sharedFSAP) warn.style.display = 'block';

  if (!sharedRoots.length) {
    list.innerHTML = '<div class="shared-empty">No real files open.<br><br>'
      + 'Use <b>📄</b> to pick file(s) or <b>📁</b> for a whole folder.<br><br>'
      + 'Files open with <b>full read &amp; write</b> access to your actual disk.<br><br>'
      + '<span style="color:var(--accent-dim);font-size:10px">Fonts &amp; assets referenced by file:// in CSS<br>are automatically served from disk.</span></div>';
    return;
  }

  list.innerHTML = '';
  for (const root of sharedRoots) {
    if (root.kind === 'file') {
      // Single file root
      const f = sharedFiles.find(x => x.rootName === root.name && x.path === root.name);
      _sharedRenderFileRow(list, root.name, f ? f.id : null, f ? f.dirty : false, 0);
    } else {
      // Directory root — render as collapsible tree
      _sharedRenderDirNode(list, root.name, root.handle, root.name, 0);
    }
  }
}

function _sharedRenderDirNode(container, label, dirHandle, vDirPath, depth) {
  const expanded = sharedTreeExp.has(vDirPath);

  const row = document.createElement('div');
  row.className = 'shared-item shared-dir-row';
  row.style.paddingLeft = (depth * 14 + 6) + 'px';
  row.innerHTML = '<span class="si-icon">' + (expanded ? '📂' : '📁') + '</span>'
    + '<span class="si-name" style="font-weight:600;color:var(--text)">' + escH(label) + '</span>';
  row.addEventListener('click', function(e) {
    e.stopPropagation();
    if (sharedTreeExp.has(vDirPath)) sharedTreeExp.delete(vDirPath);
    else sharedTreeExp.add(vDirPath);
    sharedRender();
  });
  container.appendChild(row);

  if (!expanded) return;

  // Collect children from sharedFileMap for this dir
  const children = { dirs: new Map(), files: [] };
  for (const [vPath, entry] of sharedFileMap) {
    if (!vPath.startsWith(vDirPath + '/')) continue;
    const rest = vPath.slice(vDirPath.length + 1); // relative to this dir
    if (!rest) continue;
    const slash = rest.indexOf('/');
    if (slash === -1) {
      // direct file child
      files_push: {
        const f = sharedFiles.find(x => x.vPath === vPath);
        children.files.push({ name: rest, vPath, id: f ? f.id : null, dirty: f ? f.dirty : false, entry });
      }
    } else {
      // sub-directory — only capture top-level subdir name
      const subdirName = rest.slice(0, slash);
      const subdirVPath = vDirPath + '/' + subdirName;
      if (!children.dirs.has(subdirVPath)) {
        children.dirs.set(subdirVPath, { name: subdirName, vPath: subdirVPath });
      }
    }
  }

  // Render subdirs first, then files
  const sortedDirs = [...children.dirs.values()].sort((a,b) => a.name.localeCompare(b.name));
  for (const dir of sortedDirs) {
    _sharedRenderDirNode(container, dir.name, null, dir.vPath, depth + 1);
  }
  const sortedFiles = children.files.sort((a,b) => a.name.localeCompare(b.name));
  for (const child of sortedFiles) {
    _sharedRenderFileRow(container, child.name, child.id, child.dirty, depth + 1, child.vPath);
  }
}

function _sharedRenderFileRow(container, name, id, dirty, depth, vPath) {
  const el = document.createElement('div');
  el.className = 'shared-item' + (id && id === sharedActiveId ? ' selected' : '');
  el.style.paddingLeft = (depth * 14 + 6) + 'px';
  el.innerHTML = '<span class="si-icon">' + getFileIconPlain(name) + '</span>'
    + '<span class="si-name" title="' + escH(vPath || name) + '">' + escH(name) + '</span>'
    + (id ? (dirty ? '<span class="si-badge dirty">●</span>' : '<span class="si-badge">✓</span>') : '');
  if (id) {
    el.addEventListener('click', () => sharedOpenInEditor(id));
  } else if (vPath) {
    // Not yet loaded into memory — load on click
    el.addEventListener('click', () => sharedLoadAndOpen(vPath));
  }
  container.appendChild(el);
}

// ── Open single files ────────────────────────────────────────────
async function sharedOpenFile() {
  if (!sharedFSAP) { termLog('warn', 'File System Access API not supported. Use Chrome or Edge 86+.'); return; }
  try {
    const handles = await window.showOpenFilePicker({ multiple: true });
    for (const handle of handles) {
      const vPath = handle.name;
      if (sharedFileMap.has(vPath)) continue;
      sharedFileMap.set(vPath, { handle, rootName: handle.name, relPath: handle.name });
      sharedRoots.push({ name: handle.name, handle, kind: 'file' });
    }
    sharedRender();
    // Load and open the last one
    const last = handles[handles.length - 1];
    if (last) await sharedLoadAndOpen(last.name);
  } catch(e) {
    if (e.name !== 'AbortError') termLog('error', 'Open file failed: ' + e.message);
  }
}

// ── Open folder ──────────────────────────────────────────────────
async function sharedOpenDir() {
  if (!sharedFSAP) { termLog('warn', 'File System Access API not supported. Use Chrome or Edge 86+.'); return; }
  try {
    const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
    const rootName = dirHandle.name;
    termLog('sys', 'Opened folder: ' + rootName);

    // Remove existing root with same name if re-opened
    sharedRoots = sharedRoots.filter(r => r.name !== rootName);
    // Clean old entries from map
    for (const k of sharedFileMap.keys()) {
      if (sharedFileMap.get(k).rootName === rootName) sharedFileMap.delete(k);
    }

    sharedRoots.push({ name: rootName, handle: dirHandle, kind: 'dir' });
    sharedTreeExp.add(rootName); // auto-expand root

    // Walk and register ALL file handles (no content loading yet)
    await sharedIndexDir(dirHandle, rootName, rootName);

    termLog('sys', 'Indexed ' + [...sharedFileMap.values()].filter(e=>e.rootName===rootName).length + ' files in ' + rootName);
    sharedRender();
  } catch(e) {
    if (e.name !== 'AbortError') termLog('error', 'Open folder failed: ' + e.message);
  }
}

// Index all file handles recursively — NO content loading (lazy)
async function sharedIndexDir(dirHandle, rootName, vDirPath) {
  const skip = new Set(['.git', '.DS_Store', 'node_modules', '.vscode', '.idea', '__pycache__']);
  const entries = [];
  for await (const [name, handle] of dirHandle) entries.push([name, handle]);
  entries.sort((a,b) => a[0].localeCompare(b[0]));

  for (const [name, handle] of entries) {
    if (skip.has(name)) continue;
    const vPath = vDirPath + '/' + name;
    if (handle.kind === 'directory') {
      await sharedIndexDir(handle, rootName, vPath);
    } else {
      sharedFileMap.set(vPath, { handle, rootName, relPath: vPath.slice(rootName.length + 1) });
    }
  }
}

// ── Load file content from handle, then open in editor ──────────
async function sharedLoadAndOpen(vPath) {
  // Already loaded?
  const existing = sharedFiles.find(f => f.vPath === vPath);
  if (existing) { await sharedOpenInEditor(existing.id); return; }

  const entry = sharedFileMap.get(vPath);
  if (!entry) { termLog('error', 'No handle for: ' + vPath); return; }

  const { handle, rootName, relPath } = entry;
  const file = await handle.getFile();
  const isBinary = /\.(png|jpg|jpeg|gif|webp|bmp|ico|woff2?|ttf|otf|mp3|mp4|wav|ogg|pdf|zip|gz|wasm|avif|svg)$/i.test(handle.name);

  let content;
  if (isBinary) {
    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let b64 = '';
    const chunk = 8192;
    for (let i = 0; i < bytes.length; i += chunk) {
      b64 += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i+chunk, bytes.length)));
    }
    const ext = handle.name.split('.').pop().toLowerCase();
    content = 'data:' + getMime(ext) + ';base64,' + btoa(b64);
  } else {
    content = await file.text();
  }

  const id = 'sf_' + Date.now() + '_' + Math.random().toString(36).slice(2);
  const record = {
    id, name: handle.name, handle, rootName,
    vPath,            // canonical virtual path e.g. "myproject/src/app.js"
    relPath,          // path relative to root e.g. "src/app.js"
    content, dirty: false, isBinary,
    listenerDispose: null
  };
  sharedFiles.push(record);

  // Write to VFS at /<vPath> so preview fetch bridge can serve it
  await fsWriteFileSafe('/' + vPath, content);

  termLog('sys', 'Loaded: ' + vPath + ' (' + (file.size/1024).toFixed(1) + ' KB)');
  await sharedOpenInEditor(id);
  sharedRender();
}

async function sharedOpenInEditor(id) {
  const f = sharedFiles.find(x => x.id === id);
  if (!f) return;
  sharedActiveId = id;

  const editorPath = '/' + f.vPath;

  if (!f.isBinary) {
    let tab = openTabs.find(t => t.path === editorPath);
    if (!tab) {
      const lang = getLang(editorPath);
      const uriStr = 'inmemory://disk/' + f.vPath;
      const uri = monaco.Uri.parse(uriStr);
      let model = monaco.editor.getModel(uri);
      if (!model) model = monaco.editor.createModel(f.content, lang, uri);
      else model.setValue(f.content);

      tab = { path: editorPath, model, dirty: false, sharedId: id };
      openTabs.push(tab);

      // Attach ONE change listener per model
      const disposable = model.onDidChangeContent(() => {
        f.content = model.getValue();
        if (!f.dirty) {
          f.dirty = true;
          tab.dirty = true;
          renderTabs();
          sharedRender();
        }
        if (_liveReload) {
          clearTimeout(_liveDebounce);
          _liveDebounce = setTimeout(_liveRun, LIVE_DEBOUNCE_MS);
        }
      });
      f.listenerDispose = disposable;
    } else {
      tab.sharedId = id;
    }

    activeTab = editorPath;
    monacoEditor.setModel(tab.model);
    document.getElementById('empty-state').style.display = 'none';
    renderTabs();
    updateStatusBar(editorPath);
    monacoEditor.focus();
  } else {
    termLog('info', 'Binary: ' + f.name + ' — served from disk via /' + f.vPath);
  }
  sharedRender();
}

// ── Save back to real disk ───────────────────────────────────────
async function sharedSaveActive() {
  let f = sharedFiles.find(x => x.id === sharedActiveId);
  if (!f) {
    const tab = openTabs.find(t => t.path === activeTab && t.sharedId);
    if (tab) f = sharedFiles.find(x => x.id === tab.sharedId);
  }
  if (!f) { termLog('warn', 'No shared file is active.'); return; }
  await sharedWriteFile(f);
}

async function sharedSaveAll() {
  const dirty = sharedFiles.filter(f => f.dirty);
  if (!dirty.length) { termLog('info', 'All shared files are clean.'); return; }
  for (const f of dirty) await sharedWriteFile(f);
}

async function sharedWriteFile(f) {
  try {
    const editorPath = '/' + f.vPath;
    const tab = openTabs.find(t => t.path === editorPath);
    if (tab) f.content = tab.model.getValue();

    const writable = await f.handle.createWritable();
    if (f.isBinary && f.content.startsWith('data:') && f.content.includes(';base64,')) {
      const b64 = f.content.split(';base64,')[1];
      const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
      await writable.write(bytes);
    } else {
      await writable.write(f.content);
    }
    await writable.close();
    f.dirty = false;
    if (tab) tab.dirty = false;
    // Also sync VFS
    await fsWriteFileSafe('/' + f.vPath, f.content);
    termLog('sys', 'Saved to disk: ' + f.name);
    renderTabs();
    sharedRender();
  } catch(e) {
    termLog('error', 'Save failed (' + f.name + '): ' + e.message);
  }
}

// ── Read binary file directly from disk handle (for CSS url() resolver) ──
async function sharedReadBinaryHandle(vPath) {
  const entry = sharedFileMap.get(vPath);
  if (!entry) return null;
  try {
    const file = await entry.handle.getFile();
    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);
    let b64 = '';
    const chunk = 8192;
    for (let i = 0; i < bytes.length; i += chunk) {
      b64 += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i+chunk, bytes.length)));
    }
    const ext = entry.handle.name.split('.').pop().toLowerCase();
    return 'data:' + getMime(ext) + ';base64,' + btoa(b64);
  } catch(e) {
    return null;
  }
}

async function sharedImportToVFS() {
  let count = 0;
  for (const f of sharedFiles) {
    await fsWriteFileSafe('/' + f.relPath, f.content);
    count++;
  }
  await refreshTree();
  termLog('sys', 'Imported ' + count + ' shared file(s) to VFS.');
  setActivity('files');
}

function sharedClearAll() {
  if (!sharedRoots.length) return;
  showConfirm('Remove all shared files?', 'Disk files are not deleted.', () => {
    for (const f of sharedFiles) {
      if (f.listenerDispose) try { f.listenerDispose.dispose(); } catch(e) {}
    }
    sharedFiles = [];
    sharedFileMap.clear();
    sharedRoots = [];
    sharedActiveId = null;
    sharedTreeExp.clear();
    sharedRender();
  });
}


// ═══════════════════════════════════════════════════════════════════
//  WASM RUNNER
//  Loads a .wasm file from VFS or shared map, instantiates it with
//  a full WASI-like import object, and logs exports to terminal.
// ═══════════════════════════════════════════════════════════════════
async function runWasm(path) {
  switchPanelTab('terminal');
  termLog('sys', '⬡ WASM: loading ' + path.split('/').pop());
  let bytes;
  try {
    const entry = sharedMapLookup(path.replace(/^\/+/,''));
    if (entry) {
      const file = await entry.handle.getFile();
      bytes = await file.arrayBuffer();
    } else {
      bytes = await readRawBytes(path);
    }
    if (!bytes || bytes.byteLength === 0) throw new Error('File is empty or not found');
  } catch(e) {
    termLog('error', 'WASM load failed: ' + e.message); return;
  }

  const wasmMemory = new WebAssembly.Memory({ initial: 256, maximum: 1024 });
  const wasmTable  = new WebAssembly.Table({ element: 'anyfunc', initial: 64 });
  const textDec    = new TextDecoder();

  function readStr(ptr, mem) {
    const view = new Uint8Array(mem.buffer);
    let end = ptr;
    while (end < view.length && view[end]) end++;
    return textDec.decode(view.subarray(ptr, end));
  }

  const importObj = {
    env: {
      memory: wasmMemory, table: wasmTable,
      __memory_base: 0, __table_base: 0,
      printf:  (ptr) => { termLog('log', readStr(ptr, wasmMemory)); return 0; },
      puts:    (ptr) => { termLog('log', readStr(ptr, wasmMemory)); return 0; },
      putchar: (c)   => { termLog('log', String.fromCharCode(c)); return c; },
      fprintf: () => 0, abort: () => { termLog('error', 'WASM abort()'); },
      exit:    (c) => { termLog('sys', 'WASM exit(' + c + ')'); },
      pow: Math.pow, sqrt: Math.sqrt, floor: Math.floor, ceil: Math.ceil,
      fabs: Math.abs, sin: Math.sin, cos: Math.cos, tan: Math.tan,
      exp: Math.exp, log: Math.log, fmod: (a,b) => a % b,
      memcpy: (dst,src,n) => { new Uint8Array(wasmMemory.buffer).copyWithin(dst,src,src+n); return dst; },
      memset: (dst,val,n) => { new Uint8Array(wasmMemory.buffer).fill(val,dst,dst+n); return dst; },
      memcmp: (a,b,n) => {
        const v=new Uint8Array(wasmMemory.buffer);
        for(let i=0;i<n;i++){if(v[a+i]!==v[b+i])return v[a+i]-v[b+i];} return 0;
      },
      malloc: () => 0, free: () => {},
      __cxa_throw: () => {}, __cxa_allocate_exception: () => 0, llvm_trap: () => {},
    },
    wasi_snapshot_preview1: {
      fd_write: (fd, iovPtr, iovLen, nwritten) => {
        const mem = new DataView(wasmMemory.buffer);
        let out = '';
        for (let i=0;i<iovLen;i++) {
          const ptr = mem.getUint32(iovPtr+i*8,true);
          const len = mem.getUint32(iovPtr+i*8+4,true);
          out += textDec.decode(new Uint8Array(wasmMemory.buffer,ptr,len));
        }
        if (out) termLog(fd===2?'error':'log', out.replace(/\n$/,''));
        if (nwritten) new DataView(wasmMemory.buffer).setUint32(nwritten,out.length,true);
        return 0;
      },
      fd_read: ()=>0, fd_close: ()=>0, fd_seek: ()=>0,
      fd_prestat_get: ()=>8, fd_prestat_dir_name: ()=>8, path_open: ()=>8,
      environ_sizes_get: (cPtr,sPtr) => {
        const d=new DataView(wasmMemory.buffer);
        d.setUint32(cPtr,0,true); d.setUint32(sPtr,0,true); return 0;
      },
      environ_get: ()=>0,
      args_sizes_get: (ac,av) => {
        const d=new DataView(wasmMemory.buffer);
        d.setUint32(ac,0,true); d.setUint32(av,0,true); return 0;
      },
      args_get: ()=>0,
      proc_exit: (c) => { termLog('sys','WASM proc_exit('+c+')'); },
      clock_time_get: (id,prec,timePtr) => {
        new DataView(wasmMemory.buffer).setBigUint64(timePtr,BigInt(Date.now())*1000000n,true);
        return 0;
      },
    },
    imports: { imported_func: (x) => termLog('log','imported_func('+x+')') },
    js: { mem: wasmMemory },
  };

  let instance;
  try {
    const result = await WebAssembly.instantiate(bytes, importObj);
    instance = result.instance;
    termLog('sys', '⬡ WASM instantiated ✓');
  } catch(e) {
    try {
      const obj2 = JSON.parse(JSON.stringify(importObj, (k,v)=>typeof v==='function'?undefined:v));
      // Retry without injected memory (module exports its own)
      const obj3 = { ...importObj, env: { ...importObj.env } };
      delete obj3.env.memory;
      const result = await WebAssembly.instantiate(bytes, obj3);
      instance = result.instance;
      termLog('sys', '⬡ WASM instantiated (no mem inject) ✓');
    } catch(e2) {
      termLog('error', 'WASM instantiate failed: ' + e2.message); return;
    }
  }

  const exports = instance.exports;
  const exportNames = Object.keys(exports);
  termLog('sys', '⬡ Exports: ' + exportNames.join(', '));

  // Run well-known entry points
  for (const ep of ['_start','main','run','start','init','__wasm_call_ctors']) {
    if (typeof exports[ep] === 'function') {
      termLog('sys', '⬡ Calling ' + ep + '()...');
      try {
        const ret = exports[ep]();
        if (ret !== undefined) termLog('log', ep + '() returned ' + ret);
      } catch(e) {
        if (!e.message.includes('unreachable')) termLog('error', ep + '() threw: ' + e.message);
      }
    }
  }

  for (const [name, val] of Object.entries(exports)) {
    if (typeof val === 'function') termLog('info', '  fn ' + name + '()');
    else if (val instanceof WebAssembly.Memory) termLog('info', '  memory: ' + (val.buffer.byteLength/1024).toFixed(0) + ' KB');
    else if (val instanceof WebAssembly.Global) { try { termLog('info','  global '+name+' = '+val.value); } catch(e){} }
    else termLog('info', '  ' + name + ' [' + typeof val + ']');
  }
  termLog('sys', '⬡ WASM ready. Access via window.__wasmExports');
  window.__wasmExports = exports;
  window.__wasmInstance = instance;
}

// ═══════════════════════════════════════════════════════════════════
//  WEBPACK BUNDLE EXPORT
//  Fully inlines all JS/CSS/assets into a single standalone HTML.
// ═══════════════════════════════════════════════════════════════════
async function exportWebpackBundle() {
  let htmlPath = activeTab;
  if (!htmlPath || !/\.(html|htm)$/i.test(htmlPath)) {
    for (const [vp] of sharedFileMap) {
      if (vp.endsWith('/index.html') || vp === 'index.html') { htmlPath = '/' + vp; break; }
    }
    if (!htmlPath && await fsExists('/index.html').catch(()=>false)) htmlPath = '/index.html';
  }
  if (!htmlPath || !/\.(html|htm)$/i.test(htmlPath)) {
    termLog('warn', 'No HTML file is active. Open an HTML file first.'); return;
  }

  switchPanelTab('terminal');
  termLog('sys', '━━ Webpack Bundle Export: ' + htmlPath.split('/').pop());
  termLog('sys', '   Inlining all assets (JS, CSS, images, fonts)...');

  const strippedPath = htmlPath.replace(/^\/+/,'');
  let html;
  try {
    const srcEntry = sharedMapLookup(strippedPath);
    html = srcEntry
      ? await (await srcEntry.handle.getFile()).text()
      : await fsReadFile(htmlPath);
  } catch(e) { termLog('error', 'Could not read HTML: ' + e.message); return; }

  let bundled;
  try {
    bundled = await fullyInlineHTML(html, strippedPath);
    termLog('sys', '   Inlining complete');
  } catch(e) { termLog('error', 'Bundle failed: ' + e.message); return; }

  // JS exec-tree pass for fetch() / import() rewrites
  try {
    termLog('sys', '   Building JS execution tree...');
    const treeResult = await buildExecTree(bundled, strippedPath);
    if (treeResult && treeResult.patchedHtml) bundled = treeResult.patchedHtml;
  } catch(e) { termLog('warn', '   JS tree pass skipped: ' + e.message); }

  bundled = '<!-- Bundled by VOID IDE v16 — ' + new Date().toISOString() + ' -->\n' + bundled;

  const blob = new Blob([bundled], { type: 'text/html' });
  const name = htmlPath.split('/').pop().replace(/\.html?$/i,'') + '.bundle.html';
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  termLog('sys', '━━ Bundle exported: ' + name + ' (' + (blob.size/1024).toFixed(1) + ' KB)');
}

// ═══════════════════════════════════════════════════════════════════
//  ZSH SHELL EMULATOR — xterm.js powered, VSCode-style
// ═══════════════════════════════════════════════════════════════════

let zshTerm = null;
let zshFitAddon = null;
let zshInitialized = false;

// ── ZSH State ──────────────────────────────────────────────────────
const zshEnv = {
  HOME: '/home/void', PATH: '/usr/local/bin:/usr/bin:/bin',
  TERM: 'xterm-256color', SHELL: '/bin/zsh', USER: 'void',
  LANG: 'en_US.UTF-8', EDITOR: 'void', PAGER: 'less',
  ZSH_VERSION: '5.9', HISTSIZE: '10000', SAVEHIST: '10000',
};
let zshCwd = '/home/void';
let zshHistory = [];
let zshHistIdx = -1;
let zshHistSearch = null;
let zshAliases = {
  ll: 'ls -la', la: 'ls -a', l: 'ls -CF',
  '.': 'source', '..': 'cd ..', '...': 'cd ../..',
  grep: 'grep --color=auto', diff: 'diff --color',
  'g': 'git', 'gi': 'git init', 'gst': 'git status',
  'ga': 'git add', 'gc': 'git commit', 'gp': 'git push',
};
let zshVars = {};
let zshArrays = {};      // ZSH arrays: name -> []
let zshAssocArrays = {}; // ZSH assoc arrays: name -> {}
let zshFunctions = {};   // user-defined functions
let zshOptions = {       // setopt state
  autocd: true, correctall: false, globdots: false,
  nocaseglob: false, extendedglob: true, nullglob: true,
  sharehistory: true, histignorespace: true, histignoredups: true,
};
let zshLastExit = 0;
let zshCurrentLine = '';
let zshCursorPos = 0;
let zshCompletionState = null; // {matches, idx, prefix}
let zshMultiline = '';         // accumulator for multi-line input
let zshPromptShown = false;
let zshRunning = false;        // true while a command executes

// ANSI color helpers
const C = {
  reset:   '\x1b[0m',
  bold:    '\x1b[1m',
  dim:     '\x1b[2m',
  italic:  '\x1b[3m',
  under:   '\x1b[4m',
  black:   '\x1b[30m', red:     '\x1b[31m', green:  '\x1b[32m',
  yellow:  '\x1b[33m', blue:    '\x1b[34m', purple: '\x1b[35m',
  cyan:    '\x1b[36m', white:   '\x1b[37m',
  bblack:  '\x1b[90m', bred:    '\x1b[91m', bgreen: '\x1b[92m',
  byellow: '\x1b[93m', bblue:   '\x1b[94m', bpurple:'\x1b[95m',
  bcyan:   '\x1b[96m', bwhite:  '\x1b[97m',
  bgBlack: '\x1b[40m', bgRed:   '\x1b[41m', bgGreen:'\x1b[42m',
  bgBlue:  '\x1b[44m', bgCyan:  '\x1b[46m',
};

function zshPromptStr(short) {
  const rel = zshCwd === '/home/void' ? '~' : zshCwd.replace(/^\/home\/void\//,'~/').replace(/^\/home\/void$/,'~');
  const branch = ''; // no git in VFS
  const exitIcon = zshLastExit !== 0 ? C.bred + '✗ ' + C.reset : '';
  if (short) return rel + ' ';
  // VSCode-style two-line prompt like oh-my-zsh "agnoster" feel
  const top = C.bblack + '┌─[' + C.reset
    + C.bgreen + C.bold + 'void' + C.reset
    + C.bblack + '@' + C.reset
    + C.bcyan + 'VOID' + C.reset
    + C.bblack + ']──[' + C.reset
    + C.byellow + rel + C.reset
    + C.bblack + ']' + C.reset
    + (branch ? C.bblack + '──[' + C.reset + C.bpurple + '' + branch + C.reset + C.bblack + ']' + C.reset : '')
    + '\r\n';
  const bot = C.bblack + '└─' + C.reset + exitIcon + C.bblue + C.bold + '❯ ' + C.reset;
  return top + bot;
}

function zshWrite(s) { if (zshTerm) zshTerm.write(s); }
function zshWriteln(s) { zshWrite(s + '\r\n'); }

function zshShowPrompt() {
  zshCurrentLine = '';
  zshCursorPos = 0;
  zshCompletionState = null;
  zshPromptShown = true;
  zshWrite(zshPromptStr());
}

function zshRefreshLine(oldLine, newLine, newCursor) {
  // Move to start of input, clear to end, rewrite
  const moveBack = '\x1b[' + zshCursorPos + 'D'.replace(/\[0D/,'[D'); // handle 0
  // Actually: move cursor left by cursorPos chars, then clear line, rewrite
  let seq = '';
  if (zshCursorPos > 0) seq += '\x1b[' + zshCursorPos + 'D';
  seq += '\x1b[K'; // clear to end of line
  seq += zshColorizeInput(newLine);
  // position cursor
  const moveLeft = newLine.length - newCursor;
  if (moveLeft > 0) seq += '\x1b[' + moveLeft + 'D';
  zshWrite(seq);
  zshCurrentLine = newLine;
  zshCursorPos = newCursor;
}

function zshColorizeInput(line) {
  // Syntax highlight the command line as user types (VSCode-like)
  if (!line) return '';
  const tokens = line.split(' ');
  const cmd = tokens[0];
  const builtins = new Set(['cd','ls','cat','echo','pwd','mkdir','rm','cp','mv','touch',
    'grep','find','wc','head','tail','which','source','export','alias','unalias',
    'history','clear','date','env','printenv','help','man','node','js','wasm',
    'setopt','unsetopt','typeset','declare','local','function','return','exit',
    'true','false','set','unset','shift','read','printf','test','[','[[',
    'zsh-version','jobs','kill','fg','bg','disown','time','exec','eval','trap',
  ]);
  let out = '';
  if (zshAliases[cmd]) {
    out += C.bcyan + tokens[0] + C.reset;
  } else if (zshFunctions[cmd]) {
    out += C.bpurple + tokens[0] + C.reset;
  } else if (builtins.has(cmd)) {
    out += C.bblue + C.bold + tokens[0] + C.reset;
  } else {
    out += C.bred + tokens[0] + C.reset;
  }
  for (let i = 1; i < tokens.length; i++) {
    const t = tokens[i];
    out += ' ';
    if (t.startsWith('-')) {
      out += C.byellow + t + C.reset;
    } else if (t.startsWith('"') || t.startsWith("'")) {
      out += C.bgreen + t + C.reset;
    } else if (t.startsWith('$')) {
      out += C.bpurple + t + C.reset;
    } else if (t.match(/^\d+$/)) {
      out += C.byellow + t + C.reset;
    } else {
      out += t;
    }
  }
  return out;
}

function zshPrintOutput(text, color) {
  if (!text && text !== 0) return;
  const lines = String(text).split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    zshWrite((color || '') + line + (color ? C.reset : '') + (i < lines.length - 1 ? '\r\n' : ''));
  }
  if (!String(text).endsWith('\n')) zshWrite('\r\n');
}

function zshPrintErr(msg) {
  zshWrite(C.bred + 'zsh: ' + msg + C.reset + '\r\n');
}
function zshPrintInfo(msg) {
  zshWrite(C.bcyan + msg + C.reset + '\r\n');
}

// ── Path resolution ───────────────────────────────────────────────
function zshResolve(p) {
  if (!p || p === '~') return '/home/void';
  if (p.startsWith('~/')) p = '/home/void/' + p.slice(2);
  if (!p.startsWith('/')) p = zshCwd.replace(/\/?$/, '/') + p;
  const parts = p.split('/').filter(Boolean), stack = [];
  for (const part of parts) {
    if (part === '..') stack.pop();
    else if (part !== '.') stack.push(part);
  }
  return '/' + stack.join('/');
}

// ── Variable / parameter expansion ───────────────────────────────
function zshExpandParam(expr) {
  // ${var}, ${var:-default}, ${var:=default}, ${var:+alt}, ${var:?err}
  // ${#var}, ${var#prefix}, ${var%suffix}, ${var/pat/rep}
  const m = expr.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([=\-+?])(.*))?$/);
  if (m) {
    const [,name,,mod,val] = [...(expr.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([=\-+?])(.*))?$/) || [])];
    let v = zshVars[name] !== undefined ? zshVars[name] : (zshEnv[name] || '');
    if (mod === '-') return v || val || '';
    if (mod === '=') { if (!v) { zshVars[name] = val||''; v = val||''; } return v; }
    if (mod === '+') return v ? (val||'') : '';
    if (mod === '?') { if (!v) throw new Error(name + ': ' + (val||'parameter null or not set')); return v; }
    return v;
  }
  if (expr.startsWith('#')) {
    const n = expr.slice(1);
    const v = zshVars[n] !== undefined ? zshVars[n] : (zshEnv[n] || '');
    return String(v.length);
  }
  // ${var/pattern/replacement}
  const slash = expr.match(/^([A-Za-z_][A-Za-z0-9_]*)\/(.*)\/(.*)$/);
  if (slash) {
    let v = zshVars[slash[1]] !== undefined ? zshVars[slash[1]] : (zshEnv[slash[1]] || '');
    return v.replace(new RegExp(slash[2]), slash[3]);
  }
  // ${var//pattern/replacement} (global)
  const dslash = expr.match(/^([A-Za-z_][A-Za-z0-9_]*)\/\/(.*)\/(.*)$/);
  if (dslash) {
    let v = zshVars[dslash[1]] !== undefined ? zshVars[dslash[1]] : (zshEnv[dslash[1]] || '');
    return v.replace(new RegExp(dslash[2], 'g'), dslash[3]);
  }
  // ${var#prefix}
  const hash = expr.match(/^([A-Za-z_][A-Za-z0-9_]*)#(.*)$/);
  if (hash) {
    let v = zshVars[hash[1]] !== undefined ? zshVars[hash[1]] : (zshEnv[hash[1]] || '');
    const rx = new RegExp('^' + hash[2].replace(/\*/g, '.*'));
    return v.replace(rx, '');
  }
  // ${var%suffix}
  const pct = expr.match(/^([A-Za-z_][A-Za-z0-9_]*)%(.*)$/);
  if (pct) {
    let v = zshVars[pct[1]] !== undefined ? zshVars[pct[1]] : (zshEnv[pct[1]] || '');
    const rx = new RegExp(pct[2].replace(/\*/g, '.*') + '$');
    return v.replace(rx, '');
  }
  // fallback - just look up
  const v = zshVars[expr] !== undefined ? zshVars[expr] : (zshEnv[expr] || '');
  return v;
}

function zshExpandVars(s) {
  // $((arithmetic))
  s = s.replace(/\$\(\(([^)]+)\)\)/g, (_, expr) => {
    try { return String(Math.round(Function('return (' + zshExpandVarsSimple(expr) + ')')())); }
    catch(e) { return '0'; }
  });
  // $(command) - command substitution
  // ${...} complex
  s = s.replace(/\$\{([^}]+)\}/g, (_, expr) => {
    try { return zshExpandParam(expr); } catch(e) { return ''; }
  });
  // $var
  s = s.replace(/\$([A-Za-z_][A-Za-z0-9_]*|\?|!|#|\$|0|[1-9])/g, (_, n) => {
    if (n === '?') return String(zshLastExit);
    if (n === '$') return String(Math.floor(Math.random()*99999));
    if (n === '#') return '0';
    return zshVars[n] !== undefined ? zshVars[n] : (zshEnv[n] || '');
  });
  return s;
}

function zshExpandVarsSimple(s) {
  return s.replace(/\$([A-Za-z_][A-Za-z0-9_]*)/g, (_, n) =>
    zshVars[n] !== undefined ? zshVars[n] : (zshEnv[n] || '0'));
}

// ── Tokenizer ──────────────────────────────────────────────────────
function zshTokenize(str) {
  const args = []; let cur = '', inSingle = false, inDouble = false, inBrace = 0;
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
    if (c === "'" && !inDouble) { inSingle = !inSingle; continue; }
    if (c === '"' && !inSingle) { inDouble = !inDouble; continue; }
    if (c === '\\' && !inSingle && i + 1 < str.length) { cur += str[++i]; continue; }
    if (c === '{' && !inSingle && !inDouble) { inBrace++; cur += c; continue; }
    if (c === '}' && !inSingle && !inDouble && inBrace > 0) { inBrace--; cur += c; continue; }
    if (c === ' ' && !inSingle && !inDouble && !inBrace) {
      if (cur) { args.push(inDouble ? cur : zshExpandVars(cur)); cur = ''; }
      continue;
    }
    cur += c;
  }
  if (cur) args.push(inDouble ? zshExpandVars(cur) : zshExpandVars(cur));
  return args;
}

// ── Globbing ───────────────────────────────────────────────────────
async function zshGlob(pattern) {
  // Only glob if pattern contains * ? or [ 
  if (!/[*?\[]/.test(pattern)) return [pattern];
  try {
    const dir = pattern.includes('/') ? zshResolve(pattern.replace(/\/[^/]*$/, '')) : zshCwd;
    const base = pattern.includes('/') ? pattern.replace(/.*\//, '') : pattern;
    const items = await fsReaddir(dir).catch(() => []);
    const rx = new RegExp('^' + base.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\?/g, '.') + '$');
    const matches = items.filter(i => (zshOptions.globdots || !i.startsWith('.')) && rx.test(i))
                         .map(i => pattern.includes('/') ? dir + '/' + i : i);
    return matches.length ? matches : (zshOptions.nullglob ? [] : [pattern]);
  } catch(e) { return [pattern]; }
}

async function zshExpandGlobs(args) {
  const out = [];
  for (const a of args) {
    if (/[*?\[]/.test(a)) {
      const g = await zshGlob(a);
      out.push(...g);
    } else {
      out.push(a);
    }
  }
  return out;
}

// ── Command substitution ───────────────────────────────────────────
async function zshCmdSub(expr) {
  return (await zshExecCapture(expr)).trimEnd();
}

async function zshPreprocess(line) {
  // Process $(cmd) substitutions
  let out = line;
  const rx = /\$\(([^)]+)\)/g;
  let m;
  const subs = [];
  while ((m = rx.exec(line)) !== null) subs.push({ full: m[0], inner: m[1], idx: m.index });
  for (const s of subs.reverse()) {
    const result = await zshCmdSub(s.inner);
    out = out.slice(0, s.idx) + result + out.slice(s.idx + s.full.length);
  }
  return out;
}

// ── Pipeline / redirection parser ─────────────────────────────────
function zshSplitPipe(line) {
  const parts = []; let cur = '', inSingle = false, inDouble = false, inParen = 0;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === "'" && !inDouble) inSingle = !inSingle;
    if (c === '"' && !inSingle) inDouble = !inDouble;
    if (!inSingle && !inDouble) {
      if (c === '(') inParen++;
      if (c === ')') inParen--;
      if (c === '|' && !inParen && line[i+1] !== '|') { parts.push(cur.trim()); cur = ''; continue; }
    }
    cur += c;
  }
  if (cur.trim()) parts.push(cur.trim());
  return parts;
}

// ── Main executor ─────────────────────────────────────────────────
async function zshExec(line) {
  line = line.trim();
  if (!line || line.startsWith('#')) return 0;

  // Preprocess command substitutions
  line = await zshPreprocess(line);

  // Handle ; separated commands
  if (/;/.test(line)) {
    const parts = zshSplitOnSemicolon(line);
    let exit = 0;
    for (const p of parts) { if (p.trim()) exit = await zshExec(p.trim()); }
    return exit;
  }

  // && / ||
  if (/ && /.test(line)) {
    const parts = line.split(/ && /);
    let exit = 0;
    for (const p of parts) {
      exit = await zshExec(p.trim());
      if (exit !== 0) return exit;
    }
    return exit;
  }
  if (/ \|\| /.test(line)) {
    const parts = line.split(/ \|\| /);
    let exit = 1;
    for (const p of parts) {
      exit = await zshExec(p.trim());
      if (exit === 0) return exit;
    }
    return exit;
  }

  // Redirection: >> and >
  const appendM = line.match(/^(.*?)\s*>>\s*(.+)$/);
  if (appendM) {
    const out = await zshExecCapture(appendM[1].trim());
    const dest = zshResolve(appendM[2].trim());
    let ex = ''; try { ex = await fsReadFile(dest); } catch(e) {}
    await fsWriteFileSafe(dest, ex + out);
    zshPrintInfo('Appended → ' + dest);
    return 0;
  }
  const redirectM = line.match(/^(.*?)\s*>\s*(.+)$/);
  if (redirectM) {
    const out = await zshExecCapture(redirectM[1].trim());
    const dest = zshResolve(redirectM[2].trim());
    await fsWriteFileSafe(dest, out);
    zshPrintInfo('Wrote → ' + dest);
    return 0;
  }

  // Pipe
  const pipeParts = zshSplitPipe(line);
  if (pipeParts.length > 1) {
    let buf = '';
    for (let i = 0; i < pipeParts.length; i++) {
      const isLast = i === pipeParts.length - 1;
      buf = await zshExecSingle(pipeParts[i].trim(), buf, !isLast);
    }
    if (buf) zshPrintOutput(buf.replace(/\n$/, ''));
    return 0;
  }

  return await zshExecSingle(line, '', false);
}

function zshSplitOnSemicolon(line) {
  const parts = []; let cur = '', inSingle = false, inDouble = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === "'" && !inDouble) inSingle = !inSingle;
    if (c === '"' && !inSingle) inDouble = !inDouble;
    if (c === ';' && !inSingle && !inDouble) { parts.push(cur); cur = ''; }
    else cur += c;
  }
  if (cur) parts.push(cur);
  return parts;
}

async function zshExecCapture(cmdLine) {
  // Execute command line, capture output as string
  let captured = '';
  const origWrite = zshTerm.write.bind(zshTerm);
  // intercept by temporarily patching
  const results = await _zshExecSilent(cmdLine);
  return results;
}

async function _zshExecSilent(cmdLine) {
  cmdLine = cmdLine.trim();
  if (!cmdLine) return '';
  const args = zshTokenize(cmdLine);
  const expandedArgs = await zshExpandGlobs(args);
  const cmd = expandedArgs[0];
  const rest = expandedArgs.slice(1);

  if (!cmd) return '';

  // Alias expansion
  if (zshAliases[cmd]) {
    const expanded = zshAliases[cmd] + (rest.length ? ' ' + rest.join(' ') : '');
    return _zshExecSilent(expanded);
  }

  let output = '';
  const p = (t) => { output += t + '\n'; };

  switch (cmd) {
    case 'pwd': return zshCwd + '\n';
    case 'echo': {
      const noNl = rest[0] === '-n', noEsc = rest[0] === '-E';
      const words = (noNl || noEsc) ? rest.slice(1) : rest;
      let line = words.join(' ').replace(/\\n/g, '\n').replace(/\\t/g, '\t');
      return noNl ? line : line + '\n';
    }
    case 'cat': {
      for (const f of rest) {
        try { output += await fsReadFile(zshResolve(f)); } catch(e) {}
      }
      return output;
    }
    case 'ls': {
      const flags = rest.filter(a => a.startsWith('-')).join('');
      const pos = rest.filter(a => !a.startsWith('-'));
      const dir = pos[0] ? zshResolve(pos[0]) : zshCwd;
      const all = flags.includes('a');
      let items = await fsReaddir(dir).catch(() => []);
      if (!all) items = items.filter(i => !i.startsWith('.'));
      items.sort();
      return items.join('\n') + '\n';
    }
    case 'date': return new Date().toString() + '\n';
    case 'wc': {
      for (const f of rest.filter(a => !a.startsWith('-'))) {
        try {
          const c = await fsReadFile(zshResolve(f));
          const l = c.split('\n').length, w = c.split(/\s+/).filter(Boolean).length, b = c.length;
          output += [String(l).padStart(8), String(w).padStart(8), String(b).padStart(8), f].join(' ') + '\n';
        } catch(e) {}
      }
      return output;
    }
    case 'grep': {
      let flags='', pattern='', files=[];
      for (const a of rest) { if(a.startsWith('-'))flags+=a.slice(1); else if(!pattern)pattern=a; else files.push(a); }
      const rx = new RegExp(pattern, flags.includes('i') ? 'i' : '');
      for (const f of files) {
        const c = await fsReadFile(zshResolve(f)).catch(() => '');
        c.split('\n').forEach((line, i) => {
          if (rx.test(line)) output += (flags.includes('n') ? (i+1)+':' : '') + line + '\n';
        });
      }
      return output;
    }
    case 'head': {
      const n = rest.includes('-n') ? parseInt(rest[rest.indexOf('-n')+1]) : 10;
      const f = rest.filter(a => !a.startsWith('-'))[0];
      const c = f ? await fsReadFile(zshResolve(f)).catch(()=>'') : '';
      return c.split('\n').slice(0, n).join('\n') + '\n';
    }
    case 'tail': {
      const n = rest.includes('-n') ? parseInt(rest[rest.indexOf('-n')+1]) : 10;
      const f = rest.filter(a => !a.startsWith('-'))[0];
      const c = f ? await fsReadFile(zshResolve(f)).catch(()=>'') : '';
      return c.split('\n').slice(-n).join('\n') + '\n';
    }
    case 'printf': {
      if (!rest.length) return '';
      let fmt = rest[0].replace(/\\n/g,'\n').replace(/\\t/g,'\t');
      let argIdx = 1;
      output = fmt.replace(/%[sd%]/g, m => {
        if (m === '%%') return '%';
        return rest[argIdx++] || '';
      });
      return output;
    }
    default: return '';
  }
}

async function zshExecSingle(cmdLine, stdin, silent) {
  cmdLine = cmdLine.trim();
  if (!cmdLine) return 0;

  const rawArgs = zshTokenize(cmdLine);
  if (!rawArgs.length) return 0;
  const args = await zshExpandGlobs(rawArgs);
  const cmd = args[0], rest = args.slice(1);

  // Variable assignment: FOO=bar or FOO=bar cmd
  if (/^[A-Za-z_][A-Za-z0-9_]*=/.test(cmd)) {
    const [name, ...vals] = cmd.split('=');
    const val = zshExpandVars(vals.join('='));
    // If there are more args, it's a temp env for next cmd
    if (rest.length) {
      const prev = zshVars[name];
      zshVars[name] = val;
      const exit = await zshExecSingle(rest.join(' '), stdin, silent);
      if (prev === undefined) delete zshVars[name]; else zshVars[name] = prev;
      return exit;
    }
    zshVars[name] = val;
    return 0;
  }

  // Alias expansion
  if (zshAliases[cmd]) {
    const expanded = zshAliases[cmd] + (rest.length ? ' ' + rest.join(' ') : '');
    return zshExecSingle(expanded, stdin, silent);
  }

  // User-defined functions
  if (zshFunctions[cmd]) {
    const fn = zshFunctions[cmd];
    // Set $1, $2, etc.
    rest.forEach((a, i) => { zshVars[String(i+1)] = a; });
    for (const line of fn) { await zshExec(line); }
    rest.forEach((_, i) => { delete zshVars[String(i+1)]; });
    return zshLastExit;
  }

  const print = silent
    ? (t) => { if(t!==undefined) stdin += String(t) + '\n'; return ''; }
    : (t, col) => { zshPrintOutput(t, col); };
  const printErr = silent ? (t) => {} : zshPrintErr;

  switch (cmd) {
    // ── Navigation ──────────────────────────────────────────────────
    case 'cd': {
      const target = rest[0] ? zshResolve(rest[0]) : '/home/void';
      const ex = await fsExists(target).catch(() => false);
      if (!ex) { printErr('no such file or directory: ' + (rest[0] || '')); return 1; }
      const st = await fsStat(target).catch(() => null);
      if (st && st.isDirectory()) {
        zshEnv.OLDPWD = zshCwd;
        zshCwd = target;
      } else { printErr('not a directory: ' + rest[0]); return 1; }
      return 0;
    }
    case 'pwd': print(zshCwd); return 0;

    // ── File listing ────────────────────────────────────────────────
    case 'ls': {
      const flags = rest.filter(a => a.startsWith('-')).join('');
      const pos = rest.filter(a => !a.startsWith('-'));
      const long = flags.includes('l'), all = flags.includes('a'), color = !flags.includes('G');
      const dirs = pos.length ? pos.map(p => zshResolve(p)) : [zshCwd];
      for (const dir of dirs) {
        try {
          const st = await fsStat(dir).catch(() => null);
          if (st && !st.isDirectory()) {
            const name = dir.split('/').pop();
            print(long ? '-rw-r--r-- 1 void void ' + String(st.size).padStart(8) + ' ' + name : name);
            continue;
          }
          let items = await fsReaddir(dir).catch(() => []);
          if (!all) items = items.filter(i => !i.startsWith('.'));
          items.sort((a, b) => a.localeCompare(b));
          if (long) {
            if (!silent) zshWrite(C.bblack + 'total ' + items.length + '\r\n' + C.reset);
            for (const item of items) {
              const fp = dir.replace(/\/?$/, '/') + item;
              const s = await fsStat(fp).catch(() => null);
              const isDir = s && s.isDirectory();
              const dateStr = s ? new Date(s.mtimeMs || Date.now()).toLocaleDateString('en-US',{month:'short',day:'2-digit',year:'numeric'}) : '          ';
              const coloredName = !silent ? (isDir ? C.bold + C.bblue + item + '/' + C.reset : (item.endsWith('.sh') || item.endsWith('.zsh') ? C.bgreen + item + C.reset : item)) : item;
              if (!silent) {
                zshWrite((isDir ? C.bblue + 'drwxr-xr-x' : '-rw-r--r--') + C.reset
                  + '  1 void void ' + String(s ? s.size : 0).padStart(8) + ' ' + dateStr + '  ' + coloredName + '\r\n');
              } else {
                stdin += (isDir ? 'd' : '-') + 'rwxr-xr-x  1 void void ' + String(s?s.size:0).padStart(8) + ' ' + item + '\n';
              }
            }
          } else {
            if (!silent) {
              // colored columns like real ls
              const cols = Math.max(1, Math.floor((zshTerm ? zshTerm.cols : 80) / 22));
              for (let i = 0; i < items.length; i += cols) {
                const row = items.slice(i, i + cols);
                let line = '';
                for (const item of row) {
                  const fp = dir.replace(/\/?$/, '/') + item;
                  const s = await fsStat(fp).catch(() => null);
                  const isDir = s && s.isDirectory();
                  const colored = isDir ? C.bold + C.bblue + item + '/' + C.reset
                    : (item.match(/\.(sh|zsh|bash|py|js|ts|rb|go|rs)$/) ? C.bgreen + item + C.reset
                    : (item.match(/\.(jpg|png|gif|svg|mp4|mp3)$/) ? C.bpurple + item + C.reset
                    : item));
                  line += colored + ' '.repeat(Math.max(1, 22 - item.length - (isDir?1:0)));
                }
                zshWrite(line.trimEnd() + '\r\n');
              }
            } else {
              stdin += items.join('\n') + '\n';
            }
          }
        } catch(e) { printErr('ls: ' + e.message); }
      }
      return 0;
    }

    // ── File ops ────────────────────────────────────────────────────
    case 'cat': {
      if (!rest.length && stdin) { print(stdin.trimEnd()); return 0; }
      for (const f of rest) {
        const fp = zshResolve(f);
        try { print(await fsReadFile(fp)); }
        catch(e) { printErr(f + ': No such file or directory'); return 1; }
      }
      return 0;
    }
    case 'echo': {
      const noNl = rest[0] === '-n', noEsc = rest[0] === '-E';
      const hasE = rest[0] === '-e';
      const words = (noNl || noEsc || hasE) ? rest.slice(1) : rest;
      let line = words.join(' ');
      if (!noEsc) line = line.replace(/\\n/g, '\n').replace(/\\t/g, '\t').replace(/\\e/g, '\x1b');
      if (!silent) {
        if (noNl) zshWrite(line);
        else zshWrite(line + '\r\n');
      } else {
        stdin += line + (noNl ? '' : '\n');
      }
      return 0;
    }
    case 'printf': {
      if (!rest.length) return 0;
      let fmt = rest[0].replace(/\\n/g,'\n').replace(/\\t/g,'\t').replace(/\\e/g,'\x1b');
      let argIdx = 1;
      const out = fmt.replace(/%[sd%]/g, m => {
        if (m === '%%') return '%';
        return rest[argIdx++] || '';
      });
      if (!silent) zshWrite(out);
      else stdin += out;
      return 0;
    }
    case 'mkdir': {
      const parents = rest.includes('-p');
      const dirs = rest.filter(a => !a.startsWith('-'));
      for (const d of dirs) {
        try { await fsMkdir(zshResolve(d)); if(!silent) zshPrintInfo('created: ' + zshResolve(d)); }
        catch(e) { printErr('cannot create directory \'' + d + '\': ' + e.message); return 1; }
      }
      return 0;
    }
    case 'rm': {
      const rec = rest.some(a => a === '-r' || a === '-rf' || a === '-fr' || a === '-f');
      const files = rest.filter(a => !a.startsWith('-'));
      for (const f of files) {
        const fp = zshResolve(f);
        try {
          const st = await fsStat(fp).catch(() => null);
          if (st && st.isDirectory()) {
            if (rec) await fsRmdirR(fp);
            else { printErr('cannot remove \'' + f + '\': Is a directory'); return 1; }
          } else await fsUnlink(fp);
          if(!silent) zshPrintInfo('removed: ' + fp);
        } catch(e) { printErr('cannot remove \'' + f + '\': ' + e.message); return 1; }
      }
      return 0;
    }
    case 'touch': {
      for (const f of rest) {
        const fp = zshResolve(f);
        if (!await fsExists(fp).catch(() => false)) await fsWriteFileSafe(fp, '');
      }
      return 0;
    }
    case 'cp': {
      if (rest.length < 2) { printErr('missing operand'); return 1; }
      const src = zshResolve(rest[0]), dst = zshResolve(rest[rest.length-1]);
      try { await fsWriteFileSafe(dst, await fsReadFile(src)); if(!silent) zshPrintInfo(src + ' → ' + dst); }
      catch(e) { printErr(e.message); return 1; }
      return 0;
    }
    case 'mv': {
      if (rest.length < 2) { printErr('missing operand'); return 1; }
      const src = zshResolve(rest[0]), dst = zshResolve(rest[rest.length-1]);
      try {
        await fsWriteFileSafe(dst, await fsReadFile(src));
        await fsUnlink(src);
        if(!silent) zshPrintInfo(src + ' → ' + dst);
      } catch(e) { printErr(e.message); return 1; }
      return 0;
    }
    case 'ln': {
      // Soft link: just copy in VFS
      if (rest.length < 2) { printErr('missing operand'); return 1; }
      const src = zshResolve(rest[rest.length-2]), dst = zshResolve(rest[rest.length-1]);
      try { await fsWriteFileSafe(dst, await fsReadFile(src)); }
      catch(e) { printErr(e.message); return 1; }
      return 0;
    }
    case 'stat': {
      for (const f of rest) {
        const fp = zshResolve(f);
        try {
          const s = await fsStat(fp);
          print([
            '  File: ' + fp,
            '  Size: ' + s.size,
            '  Type: ' + (s.isDirectory() ? 'directory' : 'regular file'),
            ' Inode: ' + Math.floor(Math.random()*99999),
            'Access: ' + new Date(s.mtimeMs||Date.now()).toISOString(),
          ].join('\n'));
        } catch(e) { printErr('cannot stat \'' + f + '\': No such file or directory'); return 1; }
      }
      return 0;
    }
    case 'file': {
      for (const f of rest) {
        const fp = zshResolve(f);
        try {
          const st = await fsStat(fp);
          if (st.isDirectory()) print(f + ': directory');
          else {
            const c = await fsReadFile(fp).catch(()=>'');
            const ext = f.split('.').pop();
            const types = { js:'JavaScript', ts:'TypeScript', html:'HTML', css:'CSS',
              json:'JSON data', py:'Python', sh:'shell script', md:'Markdown', txt:'ASCII text' };
            print(f + ': ' + (types[ext] || 'ASCII text'));
          }
        } catch(e) { print(f + ': ERROR'); }
      }
      return 0;
    }

    // ── Text processing ─────────────────────────────────────────────
    case 'grep': {
      let flags = '', pattern = '', files = [];
      for (const a of rest) {
        if (a.startsWith('-')) flags += a.slice(1);
        else if (!pattern) pattern = a;
        else files.push(a);
      }
      if (!pattern) { printErr('grep: missing pattern'); return 1; }
      const ignCase = flags.includes('i'), showLine = flags.includes('n');
      const invert = flags.includes('v'), count = flags.includes('c');
      let rx;
      try { rx = new RegExp(pattern, ignCase ? 'gi' : 'g'); }
      catch(e) { printErr('grep: invalid regex: ' + e.message); return 1; }
      let totalCount = 0;
      const srcs = files.length ? files : (stdin ? ['<stdin>'] : []);
      for (const f of srcs) {
        const content = f === '<stdin>' ? stdin : await fsReadFile(zshResolve(f)).catch(() => null);
        if (content === null) { printErr(f + ': No such file'); continue; }
        const lines = content.split('\n');
        let fc = 0;
        lines.forEach((line, i) => {
          const match = rx.test(line); rx.lastIndex = 0;
          if (match !== !!invert) {
            fc++;
            if (!count) {
              const prefix = (files.length > 1 ? C.bpurple + f + C.reset + ':' : '')
                           + (showLine ? C.byellow + (i+1) + C.reset + ':' : '');
              const highlighted = !silent ? line.replace(new RegExp(pattern, ignCase?'gi':'g'), m => C.bred + C.bold + m + C.reset) : line;
              if (!silent) zshWrite(prefix + highlighted + '\r\n');
              else stdin += (files.length > 1 ? f + ':' : '') + (showLine ? (i+1)+':' : '') + line + '\n';
            }
          }
        });
        if (count) { print(fc + (files.length > 1 ? ' ' + f : '')); }
        totalCount += fc;
      }
      zshLastExit = totalCount > 0 ? 0 : 1;
      return zshLastExit;
    }
    case 'wc': {
      const showL = rest.includes('-l'), showW = rest.includes('-w'), showC = rest.includes('-c');
      const files2 = rest.filter(a => !a.startsWith('-'));
      for (const f of files2) {
        try {
          const c = await fsReadFile(zshResolve(f));
          const l = c.split('\n').length, w = c.split(/\s+/).filter(Boolean).length, b = new TextEncoder().encode(c).length;
          if (showL) print(l + '  ' + f);
          else if (showW) print(w + '  ' + f);
          else if (showC) print(b + '  ' + f);
          else print([String(l).padStart(7), String(w).padStart(7), String(b).padStart(7), f].join(' '));
        } catch(e) { printErr(f + ': No such file'); return 1; }
      }
      return 0;
    }
    case 'head': {
      const ni = rest.indexOf('-n');
      const n = ni >= 0 ? parseInt(rest[ni+1]) : 10;
      const fa = rest.filter(a => !a.startsWith('-'))[0];
      const c = fa ? await fsReadFile(zshResolve(fa)).catch(()=>'') : stdin;
      print(c.split('\n').slice(0, n).join('\n'));
      return 0;
    }
    case 'tail': {
      const ni = rest.indexOf('-n');
      const n = ni >= 0 ? parseInt(rest[ni+1]) : 10;
      const fa = rest.filter(a => !a.startsWith('-'))[0];
      const c = fa ? await fsReadFile(zshResolve(fa)).catch(()=>'') : stdin;
      print(c.split('\n').slice(-n).join('\n'));
      return 0;
    }
    case 'sed': {
      // Basic sed s/pat/rep/flags
      const script = rest[0], file = rest[1];
      const m = script && script.match(/^s\/([^/]*)\/([^/]*)\/(g?)$/);
      if (!m) { printErr('sed: unsupported expression'); return 1; }
      const src = file ? await fsReadFile(zshResolve(file)).catch(()=>'') : stdin;
      const result = src.replace(new RegExp(m[1], m[3] ? 'g' : ''), m[2]);
      if (!silent) zshWrite(result.replace(/\n/g, '\r\n'));
      else stdin = result;
      return 0;
    }
    case 'awk': {
      // Minimal awk: print fields
      const prog = rest[0], file2 = rest[1];
      const src2 = file2 ? await fsReadFile(zshResolve(file2)).catch(()=>'') : stdin;
      const printMatch = prog && prog.match(/^\{print \$(\d+|NF|NR|0)\}$/);
      if (printMatch) {
        const fi = printMatch[1];
        src2.split('\n').forEach((line, idx) => {
          const fields = line.split(/\s+/).filter(Boolean);
          let val;
          if (fi === '0') val = line;
          else if (fi === 'NF') val = fields[fields.length-1] || '';
          else if (fi === 'NR') val = String(idx+1);
          else val = fields[parseInt(fi)-1] || '';
          if (val !== undefined && val !== '') print(val);
        });
      } else {
        // Just print each line
        src2.split('\n').filter(Boolean).forEach(l => print(l));
      }
      return 0;
    }
    case 'sort': {
      const src = rest.filter(a=>!a.startsWith('-'))[0];
      const c = src ? await fsReadFile(zshResolve(src)).catch(()=>'') : stdin;
      const rev = rest.includes('-r'), nums = rest.includes('-n'), uniq2 = rest.includes('-u');
      let lines = c.split('\n').filter(Boolean);
      lines.sort(nums ? (a,b) => parseFloat(a)-parseFloat(b) : (a,b) => a.localeCompare(b));
      if (rev) lines.reverse();
      if (uniq2) lines = [...new Set(lines)];
      print(lines.join('\n'));
      return 0;
    }
    case 'uniq': {
      const src = rest.filter(a=>!a.startsWith('-'))[0];
      const c = src ? await fsReadFile(zshResolve(src)).catch(()=>'') : stdin;
      const lines = c.split('\n');
      const result = lines.filter((l,i) => i===0 || l !== lines[i-1]);
      print(result.join('\n'));
      return 0;
    }
    case 'tr': {
      if (rest.length < 2) { printErr('tr: missing operand'); return 1; }
      let src = stdin, from = rest[0], to = rest[1];
      from = from.replace(/\\n/g,'\n').replace(/\\t/g,'\t');
      to = to.replace(/\\n/g,'\n').replace(/\\t/g,'\t');
      let out = '';
      for (const c of src) {
        const idx = from.indexOf(c);
        out += idx >= 0 ? (to[idx] || '') : c;
      }
      if (!silent) zshWrite(out.replace(/\n/g, '\r\n'));
      else stdin = out;
      return 0;
    }
    case 'cut': {
      const di = rest.indexOf('-d'), fi2 = rest.indexOf('-f');
      const delim = di >= 0 ? rest[di+1] : '\t';
      const field = fi2 >= 0 ? parseInt(rest[fi2+1]) - 1 : 0;
      const src = rest.filter(a=>!a.startsWith('-') && rest.indexOf(a)!==di+1 && rest.indexOf(a)!==fi2+1)[0];
      const c = src ? await fsReadFile(zshResolve(src)).catch(()=>'') : stdin;
      c.split('\n').filter(Boolean).forEach(line => print(line.split(delim)[field] || ''));
      return 0;
    }
    case 'tee': {
      if (rest[0]) await fsWriteFileSafe(zshResolve(rest[0]), stdin);
      print(stdin);
      return 0;
    }
    case 'xargs': {
      const xcmd = rest.join(' ') || 'echo';
      const items = stdin.split(/\s+/).filter(Boolean);
      for (const item of items) await zshExec(xcmd + ' ' + item);
      return 0;
    }

    // ── Find ───────────────────────────────────────────────────────
    case 'find': {
      const baseDir = rest[0] && !rest[0].startsWith('-') ? zshResolve(rest[0]) : zshCwd;
      const ni2 = rest.indexOf('-name'), np = ni2 >= 0 ? rest[ni2+1] : null;
      const ti2 = rest.indexOf('-type'), tf = ti2 >= 0 ? rest[ti2+1] : null;
      const maxd = rest.indexOf('-maxdepth') >= 0 ? parseInt(rest[rest.indexOf('-maxdepth')+1]) : 100;
      async function doFind(dir, depth) {
        if (depth > maxd) return;
        const items = await fsReaddir(dir).catch(() => []);
        for (const item of items) {
          const fp = dir.replace(/\/?$/, '/') + item;
          const st = await fsStat(fp).catch(() => null), isDir = st && st.isDirectory();
          const nameMatch = !np || item === np || item.match(new RegExp('^' + np.replace(/\./g,'\\.').replace('*','.*') + '$'));
          const typeMatch = !tf || (tf === 'f' && !isDir) || (tf === 'd' && isDir);
          if (nameMatch && typeMatch) print(fp);
          if (isDir) await doFind(fp, depth+1);
        }
      }
      await doFind(baseDir, 0);
      return 0;
    }

    // ── Environment ────────────────────────────────────────────────
    case 'export': {
      if (!rest.length) {
        for (const [k,v] of Object.entries(zshEnv)) print('export ' + k + '=' + v);
        return 0;
      }
      for (const a of rest) {
        const eq = a.indexOf('=');
        if (eq > 0) { const k = a.slice(0,eq), v = a.slice(eq+1); zshEnv[k] = v; zshVars[k] = v; }
        else if (zshVars[a] !== undefined) zshEnv[a] = zshVars[a];
      }
      return 0;
    }
    case 'unset': for (const a of rest) { delete zshVars[a]; delete zshEnv[a]; } return 0;
    case 'env': case 'printenv': {
      const all2 = { ...zshEnv, ...zshVars };
      if (rest.length) { print(all2[rest[0]] || ''); return 0; }
      for (const [k,v] of Object.entries(all2)) print(k + '=' + v);
      return 0;
    }

    // ── Alias ─────────────────────────────────────────────────────
    case 'alias': {
      if (!rest.length) {
        for (const [k,v] of Object.entries(zshAliases))
          print(C.bblue + 'alias ' + C.reset + k + C.byellow + "='" + v + "'" + C.reset);
        return 0;
      }
      for (const a of rest) {
        const eq = a.indexOf('=');
        if (eq > 0) zshAliases[a.slice(0,eq)] = a.slice(eq+1).replace(/^['"]|['"]$/g,'');
        else { if(zshAliases[a]) print("alias " + a + "='" + zshAliases[a] + "'"); }
      }
      return 0;
    }
    case 'unalias': for (const a of rest) delete zshAliases[a]; return 0;

    // ── ZSH options ────────────────────────────────────────────────
    case 'setopt': {
      if (!rest.length) {
        for (const [k,v] of Object.entries(zshOptions)) if(v) print(k);
        return 0;
      }
      for (const opt of rest) zshOptions[opt.toLowerCase()] = true;
      return 0;
    }
    case 'unsetopt': {
      for (const opt of rest) zshOptions[opt.toLowerCase()] = false;
      return 0;
    }

    // ── ZSH arrays / typeset ──────────────────────────────────────
    case 'typeset': case 'declare': case 'local': {
      // typeset -A assoc; typeset -a arr
      const isAssoc = rest.includes('-A');
      const isArr = rest.includes('-a');
      const names = rest.filter(a => !a.startsWith('-'));
      for (const n of names) {
        const [name,...vals2] = n.split('=');
        if (isAssoc) zshAssocArrays[name] = {};
        else if (isArr) zshArrays[name] = [];
        else { zshVars[name] = vals2.join('=') || ''; }
      }
      return 0;
    }

    // ── History ────────────────────────────────────────────────────
    case 'history': {
      const n = rest[0] ? parseInt(rest[0]) : 20;
      const slice = zshHistory.slice(-n);
      slice.forEach((h, i) => {
        const num = String(zshHistory.length - n + i + 1).padStart(5);
        if(!silent) zshWrite(C.byellow + num + C.reset + '  ' + h + '\r\n');
        else stdin += num + '  ' + h + '\n';
      });
      return 0;
    }
    case 'fc': {
      // fc -l: list history
      if (rest.includes('-l')) {
        zshHistory.slice(-20).forEach((h, i) => {
          zshWrite(C.byellow + String(i+1).padStart(5) + C.reset + '  ' + h + '\r\n');
        });
      }
      return 0;
    }

    // ── String processing (zsh-specific) ──────────────────────────
    case 'print': {
      // zsh print with -P (prompt expansion), -n (no newline)
      const noNl2 = rest.includes('-n');
      const words = rest.filter(a => !a.startsWith('-'));
      const line = words.join(' ');
      if (!silent) zshWrite(line + (noNl2 ? '' : '\r\n'));
      else stdin += line + (noNl2 ? '' : '\n');
      return 0;
    }

    // ── System info ────────────────────────────────────────────────
    case 'uname': {
      const all3 = rest.includes('-a');
      const kern = rest.includes('-s') || all3;
      const node = rest.includes('-n') || all3;
      const rel = rest.includes('-r') || all3;
      const parts = [];
      if (!rest.length || kern) parts.push('VoidOS');
      if (node) parts.push('void-browser');
      if (rel) parts.push('1.0.0');
      if (all3) parts.push('void-browser 1.0.0 #1 SMP ' + new Date().toString() + ' x86_64');
      print(parts.join(' '));
      return 0;
    }
    case 'whoami': case 'id': {
      if (cmd === 'id') print('uid=1000(void) gid=1000(void) groups=1000(void),4(adm),27(sudo)');
      else print('void');
      return 0;
    }
    case 'hostname': print('void-browser'); return 0;
    case 'uptime': print('up ' + Math.floor(performance.now()/60000) + ' min, 1 user, load average: 0.00, 0.00, 0.00'); return 0;
    case 'date': {
      const d = new Date();
      if (rest[0] && rest[0].startsWith('+')) {
        const fmt = rest[0].slice(1);
        print(fmt
          .replace('%Y', d.getFullYear())
          .replace('%m', String(d.getMonth()+1).padStart(2,'0'))
          .replace('%d', String(d.getDate()).padStart(2,'0'))
          .replace('%H', String(d.getHours()).padStart(2,'0'))
          .replace('%M', String(d.getMinutes()).padStart(2,'0'))
          .replace('%S', String(d.getSeconds()).padStart(2,'0'))
          .replace('%s', Math.floor(d/1000))
        );
      } else print(d.toString());
      return 0;
    }
    case 'time': {
      const t0 = performance.now();
      const ex = await zshExec(rest.join(' '));
      const t1 = performance.now();
      zshWrite(C.bblack + '\r\nreal\t' + ((t1-t0)/1000).toFixed(3) + 's\r\nuser\t0.000s\r\nsys\t0.000s\r\n' + C.reset);
      return ex;
    }
    case 'sleep': {
      const secs = parseFloat(rest[0]) || 1;
      await new Promise(r => setTimeout(r, secs * 1000));
      return 0;
    }
    case 'true': return 0;
    case 'false': return 1;

    // ── Variables / math ──────────────────────────────────────────
    case 'let': {
      const expr = rest.join(' ');
      try {
        const result = Function('return (' + zshExpandVarsSimple(expr) + ')')();
        zshLastExit = result ? 0 : 1;
        return zshLastExit;
      } catch(e) { return 1; }
    }
    case 'expr': {
      const expr = rest.join(' ');
      try {
        const r = Function('return (' + expr + ')')();
        print(String(r));
      } catch(e) { printErr('expr: syntax error'); return 1; }
      return 0;
    }
    case 'read': {
      // Non-interactive in browser - just set empty
      const varName = rest.filter(a=>!a.startsWith('-'))[0] || 'REPLY';
      zshVars[varName] = '';
      return 0;
    }

    // ── Which / type ──────────────────────────────────────────────
    case 'which': case 'type': {
      for (const a of rest) {
        if (zshAliases[a]) print(cmd==='type' ? a + ' is an alias for ' + zshAliases[a] : 'alias ' + a + "='" + zshAliases[a] + "'");
        else if (zshFunctions[a]) print(cmd==='type' ? a + ' is a shell function' : '/usr/bin/' + a);
        else {
          const builtins2 = ['cd','ls','cat','echo','pwd','mkdir','rm','cp','mv','touch','grep',
            'find','wc','head','tail','which','source','export','alias','history','clear','date',
            'env','printenv','help','man','node','js','wasm','set','unset','type','alias','typeset',
          ];
          if (builtins2.includes(a)) print(cmd==='type' ? a + ' is a shell builtin' : '/usr/bin/' + a);
          else { printErr(a + ': not found'); return 1; }
        }
      }
      return 0;
    }

    // ── Shell control ─────────────────────────────────────────────
    case 'source': case '.': {
      if (!rest[0]) { printErr('source: filename argument required'); return 1; }
      try {
        const content = await fsReadFile(zshResolve(rest[0]));
        await zshRunScript(content, rest[0]);
      } catch(e) { printErr(rest[0] + ': ' + e.message); return 1; }
      return 0;
    }
    case 'exit': case 'logout': {
      zshWrite(C.byellow + '[Process completed]' + C.reset + '\r\n');
      return parseInt(rest[0]) || 0;
    }
    case 'return': {
      zshLastExit = parseInt(rest[0]) || 0;
      return zshLastExit;
    }
    case 'set': {
      if (!rest.length) {
        for (const [k,v] of Object.entries({...zshEnv,...zshVars})) print(k + '=' + v);
        return 0;
      }
      if (rest[0] === '-e') { /* errexit */ }
      return 0;
    }

    // ── zsh-specific ─────────────────────────────────────────────
    case 'zsh-version': case 'zsh_version':
      print(C.bgreen + 'zsh 5.9 (void-browser wasm-js, ' + new Date().getFullYear() + ')' + C.reset);
      return 0;
    case 'zstyle': return 0; // no-op
    case 'autoload': return 0; // no-op
    case 'compinit': zshPrintInfo('Completion initialized.'); return 0;
    case 'compdef': return 0; // no-op
    case 'zle': return 0; // no-op

    // ── Clear ─────────────────────────────────────────────────────
    case 'clear': case 'reset': zshTerm.clear(); return 0;

    // ── VOID-specific ─────────────────────────────────────────────
    case 'open': case 'code': {
      const fp = zshResolve(rest[0] || '.');
      const st = await fsStat(fp).catch(()=>null);
      if (st && st.isDirectory()) {
        zshCwd = fp;
        zshPrintInfo('Changed to: ' + fp);
      } else {
        // Try to open in editor
        if (typeof openFileInEditor === 'function') {
          openFileInEditor(fp);
          zshPrintInfo('Opened: ' + fp);
        }
      }
      return 0;
    }
    case 'node': case 'js': {
      // ── JS executor with VFS require, console, process ─────────────
      const target = rest[0];
      if (!target) { printErr('Usage: node <file.js> [args]\n       node -e "code"'); return 1; }

      let code;
      if (target === '-e') {
        code = rest.slice(1).join(' ');
        if (!code) { printErr('node -e: missing code'); return 1; }
      } else {
        const fp = zshResolve(target);
        if (!await fsExists(fp).catch(()=>false)) { printErr('node: ' + fp + ': No such file'); return 1; }
        code = await fsReadFile(fp).catch(e => { printErr('node: ' + e.message); return null; });
        if (code === null) return 1;
      }

      // Build a VFS-aware require
      const _require = async (mod) => {
        // 1. try /node_modules/<mod>/index.js or /node_modules/<mod>.js
        for (const p of [
          '/node_modules/' + mod + '/index.js',
          '/node_modules/' + mod + '.js',
          '/node_modules/' + mod,
        ]) {
          if (await fsExists(p).catch(()=>false)) {
            const src = await fsReadFile(p);
            const modFn = new Function('module','exports','require','__dirname','__filename', src);
            const modObj = { exports: {} };
            modFn(modObj, modObj.exports, _require, '/node_modules/' + mod, p);
            return modObj.exports;
          }
        }
        // 2. built-ins
        const builtins = {
          path: { join: (...a) => a.join('/').replace(/\/+/g,'/'), basename: p => p.split('/').pop(), dirname: p => p.split('/').slice(0,-1).join('/') || '/', extname: p => { const b = p.split('/').pop(); const i = b.lastIndexOf('.'); return i>0?b.slice(i):''; }, resolve: (...a) => a.join('/') },
          fs: { readFileSync: p => { printErr('fs.readFileSync: use async readFile in node mode'); return ''; }, writeFileSync: () => {} },
          os: { platform: ()=>'browser', homedir: ()=>'/home', tmpdir: ()=>'/tmp', EOL: '\n' },
          process: { argv: ['node', target||'script', ...rest.slice(1)], env: {...zshVars}, exit: (c=0)=>{ throw Object.assign(new Error('__EXIT__'), {code:c}); }, cwd: ()=>zshCwd, stdout: { write: s=>zshPrintOutput(String(s)) }, stderr: { write: s=>printErr(String(s)) }, version: 'v18.0.0-void', versions: {} },
        };
        if (builtins[mod]) return builtins[mod];
        throw new Error("Cannot find module '" + mod + "'\nHint: run 'npm install " + mod + "' first");
      };

      // Wire console
      const _console = {
        log:   (...a) => zshPrintOutput(a.map(x => typeof x==='object'?JSON.stringify(x,null,2):String(x)).join(' ')),
        error: (...a) => printErr(a.map(x => typeof x==='object'?JSON.stringify(x,null,2):String(x)).join(' ')),
        warn:  (...a) => zshWrite(C.byellow + a.map(x=>String(x)).join(' ') + C.reset + '\r\n'),
        info:  (...a) => zshPrintOutput(a.map(x=>String(x)).join(' ')),
        dir:   (x)    => zshPrintOutput(JSON.stringify(x,null,2)),
        table: (x)    => zshPrintOutput(JSON.stringify(x,null,2)),
        time:  (l='default') => { _console._timers = _console._timers||{}; _console._timers[l] = Date.now(); },
        timeEnd:(l='default')=> { const t=(_console._timers||{})[l]; zshPrintOutput(l+': '+(t?Date.now()-t+'ms':'unknown')); },
      };

      const _process = { argv: ['node', target||'-e', ...rest.slice(1)], env: {...zshVars}, exit: (c=0)=>{ throw Object.assign(new Error('__EXIT__'),{code:c}); }, cwd: ()=>zshCwd, stdout:{write:s=>zshPrintOutput(String(s))}, stderr:{write:s=>printErr(String(s))}, version:'v18.0.0-void', versions:{} };

      try {
        const wrapped = `(async function(require, console, process, __dirname, __filename) {\n${code}\n})`;
        const fn = eval(wrapped);
        await fn(_require, _console, _process, zshCwd, target || '<eval>');
      } catch(e) {
        if (e.message === '__EXIT__') return e.code || 0;
        // show stack with VFS filename
        const msg = e.stack || e.message;
        printErr(msg.replace(/\beval\b.*\n?/g, '').trim() || e.message);
        return 1;
      }
      return 0;
    }

    // ── sh / bash — run a shell script file or inline ─────────────
    case 'sh': case 'bash': {
      const scriptArg = rest[0];
      if (!scriptArg) { printErr('Usage: ' + cmd + ' <script.sh>\n       ' + cmd + ' -c "commands"'); return 1; }

      let scriptSrc;
      if (scriptArg === '-c') {
        scriptSrc = rest.slice(1).join(' ');
        if (!scriptSrc) { printErr(cmd + ' -c: no command string'); return 1; }
      } else {
        const sp = zshResolve(scriptArg);
        if (!await fsExists(sp).catch(()=>false)) { printErr(cmd + ': ' + sp + ': No such file'); return 1; }
        scriptSrc = await fsReadFile(sp).catch(e => { printErr(cmd + ': ' + e.message); return null; });
        if (scriptSrc === null) return 1;
        // Pass remaining args as $1 $2...
        rest.slice(1).forEach((a, i) => { zshVars[String(i+1)] = a; });
      }
      await zshRunScript(scriptSrc, scriptArg, rest.slice(1));
      return zshLastExit;
    }

    // ── npm / npx — VFS package manager via esm.sh ─────────────────
    case 'npm': case 'npx': {
      const sub = rest[0];

      // ── npm install ──────────────────────────────────────────────
      if (cmd === 'npm' && (sub === 'install' || sub === 'i' || sub === 'add')) {
        const pkgs = rest.slice(1).filter(a => !a.startsWith('-'));
        if (!pkgs.length) {
          // npm install with no args — read package.json
          const pkgPath = zshResolve('package.json');
          if (!await fsExists(pkgPath).catch(()=>false)) { printErr('npm: no package.json and no packages specified'); return 1; }
          let pkg;
          try { pkg = JSON.parse(await fsReadFile(pkgPath)); } catch(e) { printErr('npm: invalid package.json'); return 1; }
          const deps = Object.keys({ ...(pkg.dependencies||{}), ...(pkg.devDependencies||{}) });
          if (!deps.length) { zshPrintInfo('Nothing to install.'); return 0; }
          for (const d of deps) pkgs.push(d);
        }

        zshPrintInfo('npm: fetching ' + pkgs.length + ' package(s) via esm.sh…');
        await fsMkdirP('/node_modules');

        for (const pkgSpec of pkgs) {
          // parse name@version
          const atIdx = pkgSpec.lastIndexOf('@');
          const pkgName = atIdx > 0 ? pkgSpec.slice(0, atIdx) : pkgSpec;
          const pkgVer  = atIdx > 0 ? pkgSpec.slice(atIdx+1) : 'latest';
          const esmUrl  = 'https://esm.sh/' + pkgName + (pkgVer !== 'latest' ? '@' + pkgVer : '') + '?bundle&no-dts';

          zshWrite(C.bblack + '  ↓ ' + C.reset + pkgName + '@' + pkgVer + ' ');
          try {
            const resp = await fetch(esmUrl);
            if (!resp.ok) throw new Error('HTTP ' + resp.status + ' from esm.sh');
            const src = await resp.text();
            const modPath = '/node_modules/' + pkgName + '.js';
            await fsWriteFileSafe(modPath, src);
            // write a mini package.json alongside
            await fsWriteFileSafe('/node_modules/' + pkgName + '/index.js', src);
            await fsMkdirP('/node_modules/' + pkgName);
            await fsWriteFileSafe('/node_modules/' + pkgName + '/index.js', src);
            await fsWriteFileSafe('/node_modules/' + pkgName + '/package.json', JSON.stringify({ name: pkgName, version: pkgVer, main: 'index.js' }, null, 2));
            zshWrite(C.bgreen + '✓' + C.reset + '\r\n');

            // update package.json dependencies
            const pkgJsonPath = zshResolve('package.json');
            let pkgJson = {};
            if (await fsExists(pkgJsonPath).catch(()=>false)) {
              try { pkgJson = JSON.parse(await fsReadFile(pkgJsonPath)); } catch(e) {}
            } else {
              pkgJson = { name: zshCwd.split('/').pop() || 'void-project', version: '1.0.0', dependencies: {} };
            }
            pkgJson.dependencies = pkgJson.dependencies || {};
            pkgJson.dependencies[pkgName] = '^' + pkgVer;
            await fsWriteFileSafe(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
          } catch(e) {
            zshWrite(C.bred + '✗' + C.reset + '\r\n');
            printErr('npm: failed to install ' + pkgName + ': ' + e.message);
          }
        }
        await refreshTree();
        return 0;
      }

      // ── npm uninstall ────────────────────────────────────────────
      if (cmd === 'npm' && (sub === 'uninstall' || sub === 'remove' || sub === 'rm' || sub === 'un')) {
        const pkgs = rest.slice(1).filter(a => !a.startsWith('-'));
        for (const pkg of pkgs) {
          try {
            await fsUnlink('/node_modules/' + pkg + '.js').catch(()=>{});
            const idx = '/node_modules/' + pkg + '/index.js';
            if (await fsExists(idx).catch(()=>false)) await fsUnlink(idx).catch(()=>{});
            const pj = '/node_modules/' + pkg + '/package.json';
            if (await fsExists(pj).catch(()=>false)) await fsUnlink(pj).catch(()=>{});
            await fsRmdir('/node_modules/' + pkg).catch(()=>{});
            zshPrintInfo('removed ' + pkg);
            // remove from package.json
            const pkgJsonPath = zshResolve('package.json');
            if (await fsExists(pkgJsonPath).catch(()=>false)) {
              try {
                const p = JSON.parse(await fsReadFile(pkgJsonPath));
                delete (p.dependencies||{})[pkg]; delete (p.devDependencies||{})[pkg];
                await fsWriteFileSafe(pkgJsonPath, JSON.stringify(p, null, 2));
              } catch(e) {}
            }
          } catch(e) { printErr('npm: uninstall ' + pkg + ': ' + e.message); }
        }
        await refreshTree();
        return 0;
      }

      // ── npm list ─────────────────────────────────────────────────
      if (cmd === 'npm' && (sub === 'list' || sub === 'ls')) {
        const nmPath = '/node_modules';
        if (!await fsExists(nmPath).catch(()=>false)) { zshPrintInfo('(no packages installed)'); return 0; }
        const entries = (await fsReaddir(nmPath).catch(()=>[])).filter(e => !e.endsWith('.js'));
        if (!entries.length) { zshPrintInfo('(no packages installed)'); return 0; }
        zshWrite(C.bold + '/node_modules\r\n' + C.reset);
        for (const e of entries) {
          let ver = '';
          try { const pj = JSON.parse(await fsReadFile('/node_modules/' + e + '/package.json')); ver = '@' + pj.version; } catch(_) {}
          zshWrite('├── ' + C.bcyan + e + C.reset + ver + '\r\n');
        }
        return 0;
      }

      // ── npm init ─────────────────────────────────────────────────
      if (cmd === 'npm' && sub === 'init') {
        const name = zshCwd.split('/').pop() || 'void-project';
        const pkgJson = { name, version: '1.0.0', description: '', main: 'index.js', scripts: { start: 'node index.js', test: 'echo "no tests"' }, dependencies: {}, devDependencies: {} };
        await fsWriteFileSafe(zshResolve('package.json'), JSON.stringify(pkgJson, null, 2));
        zshPrintInfo('Wrote package.json');
        await refreshTree();
        return 0;
      }

      // ── npm run ──────────────────────────────────────────────────
      if (cmd === 'npm' && sub === 'run') {
        const scriptName = rest[1];
        const pkgJsonPath = zshResolve('package.json');
        if (!await fsExists(pkgJsonPath).catch(()=>false)) { printErr('npm run: no package.json'); return 1; }
        let pkg; try { pkg = JSON.parse(await fsReadFile(pkgJsonPath)); } catch(e) { printErr('npm: invalid package.json'); return 1; }
        const scripts = pkg.scripts || {};
        if (!scriptName) {
          zshPrintInfo('Available scripts:');
          for (const [k, v] of Object.entries(scripts)) zshWrite('  ' + C.bcyan + k + C.reset + '  ' + v + '\r\n');
          return 0;
        }
        if (!scripts[scriptName]) { printErr('npm run: missing script: ' + scriptName); return 1; }
        zshPrintInfo('> ' + scriptName + ': ' + scripts[scriptName]);
        await zshExec(scripts[scriptName]);
        return zshLastExit;
      }

      // ── npx <pkg> ────────────────────────────────────────────────
      if (cmd === 'npx') {
        const pkgName = rest[0];
        if (!pkgName) { printErr('npx: specify a package'); return 1; }
        // check if already installed
        const modPath = '/node_modules/' + pkgName + '/index.js';
        if (!await fsExists(modPath).catch(()=>false)) {
          zshPrintInfo('npx: installing ' + pkgName + '…');
          await zshExec('npm install ' + pkgName);
        }
        if (!await fsExists(modPath).catch(()=>false)) { printErr('npx: could not install ' + pkgName); return 1; }
        await zshExec('node ' + modPath + ' ' + rest.slice(1).join(' '));
        return zshLastExit;
      }

      // ── npm help ─────────────────────────────────────────────────
      const npmHelp = [
        C.bold + C.bcyan + '  npm — VOID package manager (via esm.sh)' + C.reset,
        '',
        '  ' + C.byellow + 'npm install <pkg>[@ver]' + C.reset + '   install package(s) into /node_modules',
        '  ' + C.byellow + 'npm install' + C.reset + '               install all deps from package.json',
        '  ' + C.byellow + 'npm uninstall <pkg>' + C.reset + '       remove package',
        '  ' + C.byellow + 'npm list' + C.reset + '                  list installed packages',
        '  ' + C.byellow + 'npm init' + C.reset + '                  create package.json',
        '  ' + C.byellow + 'npm run <script>' + C.reset + '          run a script from package.json',
        '  ' + C.byellow + 'npx <pkg> [args]' + C.reset + '          install (if needed) and run package',
        '',
        '  Packages are fetched from esm.sh and saved to /node_modules in VFS.',
        '  Use require("pkg") in node scripts after installing.',
      ];
      npmHelp.forEach(l => zshWrite(l + '\r\n'));
      return 0;
    }
    case 'wasm': {
      const fp2 = rest[0] ? zshResolve(rest[0]) : null;
      if (!fp2) { printErr('Usage: wasm <file.wasm>'); return 1; }
      await runWasm(fp2); switchPanelTab('shell');
      return 0;
    }

    // ── curl / fetch ─────────────────────────────────────────────
    case 'curl': case 'wget': case 'fetch': {
      // Extract URL and flags
      const isCurl = cmd === 'curl', isWget = cmd === 'wget';
      let url = '', method = 'GET', headers = {}, body = null, outputFile = null;
      let showHeaders = false, silent2 = false, followRedir = true, verbose = false;
      let i2 = 0;
      while (i2 < rest.length) {
        const a = rest[i2];
        if ((a === '-o' || a === '--output') && rest[i2+1]) { outputFile = rest[++i2]; }
        else if ((a === '-X' || a === '--request') && rest[i2+1]) { method = rest[++i2].toUpperCase(); }
        else if ((a === '-H' || a === '--header') && rest[i2+1]) {
          const hdr = rest[++i2]; const ci = hdr.indexOf(':');
          if (ci > 0) headers[hdr.slice(0,ci).trim()] = hdr.slice(ci+1).trim();
        }
        else if ((a === '-d' || a === '--data' || a === '--data-raw') && rest[i2+1]) {
          body = rest[++i2]; method = method === 'GET' ? 'POST' : method;
          if (!headers['Content-Type']) headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        else if (a === '--json' && rest[i2+1]) {
          body = rest[++i2]; method = method === 'GET' ? 'POST' : method;
          headers['Content-Type'] = 'application/json'; headers['Accept'] = 'application/json';
        }
        else if (a === '-I' || a === '--head') { method = 'HEAD'; showHeaders = true; }
        else if (a === '-i' || a === '--include') { showHeaders = true; }
        else if (a === '-s' || a === '--silent') { silent2 = true; }
        else if (a === '-v' || a === '--verbose') { verbose = true; }
        else if (a === '-L' || a === '--location') { followRedir = true; }
        else if (!a.startsWith('-')) { url = a; }
        i2++;
      }
      if (!url) { printErr(cmd + ': no URL specified\nUsage: curl [options] <url>'); return 1; }
      if (!url.startsWith('http')) url = 'https://' + url;

      if (!silent2) zshWrite(C.bblack + (isCurl ? '  % ' : '  → ') + C.reset + C.bblue + url + C.reset + '\r\n');
      if (verbose) {
        zshWrite(C.bblack + '> ' + method + ' ' + url + '\r\n' + C.reset);
        for (const [k,v] of Object.entries(headers)) zshWrite(C.bblack + '> ' + k + ': ' + v + '\r\n' + C.reset);
        zshWrite(C.bblack + '>\r\n' + C.reset);
      }

      try {
        const fetchOpts = { method, headers };
        if (body) fetchOpts.body = body;
        const resp = await fetch(url, fetchOpts);
        if (verbose || showHeaders) {
          zshWrite(C.bblack + '< HTTP/' + (resp.status >= 200 ? '1.1' : '1.0') + ' ' + resp.status + ' ' + resp.statusText + '\r\n' + C.reset);
          resp.headers.forEach((v,k) => zshWrite(C.bblack + '< ' + k + ': ' + v + '\r\n' + C.reset));
          zshWrite(C.bblack + '<\r\n' + C.reset);
        }
        if (!silent2) {
          const icon = resp.ok ? C.bgreen + '✓' : C.bred + '✗';
          zshWrite(icon + C.reset + ' HTTP ' + resp.status + ' ' + resp.statusText + '\r\n');
        }
        if (method === 'HEAD') return resp.ok ? 0 : 1;

        const ct = resp.headers.get('content-type') || '';
        const isJson = ct.includes('json');
        const isBinary = ct.includes('octet-stream') || ct.includes('image') || ct.includes('audio') || ct.includes('video') || ct.includes('pdf');

        if (outputFile || isBinary) {
          const buf = await resp.arrayBuffer();
          const bytes = new Uint8Array(buf);
          // Store as binary in VFS
          const dest = outputFile ? zshResolve(outputFile) : zshResolve(url.split('/').pop() || 'output.bin');
          // Write as base64-tagged content for VFS
          const b64 = btoa(String.fromCharCode(...bytes.slice(0,1024*1024)));
          await fsWriteFileSafe(dest, b64);
          zshPrintInfo('Saved ' + bytes.length + ' bytes → ' + dest);
        } else {
          const text = await resp.text();
          let out = text;
          if (isJson) {
            try { out = JSON.stringify(JSON.parse(text), null, 2); } catch(e) {}
          }
          if (outputFile) {
            await fsWriteFileSafe(zshResolve(outputFile), out);
            zshPrintInfo('Saved → ' + zshResolve(outputFile));
          } else {
            // Pretty-print JSON with colors
            if (isJson && !silent) {
              const colored = out
                .replace(/"([^"]+)":/g, C.bcyan + '"$1"' + C.reset + ':')
                .replace(/: "([^"]*)"/g, ': ' + C.bgreen + '"$1"' + C.reset)
                .replace(/: (true|false)/g, ': ' + C.byellow + '$1' + C.reset)
                .replace(/: (\d+\.?\d*)/g, ': ' + C.bpurple + '$1' + C.reset)
                .replace(/: null/g, ': ' + C.bblack + 'null' + C.reset);
              zshWrite(colored.replace(/\n/g, '\r\n') + '\r\n');
            } else {
              if (!silent) zshWrite(out.replace(/\n/g, '\r\n') + (out.endsWith('\n') ? '' : '\r\n'));
              else return out + '\n';
            }
          }
        }
        return resp.ok ? 0 : 1;
      } catch(e) {
        printErr(cmd + ': ' + e.message);
        if (e.message.includes('fetch') || e.message.includes('network') || e.message.includes('CORS')) {
          zshWrite(C.bblack + '  Network is ' + (navigator.onLine ? 'online but CORS/blocked' : 'offline') + '\r\n' + C.reset);
        }
        return 1;
      }
    }

    // ── git ───────────────────────────────────────────────────────
    case 'git': {
      const sub = rest[0], gitArgs = rest.slice(1);
      // VFS-based git simulation
      const gitDir = zshCwd + '/.git';
      const hasGit = await fsExists(gitDir).catch(() => false);

      const ensureGit = async () => {
        if (!hasGit) { printErr('git: not a git repository (or any of the parent directories): .git'); return false; }
        return true;
      };
      const readGitFile = async (rel) => fsReadFile(gitDir + '/' + rel).catch(() => '');
      const writeGitFile = async (rel, content) => fsWriteFileSafe(gitDir + '/' + rel, content);

      switch(sub) {
        case 'init': {
          await fsMkdir(gitDir).catch(()=>{});
          await fsMkdir(gitDir + '/refs').catch(()=>{});
          await fsMkdir(gitDir + '/refs/heads').catch(()=>{});
          await fsMkdir(gitDir + '/objects').catch(()=>{});
          await writeGitFile('HEAD', 'ref: refs/heads/main\n');
          await writeGitFile('config', '[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n\tbare = false\n');
          await writeGitFile('description', 'Unnamed repository; edit this file to name the repository.\n');
          await writeGitFile('COMMIT_EDITMSG', '');
          await writeGitFile('index', ''); // staged files list
          await writeGitFile('log', ''); // commit log
          zshWrite(C.bgreen + 'Initialized empty Git repository in ' + zshCwd + '/.git/' + C.reset + '\r\n');
          return 0;
        }
        case 'status': {
          if (!await ensureGit()) return 1;
          const branch = (await readGitFile('HEAD')).trim().replace('ref: refs/heads/', '');
          const staged = (await readGitFile('index')).split('\n').filter(Boolean);
          zshWrite(C.bold + 'On branch ' + branch + C.reset + '\r\n');
          // List VFS files vs staged
          const allFiles = [];
          const walkFiles = async (dir, base) => {
            const items = await fsReaddir(dir).catch(() => []);
            for (const item of items) {
              if (item === '.git') continue;
              const fp = dir.replace(/\/?$/,'/') + item;
              const st = await fsStat(fp).catch(()=>null);
              if (st && st.isDirectory()) await walkFiles(fp, (base?base+'/':'')+item);
              else allFiles.push((base?base+'/':'')+item);
            }
          };
          await walkFiles(zshCwd, '');
          const stagedSet = new Set(staged);
          const untracked = allFiles.filter(f => !stagedSet.has(f));
          if (staged.length === 0 && untracked.length === 0) {
            zshWrite('nothing to commit, working tree clean\r\n');
          } else {
            if (staged.length > 0) {
              zshWrite(C.bgreen + 'Changes to be committed:' + C.reset + '\r\n');
              staged.forEach(f => zshWrite(C.bgreen + '\tnew file:   ' + f + C.reset + '\r\n'));
              zshWrite('\r\n');
            }
            if (untracked.length > 0) {
              zshWrite(C.bred + 'Untracked files:' + C.reset + '\r\n');
              untracked.forEach(f => zshWrite(C.bred + '\t' + f + C.reset + '\r\n'));
            }
          }
          return 0;
        }
        case 'add': {
          if (!await ensureGit()) return 1;
          const staged = (await readGitFile('index')).split('\n').filter(Boolean);
          const stagedSet = new Set(staged);
          const toAdd = gitArgs.includes('.') || gitArgs.includes('-A') ? null : gitArgs;
          if (!toAdd || toAdd.length === 0) {
            // Add all
            const allFiles = [];
            const walkFiles = async (dir, base) => {
              const items = await fsReaddir(dir).catch(() => []);
              for (const item of items) {
                if (item === '.git') continue;
                const fp = dir.replace(/\/?$/,'/') + item;
                const st = await fsStat(fp).catch(()=>null);
                if (st && st.isDirectory()) await walkFiles(fp, (base?base+'/':'')+item);
                else allFiles.push((base?base+'/':'')+item);
              }
            };
            await walkFiles(zshCwd, '');
            allFiles.forEach(f => stagedSet.add(f));
          } else {
            for (const f of toAdd) stagedSet.add(f.startsWith('/') ? f.replace(zshCwd+'/', '') : f);
          }
          await writeGitFile('index', [...stagedSet].join('\n') + '\n');
          zshPrintInfo('staged: ' + [...stagedSet].join(', '));
          return 0;
        }
        case 'commit': {
          if (!await ensureGit()) return 1;
          const mi = gitArgs.indexOf('-m');
          const msg = mi >= 0 ? gitArgs[mi+1] : (gitArgs.find(a=>!a.startsWith('-')) || 'Update');
          const staged = (await readGitFile('index')).split('\n').filter(Boolean);
          if (staged.length === 0) { printErr('nothing to commit'); return 1; }
          const hash = Math.random().toString(16).slice(2,10) + Math.random().toString(16).slice(2,10);
          const ts = new Date().toISOString();
          const author = (await readGitFile('config')).match(/name\s*=\s*(.+)/)?.[1]?.trim() || 'void <void@void>';
          const logEntry = hash.slice(0,7) + ' ' + ts + ' ' + author + '\n    ' + msg + '\n\n';
          const log = await readGitFile('log');
          await writeGitFile('log', log + logEntry);
          await writeGitFile('refs/heads/' + ((await readGitFile('HEAD')).trim().replace('ref: refs/heads/', '')), hash + '\n');
          await writeGitFile('COMMIT_EDITMSG', msg + '\n');
          await writeGitFile('index', ''); // clear staged
          zshWrite(C.bgreen + '[' + ((await readGitFile('HEAD')).trim().replace('ref: refs/heads/','')) + ' ' + hash.slice(0,7) + '] ' + msg + C.reset + '\r\n');
          zshWrite(' ' + staged.length + ' file' + (staged.length !== 1 ? 's' : '') + ' changed\r\n');
          return 0;
        }
        case 'log': {
          if (!await ensureGit()) return 1;
          const log = await readGitFile('log');
          if (!log.trim()) { zshWrite('No commits yet\r\n'); return 0; }
          const entries = log.trim().split('\n\n').filter(Boolean).reverse();
          const n = gitArgs.includes('--oneline') ? 999 : (gitArgs.includes('-n') ? parseInt(gitArgs[gitArgs.indexOf('-n')+1]) : entries.length);
          entries.slice(0, n).forEach(entry => {
            const lines = entry.split('\n');
            const firstLine = lines[0];
            const [hash,,ts,,author] = firstLine.split(' ');
            const message = lines[1]?.trim() || '';
            if (gitArgs.includes('--oneline')) {
              zshWrite(C.byellow + (hash||'???????').slice(0,7) + C.reset + ' ' + message + '\r\n');
            } else {
              zshWrite(C.byellow + 'commit ' + (hash||'?'.repeat(40)).padEnd(40, '0') + C.reset + '\r\n');
              zshWrite('Author: ' + (author || 'void <void@void>') + '\r\n');
              zshWrite('Date:   ' + (ts||new Date().toISOString()) + '\r\n\r\n');
              zshWrite('    ' + message + '\r\n\r\n');
            }
          });
          return 0;
        }
        case 'branch': {
          if (!await ensureGit()) return 1;
          const head = (await readGitFile('HEAD')).trim().replace('ref: refs/heads/', '');
          if (gitArgs.length === 0) {
            // list branches
            const items = await fsReaddir(gitDir + '/refs/heads').catch(() => []);
            for (const b of items) {
              zshWrite((b === head ? C.bgreen + '* ' : '  ') + b + C.reset + '\r\n');
            }
          } else {
            // create branch
            const newBranch = gitArgs.find(a => !a.startsWith('-'));
            if (newBranch) {
              const headHash = await readGitFile('refs/heads/' + head).catch(() => '');
              await writeGitFile('refs/heads/' + newBranch, headHash || '0000000\n');
              zshPrintInfo('Branch \'' + newBranch + '\' created');
            }
          }
          return 0;
        }
        case 'checkout': case 'switch': {
          if (!await ensureGit()) return 1;
          const newBranch2 = gitArgs.find(a => !a.startsWith('-'));
          const createNew = gitArgs.includes('-b') || gitArgs.includes('-c');
          if (!newBranch2) { printErr('git ' + sub + ': no branch specified'); return 1; }
          if (createNew) {
            const head = (await readGitFile('HEAD')).trim().replace('ref: refs/heads/', '');
            const headHash = await readGitFile('refs/heads/' + head).catch(() => '');
            await writeGitFile('refs/heads/' + newBranch2, headHash || '0000000\n');
            zshPrintInfo('Switched to a new branch \'' + newBranch2 + '\'');
          } else {
            const exists = await fsExists(gitDir + '/refs/heads/' + newBranch2).catch(() => false);
            if (!exists) { printErr('git: branch \'' + newBranch2 + '\' not found'); return 1; }
            zshPrintInfo('Switched to branch \'' + newBranch2 + '\'');
          }
          await writeGitFile('HEAD', 'ref: refs/heads/' + newBranch2 + '\n');
          return 0;
        }
        case 'diff': {
          if (!await ensureGit()) return 1;
          zshWrite(C.bblack + 'diff --git (VFS diff not implemented — showing modified files)\r\n' + C.reset);
          const staged = (await readGitFile('index')).split('\n').filter(Boolean);
          staged.forEach(f => zshWrite(C.byellow + 'modified: ' + f + C.reset + '\r\n'));
          return 0;
        }
        case 'stash': zshPrintInfo('Stash not implemented in VFS mode'); return 0;
        case 'pull': case 'push': case 'fetch': case 'clone': case 'remote':
          zshWrite(C.byellow + 'git ' + sub + ': no remote configured (VFS mode)\r\n' + C.reset);
          zshWrite(C.bblack + 'Tip: use curl to fetch files from URLs\r\n' + C.reset);
          return 0;
        case 'config': {
          if (!await ensureGit()) return 1;
          if (gitArgs.includes('--global') || gitArgs.includes('--list')) {
            const cfg = await readGitFile('config');
            zshWrite(cfg.replace(/\n/g, '\r\n'));
          } else {
            const key = gitArgs.find(a=>!a.startsWith('-'));
            const val = gitArgs[gitArgs.indexOf(key)+1];
            if (key && val) {
              let cfg = await readGitFile('config');
              cfg += '\t' + key.split('.').pop() + ' = ' + val + '\n';
              await writeGitFile('config', cfg);
              zshPrintInfo('Set ' + key + ' = ' + val);
            }
          }
          return 0;
        }
        case 'reset': {
          if (!await ensureGit()) return 1;
          if (gitArgs.includes('--staged') || gitArgs.includes('HEAD')) {
            await writeGitFile('index', '');
            zshPrintInfo('Unstaged all changes');
          }
          return 0;
        }
        case 'show': {
          if (!await ensureGit()) return 1;
          const log2 = await readGitFile('log');
          const last = log2.trim().split('\n\n').pop();
          if (last) zshWrite(last.replace(/\n/g, '\r\n') + '\r\n');
          return 0;
        }
        case 'tag': {
          if (!await ensureGit()) return 1;
          if (gitArgs.length === 0) {
            const tags = await fsReaddir(gitDir + '/refs/tags').catch(() => []);
            tags.forEach(t => zshWrite(t + '\r\n'));
          } else {
            const tagName = gitArgs.find(a => !a.startsWith('-'));
            const head = (await readGitFile('HEAD')).trim().replace('ref: refs/heads/', '');
            const hash = await readGitFile('refs/heads/' + head).catch(() => '0000000');
            await fsMkdir(gitDir + '/refs/tags').catch(()=>{});
            await writeGitFile('refs/tags/' + tagName, hash);
            zshPrintInfo('Tagged: ' + tagName);
          }
          return 0;
        }
        case 'merge': {
          if (!await ensureGit()) return 1;
          zshWrite(C.byellow + 'Merge not implemented in VFS mode (no actual file diff engine)\r\n' + C.reset);
          return 0;
        }
        case 'blame': {
          if (!await ensureGit()) return 1;
          const file = gitArgs.find(a => !a.startsWith('-'));
          if (!file) { printErr('git blame: no file given'); return 1; }
          try {
            const content = await fsReadFile(zshResolve(file));
            const log3 = await readGitFile('log');
            const lastHash = log3.match(/^([0-9a-f]+)/m)?.[1]?.slice(0,7) || '0000000';
            content.split('\n').forEach((line, i) => {
              zshWrite(C.byellow + lastHash + C.reset + C.bblack + ' (' + new Date().toLocaleDateString() + ')' + C.reset + ' ' + String(i+1).padStart(4) + '  ' + line + '\r\n');
            });
          } catch(e) { printErr('git blame: ' + file + ': not found'); return 1; }
          return 0;
        }
        case '--version': case 'version':
          print('git version 2.43.0 (void-browser)');
          return 0;
        case 'help': case '--help':
          zshWrite([
            C.bold + 'usage: git <command> [<args>]' + C.reset,
            '',
            C.byellow + 'Repository commands:' + C.reset,
            '  init          Create empty repo',
            '  clone         [remote only — not available in VFS]',
            '  status        Show working tree status',
            '  add <file>    Stage files (. or -A for all)',
            '  commit -m msg Record changes',
            '  log           Show commit history (--oneline)',
            '  diff          Show unstaged changes',
            '  branch        List or create branches',
            '  checkout -b   Switch/create branch',
            '  switch -c     Same as checkout -b',
            '  merge         [not available in VFS]',
            '  tag           Create/list tags',
            '  blame <file>  Show line-by-line history',
            '  stash         [stub]',
            '  config        Read/write git config',
            '  reset         Unstage changes',
            '  show          Show last commit',
            '',
            'Remote commands (no-op in VFS):',
            '  pull  push  fetch  remote',
            '',
            C.bblack + 'Use curl to fetch files from URLs' + C.reset,
          ].map(l=>l).join('\r\n') + '\r\n');
          return 0;
        default:
          printErr('git: \'' + sub + '\' is not a git command. See \'git help\'.');
          return 1;
      }
    }

    // ── base64 ───────────────────────────────────────────────────
    case 'base64': {
      const decode = rest.includes('-d') || rest.includes('--decode');
      const file3 = rest.find(a => !a.startsWith('-'));
      const src3 = file3 ? await fsReadFile(zshResolve(file3)).catch(()=>'') : stdin;
      try {
        if (decode) {
          const decoded = atob(src3.trim().replace(/\s/g,''));
          print(decoded);
        } else {
          const encoded = btoa(src3);
          if (!silent) {
            // wrap at 76 chars
            const wrapped = encoded.match(/.{1,76}/g)?.join('\r\n') || encoded;
            zshWrite(wrapped + '\r\n');
          } else return encoded + '\n';
        }
      } catch(e) { printErr('base64: invalid input: ' + e.message); return 1; }
      return 0;
    }

    // ── jq ────────────────────────────────────────────────────────
    case 'jq': {
      const filter = rest.find(a => !a.startsWith('-')) || '.';
      const file4 = rest.filter(a => !a.startsWith('-'))[1];
      const compact = rest.includes('-c'), rawOut = rest.includes('-r'), slurp = rest.includes('-s');
      const src4 = file4 ? await fsReadFile(zshResolve(file4)).catch(()=>null) : stdin;
      if (src4 === null) { printErr('jq: could not read input'); return 1; }
      let data;
      try { data = JSON.parse(src4.trim()); }
      catch(e) { printErr('jq: parse error: ' + e.message); return 1; }
      try {
        // Simple jq filter eval
        const evalFilter = (obj, flt) => {
          flt = flt.trim();
          if (flt === '.') return obj;
          if (flt === 'keys') return Object.keys(obj);
          if (flt === 'values') return Object.values(obj);
          if (flt === 'length') return Array.isArray(obj) ? obj.length : (typeof obj === 'string' ? obj.length : Object.keys(obj).length);
          if (flt === 'type') return Array.isArray(obj) ? 'array' : typeof obj;
          if (flt === 'empty') return undefined;
          if (flt.startsWith('.[]')) { const sub = flt.slice(3).trim(); return (Array.isArray(obj) ? obj : Object.values(obj)).map(v => evalFilter(v, sub || '.')); }
          if (flt.startsWith('.[')) { const end = flt.indexOf(']'); const key = flt.slice(2,end).replace(/['"]/g,''); const rest2 = flt.slice(end+1).trim(); const val = obj[isNaN(key)?key:parseInt(key)]; return rest2 ? evalFilter(val, rest2) : val; }
          if (flt.startsWith('.')) {
            const parts = flt.slice(1).split('.'); let val = obj;
            for (const p of parts) { if (p) val = val?.[p.replace(/\[.*$/,'')]; }
            return val;
          }
          if (flt.startsWith('select(')) { const cond = flt.slice(7,-1); try { return Function('x','return ('+cond.replace(/\./g,'x.')+')?x:undefined')(obj); } catch(e) { return obj; } }
          if (flt.includes('|')) { const [a,b] = flt.split('|'); return evalFilter(evalFilter(obj, a.trim()), b.trim()); }
          return obj;
        };
        const result = evalFilter(data, filter);
        const fmt = (v) => {
          if (rawOut && typeof v === 'string') return v;
          return compact ? JSON.stringify(v) : JSON.stringify(v, null, 2);
        };
        if (Array.isArray(result) && !slurp) {
          for (const item of result) {
            if (item !== undefined) {
              const s = fmt(item);
              if (!silent) {
                // colorize
                const colored = s
                  .replace(/"([^"]+)":/g, C.bcyan + '"$1"' + C.reset + ':')
                  .replace(/: "([^"]*)"/g, ': ' + C.bgreen + '"$1"' + C.reset)
                  .replace(/: (true|false)/g, ': ' + C.byellow + '$1' + C.reset)
                  .replace(/: (null)/g, ': ' + C.bblack + '$1' + C.reset)
                  .replace(/: (-?\d+\.?\d*)/g, ': ' + C.bpurple + '$1' + C.reset);
                zshWrite(colored.replace(/\n/g,'\r\n') + '\r\n');
              } else stdin += s + '\n';
            }
          }
        } else if (result !== undefined) {
          const s = fmt(result);
          if (!silent) {
            const colored = s
              .replace(/"([^"]+)":/g, C.bcyan + '"$1"' + C.reset + ':')
              .replace(/: "([^"]*)"/g, ': ' + C.bgreen + '"$1"' + C.reset)
              .replace(/: (true|false)/g, ': ' + C.byellow + '$1' + C.reset)
              .replace(/: (null)/g, ': ' + C.bblack + '$1' + C.reset)
              .replace(/: (-?\d+\.?\d*)/g, ': ' + C.bpurple + '$1' + C.reset);
            zshWrite(colored.replace(/\n/g,'\r\n') + '\r\n');
          } else return s + '\n';
        }
      } catch(e) { printErr('jq: filter error: ' + e.message); return 1; }
      return 0;
    }

    // ── xxd / od ──────────────────────────────────────────────────
    case 'xxd': case 'od': case 'hexdump': {
      const fp5 = rest.find(a => !a.startsWith('-'));
      const src5 = fp5 ? await fsReadFile(zshResolve(fp5)).catch(()=>null) : stdin;
      if (src5 === null) { printErr(cmd + ': cannot open file'); return 1; }
      const bytes5 = new TextEncoder().encode(src5);
      const cols5 = 16;
      const isOd = cmd === 'od';
      const limit = rest.includes('-l') ? parseInt(rest[rest.indexOf('-l')+1]) : bytes5.length;
      for (let off = 0; off < Math.min(bytes5.length, limit); off += cols5) {
        const chunk = bytes5.slice(off, off + cols5);
        const addrStr = isOd ? String(off).padStart(7,'0') : off.toString(16).padStart(8,'0') + ':';
        const hexStr = [...chunk].map(b => b.toString(16).padStart(2,'0')).join(' ');
        const ascStr = [...chunk].map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
        if (isOd) {
          print(addrStr + '  ' + [...chunk].map(b=>b.toString(8).padStart(3,'0')).join(' '));
        } else {
          const padHex = hexStr.padEnd(cols5 * 3 - 1 + (cols5 > 8 ? 1 : 0));
          print(addrStr + ' ' + padHex + '  ' + ascStr);
        }
      }
      return 0;
    }

    // ── hexedit — open hex editor panel ──────────────────────────
    case 'hexedit': case 'hexview': {
      const fp6 = rest.find(a => !a.startsWith('-'));
      if (!fp6) { printErr('Usage: hexedit <file>'); return 1; }
      const resolved = zshResolve(fp6);
      if (!await fsExists(resolved).catch(()=>false)) { printErr('hexedit: ' + fp6 + ': No such file'); return 1; }
      try {
        const content = await fsReadFile(resolved);
        switchPanelTab('hex');
        hexLoadContent(content, resolved);
        zshPrintInfo('Opened in hex editor: ' + resolved);
      } catch(e) { printErr('hexedit: ' + e.message); return 1; }
      return 0;
    }

    // ── sha256sum / md5sum / cksum ────────────────────────────────
    case 'sha256sum': case 'sha1sum': case 'md5sum': case 'sha512sum': case 'cksum': {
      const fp7 = rest.find(a => !a.startsWith('-'));
      const src6 = fp7 ? await fsReadFile(zshResolve(fp7)).catch(()=>null) : stdin;
      if (src6 === null) { printErr(cmd + ': cannot read input'); return 1; }
      const encoded6 = new TextEncoder().encode(src6);
      // Use Web Crypto if available, fallback to simple hash
      let hash6 = '';
      try {
        const algo = cmd.includes('512') ? 'SHA-512' : cmd.includes('1') ? 'SHA-1' : cmd.includes('md5') ? 'SHA-256' : 'SHA-256';
        const hashBuf = await crypto.subtle.digest(algo, encoded6);
        hash6 = [...new Uint8Array(hashBuf)].map(b=>b.toString(16).padStart(2,'0')).join('');
      } catch(e) {
        // simple djb2 fallback
        let h = 5381;
        for (const b of encoded6) h = ((h<<5)+h+b)|0;
        hash6 = (h>>>0).toString(16).padStart(8,'0').repeat(cmd.includes('512')?16:cmd.includes('1')?5:8);
      }
      if (cmd === 'cksum') print(hash6.slice(0,8) + ' ' + encoded6.length + ' ' + (fp7||'-'));
      else print(hash6 + '  ' + (fp7||'-'));
      return 0;
    }

    // ── strings ───────────────────────────────────────────────────
    case 'strings': {
      const fp8 = rest.find(a=>!a.startsWith('-'));
      const src7 = fp8 ? await fsReadFile(zshResolve(fp8)).catch(()=>'') : stdin;
      const minLen = rest.includes('-n') ? parseInt(rest[rest.indexOf('-n')+1]) : 4;
      const matches7 = src7.match(new RegExp('[\x20-\x7e]{' + minLen + ',}', 'g')) || [];
      matches7.forEach(m => print(m));
      return 0;
    }

    // ── openssl (basic) ───────────────────────────────────────────
    case 'openssl': {
      const sub2 = rest[0];
      if (sub2 === 'base64') {
        const dec = rest.includes('-d');
        const src8 = stdin || '';
        try {
          const result2 = dec ? atob(src8.trim()) : btoa(src8);
          print(result2);
        } catch(e) { printErr('openssl: ' + e.message); return 1; }
      } else if (sub2 === 'rand') {
        const n = parseInt(rest.find(a=>!isNaN(parseInt(a))) || '16');
        const hex2 = rest.includes('-hex');
        const buf2 = new Uint8Array(n);
        crypto.getRandomValues(buf2);
        if (hex2) print([...buf2].map(b=>b.toString(16).padStart(2,'0')).join(''));
        else print(btoa(String.fromCharCode(...buf2)));
      } else if (sub2 === 'version' || sub2 === '--version') {
        print('OpenSSL 3.0.0 (void-browser stub)');
      } else {
        printErr('openssl: ' + (sub2||'') + ' not supported in browser mode');
        return 1;
      }
      return 0;
    }

    // ── nc / netcat (stub) ────────────────────────────────────────
    case 'nc': case 'netcat': case 'ncat':
      zshWrite(C.byellow + 'nc: TCP sockets not available in browser context\r\n' + C.reset);
      zshWrite(C.bblack + 'Use curl for HTTP requests\r\n' + C.reset);
      return 1;

    // ── ping ──────────────────────────────────────────────────────
    case 'ping': {
      const host = rest.find(a=>!a.startsWith('-')) || 'localhost';
      const count2 = rest.includes('-c') ? parseInt(rest[rest.indexOf('-c')+1]) : 4;
      zshWrite(C.bblue + 'PING ' + host + ' via fetch probe\r\n' + C.reset);
      for (let pi = 0; pi < count2; pi++) {
        const t0 = performance.now();
        try {
          await fetch('https://' + host + '/favicon.ico', { mode: 'no-cors', signal: AbortSignal.timeout(2000) });
          const ms = (performance.now()-t0).toFixed(1);
          zshWrite('64 bytes from ' + host + ': icmp_seq=' + (pi+1) + ' ttl=64 time=' + ms + ' ms\r\n');
        } catch(e) {
          zshWrite(C.bblack + 'Request timeout for icmp_seq ' + (pi+1) + '\r\n' + C.reset);
        }
        if (pi < count2-1) await new Promise(r=>setTimeout(r,1000));
      }
      return 0;
    }

    // ── nslookup / dig ────────────────────────────────────────────
    case 'nslookup': case 'dig': case 'host': {
      const dhost = rest.find(a=>!a.startsWith('-')&&!a.startsWith('@')) || '';
      if (!dhost) { printErr(cmd + ': no hostname given'); return 1; }
      try {
        const resp2 = await fetch('https://dns.google/resolve?name=' + encodeURIComponent(dhost) + '&type=A');
        const json2 = await resp2.json();
        if (cmd === 'dig') {
          zshWrite(C.bblack + ';; QUESTION SECTION:\r\n;' + dhost + '.\t\tIN\tA\r\n\r\n;; ANSWER SECTION:\r\n' + C.reset);
          (json2.Answer||[]).forEach(a => zshWrite(a.name + '\t' + a.TTL + '\tIN\t' + (a.type===1?'A':'AAAA') + '\t' + a.data + '\r\n'));
        } else {
          (json2.Answer||[{data:'(no records)'}]).forEach(a => zshWrite('Name:\t' + dhost + '\r\nAddress: ' + a.data + '\r\n'));
        }
      } catch(e) { printErr(cmd + ': ' + e.message); return 1; }
      return 0;
    }

    // ── ps / top (stubs) ──────────────────────────────────────────
    case 'ps': {
      print('  PID TTY          TIME CMD');
      print('    1 pts/0    00:00:00 zsh');
      print('   42 pts/0    00:00:00 ps');
      return 0;
    }
    case 'top': case 'htop': {
      zshWrite(C.bold + 'top - ' + new Date().toTimeString().split(' ')[0] + ' up ' + Math.floor(performance.now()/60000) + ' min\r\n' + C.reset);
      zshWrite('Tasks:   2 total,   1 running,   1 sleeping\r\n');
      zshWrite('Mem: browser-managed, no direct access\r\n\r\n');
      zshWrite(C.bold + '  PID USER   PR  NI    VIRT CMD\r\n' + C.reset);
      zshWrite('    1 void   20   0  browser zsh\r\n');
      return 0;
    }
    case 'kill': case 'pkill': case 'killall':
      zshPrintInfo('No killable processes in VFS mode');
      return 0;

    // ── python / python3 ──────────────────────────────────────────
    case 'python3': case 'python': {
      const pyCode = rest.join(' ');
      if (!pyCode) { printErr(cmd + ': no interactive REPL (pass an expression or -c "code")'); return 1; }
      const actualCode = rest[0] === '-c' ? rest.slice(1).join(' ') : pyCode;
      // Basic Python->JS transpilation for simple cases
      try {
        const jsCode = actualCode
          .replace(/print\((.+)\)/g, 'print($1)')
          .replace(/range\((\d+),\s*(\d+)\)/g, '{start:$1,end:$2}')
          .replace(/#.*/g, '');
        const fn2 = new Function('print', jsCode);
        fn2(t => zshPrintOutput(String(t)));
      } catch(e) { printErr('python: ' + e.message + '\n(Note: only simple Python is supported via JS eval)'); return 1; }
      return 0;
    }

    // ── zip / unzip ────────────────────────────────────────────────
    case 'zip': {
      if (typeof JSZip === 'undefined') { printErr('zip: JSZip not loaded'); return 1; }
      const zipName = rest[0];
      const zipFiles = rest.slice(1).filter(a => !a.startsWith('-'));
      if (!zipName) { printErr('Usage: zip <archive.zip> <files...>'); return 1; }
      const zip = new JSZip();
      for (const f of zipFiles) {
        try {
          const content = await fsReadFile(zshResolve(f));
          zip.file(f, content);
          zshPrintInfo('  adding: ' + f);
        } catch(e) { printErr('zip: ' + f + ': ' + e.message); }
      }
      const blob2 = await zip.generateAsync({ type: 'blob' });
      const buf3 = await blob2.arrayBuffer();
      await fsWriteFileSafe(zshResolve(zipName), String.fromCharCode(...new Uint8Array(buf3)));
      zshPrintInfo('Created: ' + zshResolve(zipName));
      return 0;
    }
    case 'unzip': {
      if (typeof JSZip === 'undefined') { printErr('unzip: JSZip not loaded'); return 1; }
      const zipSrc = rest.find(a=>!a.startsWith('-'));
      if (!zipSrc) { printErr('Usage: unzip <archive.zip>'); return 1; }
      try {
        const content = await fsReadFile(zshResolve(zipSrc));
        const zip2 = await JSZip.loadAsync(content);
        for (const [name, file] of Object.entries(zip2.files)) {
          if (!file.dir) {
            const content2 = await file.async('string');
            await fsWriteFileSafe(zshResolve(name), content2);
            zshPrintInfo('  inflating: ' + name);
          }
        }
      } catch(e) { printErr('unzip: ' + e.message); return 1; }
      return 0;
    }

    // ── tar (basic) ────────────────────────────────────────────────
    case 'tar': {
      const create = rest.includes('-c') || rest.includes('c');
      const extract = rest.includes('-x') || rest.includes('x');
      const list = rest.includes('-t') || rest.includes('t');
      const file5 = rest.find((a,i) => (a==='-f'||a==='f') ? rest[i+1] : false) || rest.find(a=>a.endsWith('.tar')||a.endsWith('.tgz')||a.endsWith('.tar.gz'));
      zshWrite(C.byellow + 'tar: basic VFS tar (no actual compression)\r\n' + C.reset);
      if (create && file5) {
        const files2 = rest.filter(a => !a.startsWith('-') && a !== file5);
        let tarContent = '';
        for (const f of files2) {
          try { tarContent += '=== ' + f + ' ===\n' + await fsReadFile(zshResolve(f)) + '\n'; }
          catch(e) {}
        }
        await fsWriteFileSafe(zshResolve(file5), tarContent);
        zshPrintInfo('Created: ' + file5);
      }
      return 0;
    }

    // ── Help ──────────────────────────────────────────────────────
    case 'help': case 'man': {
      const topic = rest[0];
      if (topic) {
        const manPages = {
          ls: 'ls [OPTIONS] [FILE...]\nList directory contents.\n  -l  long format\n  -a  all files\n  -h  human-readable sizes',
          cd: 'cd [DIR]\nChange directory. ~ = home, - = previous dir.',
          grep: 'grep [OPTIONS] PATTERN [FILE...]\nSearch for PATTERN in files.\n  -i  case insensitive\n  -n  show line numbers\n  -v  invert match\n  -r  recursive',
          find: 'find [DIR] [OPTIONS]\nFind files.\n  -name PATTERN\n  -type f|d\n  -maxdepth N',
          sed: "sed s/PATTERN/REPLACE/[g] [FILE]\nStream editor. Substitute text.",
          awk: "awk '{print $N}' [FILE]\nPattern scanning. $0=line, $1..$N=fields, $NF=last field",
          zsh: 'ZSH — Z Shell (void-browser edition)\nFeatures: arrays, assoc arrays, globbing, parameter expansion,\npipelines, redirections, functions, aliases, history.',
          curl: 'curl [OPTIONS] <url>\nTransfer data from URLs.\n  -X METHOD   HTTP method (GET, POST, PUT, DELETE...)\n  -H "K: V"   Add header\n  -d "data"   POST body\n  --json "x"  POST JSON body\n  -o file     Save to file\n  -i          Include response headers\n  -I          HEAD request only\n  -s          Silent mode\n  -v          Verbose\nJSON responses are pretty-printed with color.',
          wget: 'wget <url>\nDownload file from URL.\nAlias for: curl -o <filename> <url>',
          git: 'git <command> [args]\nVersion control.\nCommands: init status add commit log branch checkout\n          diff stash tag blame config reset show --version\nRun "git help" for full list.',
          jq: "jq <filter> [file]\nJSON processor.\n  .           Identity (pretty-print)\n  .key        Object field\n  .[]         Array/object values\n  .key.sub    Nested field\n  .[0]        Array index\n  length      Length\n  keys        Object keys\n  type        Value type\n  -r          Raw string output\n  -c          Compact output",
          base64: 'base64 [-d] [file]\nEncode/decode base64.\n  -d  decode\nReads from file or stdin.',
          xxd: 'xxd [file]\nHex dump of file.\nShows offset, hex bytes, and ASCII representation.',
          hexedit: 'hexedit <file>\nOpen file in the HEX EDITOR panel.\nNavigate: click bytes, use keyboard\nEdit: click a byte, type 2 hex digits\nSave: save button or hexsave command',
          sha256sum: 'sha256sum [file]\nCompute SHA-256 checksum of file.\nAlso: sha1sum, sha512sum, md5sum, cksum',
          ping: 'ping [-c N] <host>\nTest connectivity via fetch probe.\n  -c N  Count of pings (default 4)',
          nslookup: 'nslookup <hostname>\nDNS lookup via Google DNS-over-HTTPS API.',
          strings: 'strings [-n N] <file>\nExtract printable strings from file.\n  -n N  Minimum string length (default 4)',
          openssl: 'openssl <cmd> [options]\nBasic crypto ops.\n  base64 [-d]   Encode/decode base64\n  rand [-hex] N Generate N random bytes',
          node: 'node <file.js> [args]\nnode -e "code"\nExecute JavaScript.\n  Runs file from VFS or inline code.\n  Full console.log/error/warn support.\n  VFS-aware require() — loads from /node_modules.\n  async/await supported.\n  Built-in require modules: path, os, process, fs (stub)',
          sh: 'sh <script.sh> [args]\nsh -c "commands"\nRun a shell script via the VOID ZSH engine.\n  Supports all built-in shell commands.\n  $1 $2... set from args.',
          bash: 'bash <script.sh> [args]\nbash -c "commands"\nAlias for sh — runs script through the VOID ZSH engine.',
          npm: 'npm install <pkg>[@version]  Install package(s) from esm.sh → /node_modules\nnpm install                  Install all deps in package.json\nnpm uninstall <pkg>          Remove package\nnpm list                     List installed packages\nnpm init                     Create package.json\nnpm run <script>             Run a package.json script\nnpx <pkg> [args]             Install (if needed) and run package',
          npx: 'npx <pkg> [args]\nInstall (if needed) and execute a package.\nFetches from esm.sh, installs to /node_modules, then runs index.js.',
        };
        if (manPages[topic]) {
          zshWrite(C.bold + C.byellow + 'MAN: ' + topic.toUpperCase() + C.reset + '\r\n\r\n');
          zshWrite(manPages[topic].replace(/\n/g, '\r\n') + '\r\n');
        } else { printErr('No manual entry for ' + topic); return 1; }
        return 0;
      }
      const helpText = [
        C.bold + C.bcyan + '  VOID ZSH Shell — Z Shell emulator in the browser' + C.reset,
        C.bblack + '  ──────────────────────────────────────────────────────────────' + C.reset,
        C.byellow + '  Navigation' + C.reset + '  cd  pwd  ls [-la]  find  which  type',
        C.byellow + '  Files     ' + C.reset + '  cat  touch  mkdir  rm [-r]  cp  mv  ln  stat  file  tar  zip  unzip',
        C.byellow + '  Text      ' + C.reset + '  echo  printf  grep  sed  awk  sort  uniq  cut  tr  wc  head  tail  tee  xargs',
        C.byellow + '  Shell     ' + C.reset + '  export  env  alias  source  history  fc  set  unset',
        C.byellow + '  ZSH       ' + C.reset + '  setopt  typeset  print  autoload  compinit',
        C.byellow + '  System    ' + C.reset + '  date  uname  whoami  uptime  hostname  sleep  time  ps',
        C.byellow + '  Network   ' + C.reset + '  curl [-X -H -d -o -v]  wget  fetch  ping  nslookup  dig',
        C.byellow + '  Proxy     ' + C.reset + '  proxy connect <ws://host:port> [--mode http|socks5|ovpn|wg] [--token t]',
        C.byellow + '            ' + C.reset + '  proxy disconnect | status | test | fetch <url> | server',
        C.byellow + '  Git       ' + C.reset + '  git init|status|add|commit|log|branch|checkout|diff|tag|blame',
        C.byellow + '  Crypto    ' + C.reset + '  base64 [-d]  sha256sum  md5sum  sha1sum  sha512sum  openssl rand',
        C.byellow + '  Binary    ' + C.reset + '  xxd  od  hexdump  strings  hexedit <file>  jq <filter> <file>',
        C.byellow + '  Run       ' + C.reset + '  node <file|-e "code">  sh/bash <file|-c "cmd">  wasm <file>  python3 -c "code"',
        C.byellow + '  Packages  ' + C.reset + '  npm install <pkg>  npm uninstall  npm list  npm init  npm run  npx <pkg>',
        C.byellow + '  IO        ' + C.reset + '  cmd | cmd  cmd > file  cmd >> file  cmd && cmd  cmd || cmd',
        C.byellow + '  Keys      ' + C.reset + '  Tab=complete  ↑↓=history  Ctrl+R=search  Ctrl+L=clear',
        C.byellow + '            ' + C.reset + '  Ctrl+A/E=line start/end  Ctrl+W=del word  Ctrl+K=kill line',
        C.bblack + '  ──────────────────────────────────────────────────────────────' + C.reset,
        '  man <cmd> for detailed help  ·  hexedit <file> opens hex editor',
      ];
      helpText.forEach(l => zshWrite(l + '\r\n'));
      return 0;
    }

    // ── proxy — control the proxy tunnel from shell ───────────────
    case 'proxy': {
      const sub = rest[0];

      if (!sub || sub === 'status') {
        const s = PROXY.connected ? C.bgreen + 'connected' + C.reset : C.bred + 'disconnected' + C.reset;
        zshWrite('proxy: ' + s + (PROXY.connected ? '  mode=' + PROXY.mode : '') + '\r\n');
        if (PROXY.connected) {
          const fmt = n => n < 1024 ? n+'B' : n < 1048576 ? (n/1024).toFixed(1)+'KB' : (n/1048576).toFixed(2)+'MB';
          zshWrite('  tx=' + fmt(PROXY.stats.tx) + '  rx=' + fmt(PROXY.stats.rx) + '  requests=' + PROXY.stats.req + '\r\n');
        }
        return 0;
      }

      if (sub === 'connect') {
        const wsUrl = rest[1];
        if (wsUrl) {
          const el = document.getElementById('proxy-ws-url');
          if (el) el.value = wsUrl;
        }
        const modeArg = rest.indexOf('--mode');
        if (modeArg >= 0 && rest[modeArg+1]) {
          proxySetMode(rest[modeArg+1]);
        }
        const tokenArg = rest.indexOf('--token');
        if (tokenArg >= 0 && rest[tokenArg+1]) {
          const el = document.getElementById('proxy-token');
          if (el) el.value = rest[tokenArg+1];
        }
        switchPanelTab('proxy');
        await proxyConnect();
        return 0;
      }

      if (sub === 'disconnect') {
        proxyDisconnect();
        zshPrintInfo('proxy: disconnected');
        return 0;
      }

      if (sub === 'test') {
        if (!PROXY.connected) { printErr('proxy: not connected'); return 1; }
        await proxyTest();
        return 0;
      }

      if (sub === 'fetch') {
        if (!PROXY.connected) { printErr('proxy fetch: not connected — run: proxy connect <ws://host:port>'); return 1; }
        const url = rest[1];
        if (!url) { printErr('Usage: proxy fetch <url>'); return 1; }
        zshPrintInfo('proxy: fetching ' + url + ' via tunnel…');
        try {
          const resp = await proxyFetchViaWS(url, { method: 'GET' });
          const text = await resp.text();
          zshPrintOutput(text);
        } catch(e) { printErr('proxy fetch: ' + e.message); return 1; }
        return 0;
      }

      if (sub === 'mode') {
        const m = rest[1];
        if (!m) { zshPrintInfo('current mode: ' + PROXY.mode); return 0; }
        if (!['http','socks5','wsx','wstunnel','ovpn','wg'].includes(m)) { printErr('proxy mode: unknown mode ' + m + '\nvalid: http socks5 wsx wstunnel ovpn wg'); return 1; }
        proxySetMode(m);
        zshPrintInfo('proxy mode set to: ' + m);
        return 0;
      }

      if (sub === 'server') {
        await proxyShowServerCode();
        return 0;
      }

      if (sub === 'intercept') {
        const m = rest[1];
        if (!m) { zshPrintInfo('intercept: ' + PROXY.intercept); return 0; }
        PROXY.intercept = m;
        if (m === 'manual') proxyUnpatchFetch();
        else if (PROXY.connected) proxyPatchFetch();
        zshPrintInfo('proxy intercept: ' + m);
        return 0;
      }

      // help
      const proxyHelp = [
        C.bold + C.bcyan + '  proxy — VOID WebSocket proxy tunnel' + C.reset,
        '',
        '  ' + C.byellow + 'proxy connect <ws://host:port>' + C.reset + '   connect to proxy server',
        '  ' + C.byellow + 'proxy connect ... --mode <m>' + C.reset + '     mode: http socks5 wsx wstunnel ovpn wg',
        '  ' + C.byellow + 'proxy connect ... --token <t>' + C.reset + '    auth token',
        '  ' + C.byellow + 'proxy disconnect' + C.reset + '                 close tunnel',
        '  ' + C.byellow + 'proxy status' + C.reset + '                     show connection status',
        '  ' + C.byellow + 'proxy test' + C.reset + '                       test tunnel via ipify.org',
        '  ' + C.byellow + 'proxy fetch <url>' + C.reset + '                fetch URL through tunnel',
        '  ' + C.byellow + 'proxy mode <http|socks5|ovpn|wg>' + C.reset + ' change mode',
        '  ' + C.byellow + 'proxy intercept <all|external|manual>' + C.reset + '',
        '  ' + C.byellow + 'proxy server' + C.reset + '                     write server source to VFS',
        '',
        '  Start server: ' + C.bblack + 'node void-proxy-server.js' + C.reset + ' or ' + C.bblack + 'npx void-proxy-server' + C.reset,
        '  GUI: open the ' + C.bblack + 'PROXY' + C.reset + ' panel tab',
      ];
      proxyHelp.forEach(l => zshWrite(l + '\r\n'));
      return 0;
    }

    // ── Default: try running as file ──────────────────────────────
    default: {
      // Try as script file
      const fp3 = zshResolve(cmd);
      if (await fsExists(fp3).catch(() => false)) {
        try {
          const content = await fsReadFile(fp3);
          await zshRunScript(content, cmd, rest);
          return zshLastExit;
        } catch(e) { printErr(e.message); return 1; }
      }
      printErr(cmd + ': command not found');
      return 127;
    }
  }
  zshLastExit = 0;
  return 0;
}

async function zshRunScript(content, name, args) {
  args = args || [];
  const lines = content.split('\n');
  let i = lines[0].startsWith('#!') ? 1 : 0;
  while (i < lines.length) {
    let line = lines[i].trimEnd(); i++;
    // Multi-line: detect function defs, if blocks
    if (line.endsWith('{') || line.endsWith('do') || line.match(/^(if|while|for|until)\b/)) {
      let block = line;
      while (i < lines.length && !lines[i].trim().match(/^(}|fi|done|esac)$/)) {
        block += '\n' + lines[i]; i++;
      }
      if (i < lines.length) block += '\n' + lines[i++];
      await zshExecBlock(block);
      continue;
    }
    const t = line.trim();
    if (!t || t.startsWith('#')) continue;
    await zshExec(t);
  }
}

async function zshExecBlock(block) {
  // Handle function declarations
  const fnM = block.match(/^(?:function\s+)?([A-Za-z_][A-Za-z0-9_-]*)\s*\(\s*\)\s*\{([\s\S]*)\}$/m);
  if (fnM) {
    const name = fnM[1];
    const body = fnM[2].trim().split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
    zshFunctions[name] = body;
    return;
  }
  // For/while/if blocks — basic impl
  await zshExec(block.split('\n')[0]); // fallback
}

// ── Tab completion ─────────────────────────────────────────────────
async function zshComplete(line, cursorPos) {
  const before = line.slice(0, cursorPos);
  const tokens = zshTokenize(before.trim());
  const isFirstToken = tokens.length <= 1 && !before.endsWith(' ');
  const lastToken = tokens[tokens.length - 1] || '';
  const lastTokenStart = before.lastIndexOf(lastToken);

  let matches = [];

  if (isFirstToken) {
    // Complete command: builtins + aliases + functions + executables in VFS
    const prefix = lastToken;
    const builtinsAll = ['cd','ls','cat','echo','pwd','mkdir','rm','cp','mv','touch','grep','find',
      'wc','head','tail','sed','awk','sort','uniq','cut','tr','tee','xargs','which','type','source',
      'export','alias','unalias','history','fc','clear','reset','date','uname','whoami','uptime',
      'hostname','sleep','time','let','expr','read','print','printf','setopt','unsetopt','typeset',
      'declare','local','set','unset','env','printenv','node','js','sh','bash','wasm','open','code','help','man',
      'npm','npx','proxy','zsh-version','true','false','exit','return','compinit','autoload','zstyle',
    ];
    matches = [
      ...builtinsAll.filter(b => b.startsWith(prefix)),
      ...Object.keys(zshAliases).filter(a => a.startsWith(prefix)),
      ...Object.keys(zshFunctions).filter(f => f.startsWith(prefix)),
    ];
  } else {
    // Complete file/directory
    let prefix = lastToken;
    let dirPart = '', filePart = prefix;
    if (prefix.includes('/')) {
      dirPart = prefix.replace(/\/[^/]*$/, '/');
      filePart = prefix.slice(prefix.lastIndexOf('/') + 1);
    } else if (prefix.startsWith('~')) {
      dirPart = '';
      filePart = prefix;
    }
    const resolvedDir = dirPart ? zshResolve(dirPart) : zshCwd;
    const items = await fsReaddir(resolvedDir).catch(() => []);
    matches = items.filter(i => i.startsWith(filePart)).map(i => dirPart + i);
  }

  return { matches, prefix: lastToken };
}

// ── Key input handler ──────────────────────────────────────────────
function zshHandleData(data) {
  const code = data.charCodeAt(0);

  // Control sequences
  if (data === '\r' || data === '\n') {
    // Enter
    zshWrite('\r\n');
    const cmd = zshCurrentLine.trim();
    zshCurrentLine = ''; zshCursorPos = 0;
    if (cmd) {
      if (zshOptions.histignorespace && cmd.startsWith(' ')) {
        // don't add to history
      } else if (zshOptions.histignoredups && zshHistory[zshHistory.length-1] === cmd) {
        // duplicate
      } else {
        zshHistory.push(cmd);
        if (zshHistory.length > 10000) zshHistory.shift();
      }
      zshHistIdx = -1;
    }
    if (!cmd) { zshShowPrompt(); return; }
    zshRunning = true;
    zshExec(cmd).then(exit => {
      zshLastExit = exit || 0;
      zshRunning = false;
      zshShowPrompt();
    }).catch(e => {
      zshPrintErr('internal error: ' + e.message);
      zshRunning = false;
      zshShowPrompt();
    });
    return;
  }

  if (data === '\x7f' || data === '\b') {
    // Backspace
    if (zshCursorPos > 0) {
      const newLine = zshCurrentLine.slice(0, zshCursorPos-1) + zshCurrentLine.slice(zshCursorPos);
      zshRefreshLine(zshCurrentLine, newLine, zshCursorPos - 1);
    }
    return;
  }

  if (data === '\x03') {
    // Ctrl+C
    zshWrite('^C\r\n');
    zshCurrentLine = ''; zshCursorPos = 0;
    zshRunning = false;
    zshShowPrompt();
    return;
  }

  if (data === '\x04') {
    // Ctrl+D
    if (zshCurrentLine === '') {
      zshWrite(C.byellow + '[logout]\r\n' + C.reset);
    }
    return;
  }

  if (data === '\x0c') {
    // Ctrl+L
    zshTerm.clear();
    zshShowPrompt();
    return;
  }

  if (data === '\x01') {
    // Ctrl+A - start of line
    if (zshCursorPos > 0) {
      zshWrite('\x1b[' + zshCursorPos + 'D');
      zshCursorPos = 0;
    }
    return;
  }

  if (data === '\x05') {
    // Ctrl+E - end of line
    const moveRight = zshCurrentLine.length - zshCursorPos;
    if (moveRight > 0) {
      zshWrite('\x1b[' + moveRight + 'C');
      zshCursorPos = zshCurrentLine.length;
    }
    return;
  }

  if (data === '\x17') {
    // Ctrl+W - delete word
    let pos = zshCursorPos;
    while (pos > 0 && zshCurrentLine[pos-1] === ' ') pos--;
    while (pos > 0 && zshCurrentLine[pos-1] !== ' ') pos--;
    const newLine = zshCurrentLine.slice(0, pos) + zshCurrentLine.slice(zshCursorPos);
    zshRefreshLine(zshCurrentLine, newLine, pos);
    return;
  }

  if (data === '\x0b') {
    // Ctrl+K - kill to end of line
    zshRefreshLine(zshCurrentLine, zshCurrentLine.slice(0, zshCursorPos), zshCursorPos);
    return;
  }

  if (data === '\x15') {
    // Ctrl+U - kill to start of line
    const newLine = zshCurrentLine.slice(zshCursorPos);
    zshRefreshLine(zshCurrentLine, newLine, 0);
    return;
  }

  if (data === '\x12') {
    // Ctrl+R - history search (simplified: cycle through)
    zshWrite('\r\n[history-search-not-implemented]\r\n');
    zshShowPrompt();
    return;
  }

  if (data === '\x09') {
    // Tab completion
    zshComplete(zshCurrentLine, zshCursorPos).then(({ matches, prefix }) => {
      if (matches.length === 0) {
        // Bell
        zshWrite('\x07');
      } else if (matches.length === 1) {
        const completion = matches[0];
        const suffix = completion.slice(prefix.length);
        const newLine = zshCurrentLine.slice(0, zshCursorPos) + suffix + zshCurrentLine.slice(zshCursorPos);
        zshRefreshLine(zshCurrentLine, newLine, zshCursorPos + suffix.length);
        // Add trailing space or / for directories
        fsStat(zshResolve(newLine.split(' ').pop())).then(st => {
          if (st.isDirectory()) {
            const withSlash = zshCurrentLine.slice(0, zshCursorPos + suffix.length) + '/' + zshCurrentLine.slice(zshCursorPos + suffix.length);
            zshRefreshLine(zshCurrentLine, withSlash, zshCursorPos + suffix.length + 1);
          }
        }).catch(() => {});
      } else {
        // Show completions
        zshWrite('\r\n');
        const cols2 = Math.max(1, Math.floor((zshTerm ? zshTerm.cols : 80) / 24));
        for (let i = 0; i < matches.length; i += cols2) {
          const row = matches.slice(i, i + cols2);
          zshWrite(row.map(m => C.bblue + m + C.reset + ' '.repeat(Math.max(1, 24-m.length))).join('') + '\r\n');
        }
        zshShowPrompt();
        zshWrite(zshColorizeInput(zshCurrentLine));
        const moveLeft2 = zshCurrentLine.length - zshCursorPos;
        if (moveLeft2 > 0) zshWrite('\x1b[' + moveLeft2 + 'D');
      }
    });
    return;
  }

  // Escape sequences (arrow keys, etc.)
  if (data.startsWith('\x1b[')) {
    const seq = data.slice(2);
    switch(seq) {
      case 'A': // Up arrow - history prev
        if (zshHistIdx < zshHistory.length - 1) {
          if (zshHistIdx === -1) zshHistSearch = zshCurrentLine;
          zshHistIdx++;
          const entry = zshHistory[zshHistory.length - 1 - zshHistIdx];
          zshRefreshLine(zshCurrentLine, entry, entry.length);
        }
        return;
      case 'B': // Down arrow - history next
        if (zshHistIdx > 0) {
          zshHistIdx--;
          const entry2 = zshHistory[zshHistory.length - 1 - zshHistIdx];
          zshRefreshLine(zshCurrentLine, entry2, entry2.length);
        } else if (zshHistIdx === 0) {
          zshHistIdx = -1;
          const restored = zshHistSearch || '';
          zshRefreshLine(zshCurrentLine, restored, restored.length);
        }
        return;
      case 'C': // Right arrow
        if (zshCursorPos < zshCurrentLine.length) {
          zshWrite('\x1b[C');
          zshCursorPos++;
        }
        return;
      case 'D': // Left arrow
        if (zshCursorPos > 0) {
          zshWrite('\x1b[D');
          zshCursorPos--;
        }
        return;
      case '3~': // Delete key
        if (zshCursorPos < zshCurrentLine.length) {
          const newLine = zshCurrentLine.slice(0, zshCursorPos) + zshCurrentLine.slice(zshCursorPos+1);
          zshRefreshLine(zshCurrentLine, newLine, zshCursorPos);
        }
        return;
      case 'H': case '1~': // Home
        if (zshCursorPos > 0) { zshWrite('\x1b[' + zshCursorPos + 'D'); zshCursorPos = 0; }
        return;
      case 'F': case '4~': // End
        const ml = zshCurrentLine.length - zshCursorPos;
        if (ml > 0) { zshWrite('\x1b[' + ml + 'C'); zshCursorPos = zshCurrentLine.length; }
        return;
      case '1;5C': case 'f': // Ctrl+Right - word forward
        let npos = zshCursorPos;
        while (npos < zshCurrentLine.length && zshCurrentLine[npos] === ' ') npos++;
        while (npos < zshCurrentLine.length && zshCurrentLine[npos] !== ' ') npos++;
        if (npos > zshCursorPos) { zshWrite('\x1b[' + (npos-zshCursorPos) + 'C'); zshCursorPos = npos; }
        return;
      case '1;5D': case 'b': // Ctrl+Left - word backward
        let bpos = zshCursorPos;
        while (bpos > 0 && zshCurrentLine[bpos-1] === ' ') bpos--;
        while (bpos > 0 && zshCurrentLine[bpos-1] !== ' ') bpos--;
        if (bpos < zshCursorPos) { zshWrite('\x1b[' + (zshCursorPos-bpos) + 'D'); zshCursorPos = bpos; }
        return;
    }
    return; // ignore other escape sequences
  }

  if (data === '\x1b') return; // lone Escape

  // Regular printable character
  if (code >= 32 || data === '\t') {
    if (data === '\t') return; // handled above
    const newLine = zshCurrentLine.slice(0, zshCursorPos) + data + zshCurrentLine.slice(zshCursorPos);
    zshRefreshLine(zshCurrentLine, newLine, zshCursorPos + data.length);
  }
}

// ── xterm.js initialization ────────────────────────────────────────
function initZshTerminal() {
  if (zshInitialized) return;
  zshInitialized = true;

  zshTerm = new Terminal({
    theme: {
      background:      '#080b0f',
      foreground:      '#cdd9e5',
      cursor:          '#00d4ff',
      cursorAccent:    '#080b0f',
      selectionBackground: 'rgba(0,212,255,0.2)',
      black:           '#1c2736',
      red:             '#ff4c6a',
      green:           '#3ddc84',
      yellow:          '#f0c040',
      blue:            '#0099bb',
      magenta:         '#c792ea',
      cyan:            '#00d4ff',
      white:           '#cdd9e5',
      brightBlack:     '#3d5266',
      brightRed:       '#ff4c6a',
      brightGreen:     '#3ddc84',
      brightYellow:    '#f0c040',
      brightBlue:      '#00d4ff',
      brightMagenta:   '#c792ea',
      brightCyan:      '#86e1fb',
      brightWhite:     '#ffffff',
    },
    fontFamily: "'JetBrains Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace",
    fontSize: 12.5,
    lineHeight: 1.4,
    letterSpacing: 0,
    cursorBlink: true,
    cursorStyle: 'bar',
    cursorWidth: 2,
    scrollback: 5000,
    allowProposedApi: true,
    convertEol: false,
    windowsMode: false,
  });

  zshFitAddon = new FitAddon.FitAddon();
  zshTerm.loadAddon(zshFitAddon);

  if (typeof WebLinksAddon !== 'undefined') {
    zshTerm.loadAddon(new WebLinksAddon.WebLinksAddon());
  }

  const container = document.getElementById('xterm-container');
  zshTerm.open(container);
  zshFitAddon.fit();

  // Handle resize
  const resizeObs = new ResizeObserver(() => {
    if (zshFitAddon && zshInitialized) {
      try { zshFitAddon.fit(); } catch(e) {}
    }
  });
  resizeObs.observe(container);

  // Input handler
  zshTerm.onData(zshHandleData);

  // Welcome banner
  zshWrite(C.bold + C.bcyan
    + '  ██╗   ██╗ ██████╗ ██╗██████╗     ███████╗███████╗██╗  ██╗\r\n'
    + '  ██║   ██║██╔═══██╗██║██╔══██╗    ╚══███╔╝██╔════╝██║  ██║\r\n'
    + '  ██║   ██║██║   ██║██║██║  ██║      ███╔╝ ███████╗███████║\r\n'
    + '  ╚██╗ ██╔╝██║   ██║██║██║  ██║     ███╔╝  ╚════██║██╔══██║\r\n'
    + '   ╚████╔╝ ╚██████╔╝██║██████╔╝    ███████╗███████║██║  ██║\r\n'
    + '    ╚═══╝   ╚═════╝ ╚═╝╚═════╝     ╚══════╝╚══════╝╚═╝  ╚═╝\r\n'
    + C.reset
  );
  zshWrite(C.bblack + '  ─────────────────────────────────────────────────────────────\r\n' + C.reset);
  zshWrite('  ' + C.bgreen + C.bold + 'zsh 5.9' + C.reset + C.bblack + ' (void-browser)' + C.reset
    + '  ' + C.bblack + '·  type ' + C.reset + C.byellow + 'help' + C.reset + C.bblack + ' for commands\r\n' + C.reset);
  zshWrite(C.bblack + '  ─────────────────────────────────────────────────────────────\r\n' + C.reset);
  zshWrite('\r\n');

  // Set up default env
  zshEnv.OLDPWD = zshCwd;

  // Load .zshrc if it exists
  fsExists('/home/void/.zshrc').then(exists => {
    if (exists) {
      fsReadFile('/home/void/.zshrc').then(content => {
        return zshRunScript(content, '.zshrc');
      }).catch(() => {}).finally(() => zshShowPrompt());
    } else {
      // Create default .zshrc
      const defaultZshrc = [
        '# VOID ZSH Configuration',
        'export EDITOR=void',
        'export PAGER=less',
        "setopt autocd",
        "setopt histignorespace",
        "setopt histignoredups",
        "setopt sharehistory",
        '',
        '# Aliases',
        "alias ll='ls -la'",
        "alias la='ls -a'",
        "alias l='ls -CF'",
        "alias ..='cd ..'",
        "alias ...='cd ../..'",
        "alias grep='grep --color=auto'",
        '',
        '# Prompt is set by the shell engine',
      ].join('\n');
      fsWriteFileSafe('/home/void/.zshrc', defaultZshrc).catch(()=>{});
      zshShowPrompt();
    }
  }).catch(() => zshShowPrompt());
}

// Activate shell tab → init xterm
document.getElementById('ptab-shell').addEventListener('click', () => {
  setTimeout(() => {
    initZshTerminal();
    if (zshTerm && zshFitAddon) {
      try { zshFitAddon.fit(); } catch(e) {}
      zshTerm.focus();
    }
  }, 50);
});

// Legacy compatibility stubs (other parts of IDE may call these)
function shellPrint(text, cls) {
  if (!zshTerm) return;
  if (cls === 'sh-err') zshPrintErr(text);
  else if (cls === 'sh-info') zshPrintInfo(text);
  else zshPrintOutput(text);
}
async function shellRunScript(content, name, args) {
  await zshRunScript(content, name, args);
}
function shellPromptStr() { return zshCwd + ' % '; }
function shellUpdatePrompt() {} // no-op, handled by xterm

// ═══════════════════════════════════════════════════════════════════
//  HEX EDITOR ENGINE
// ═══════════════════════════════════════════════════════════════════

const HEX = {
  data: null,          // Uint8Array
  original: null,      // Uint8Array (for diff highlighting)
  filePath: null,
  cursorByte: 0,
  selStart: -1,
  selEnd: -1,
  editingNibble: false,
  nibbleHigh: true,    // true = editing high nibble first
  pendingHigh: -1,     // high nibble typed, waiting for low
  bytesPerRow: 16,
  rowsVisible: 0,
  scrollTop: 0,        // first visible row index
  totalRows: 0,
  dirty: false,
};

const HEXCHARS = '0123456789abcdef';

function hexLoadContent(content, filePath) {
  // Convert string content to Uint8Array
  const enc = new TextEncoder();
  HEX.data = enc.encode(content);
  HEX.original = new Uint8Array(HEX.data);
  HEX.filePath = filePath;
  HEX.cursorByte = 0;
  HEX.selStart = -1;
  HEX.selEnd = -1;
  HEX.scrollTop = 0;
  HEX.dirty = false;
  hexRender();
  hexUpdateStatus();
  document.getElementById('hex-filename').textContent = filePath;
}

function hexLoadNativeFile(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    HEX.data = new Uint8Array(e.target.result);
    HEX.original = new Uint8Array(HEX.data);
    HEX.filePath = null; // native file, no VFS path
    HEX.cursorByte = 0;
    HEX.selStart = -1;
    HEX.selEnd = -1;
    HEX.scrollTop = 0;
    HEX.dirty = false;
    hexRender();
    hexUpdateStatus();
    document.getElementById('hex-filename').textContent = '📄 ' + file.name + ' (' + file.size + ' bytes)';
  };
  reader.readAsArrayBuffer(file);
}

function hexRender() {
  if (!HEX.data) return;
  const addrEl = document.getElementById('hex-addr-col');
  const bytesEl = document.getElementById('hex-bytes-col');
  const asciiEl = document.getElementById('hex-ascii-col');
  if (!addrEl || !bytesEl || !asciiEl) return;

  const bpr = HEX.bytesPerRow;
  HEX.totalRows = Math.ceil(HEX.data.length / bpr);

  // Measure visible rows
  const mainEl = document.getElementById('hex-main');
  const lineH = 22; // px per row (approx)
  const availH = mainEl ? mainEl.clientHeight - 12 : 300;
  HEX.rowsVisible = Math.max(4, Math.floor(availH / lineH));

  // Clamp scroll
  HEX.scrollTop = Math.max(0, Math.min(HEX.scrollTop, Math.max(0, HEX.totalRows - HEX.rowsVisible)));

  const startRow = HEX.scrollTop;
  const endRow = Math.min(HEX.totalRows, startRow + HEX.rowsVisible);

  let addrHTML = '', bytesHTML = '', asciiHTML = '';

  // Header row
  addrHTML += '<div style="color:var(--accent);font-size:10px;margin-bottom:2px;opacity:0.7">  Offset  </div>';
  let hdrHex = '<div style="color:var(--accent);font-size:10px;margin-bottom:2px;opacity:0.7">';
  let hdrAsc = '<div style="color:var(--accent);font-size:10px;margin-bottom:2px;opacity:0.7">';
  for (let c = 0; c < bpr; c++) {
    hdrHex += c.toString(16).padStart(2,'0').toUpperCase() + (c === bpr/2-1 ? '  ' : ' ') + ' ';
  }
  for (let c = 0; c < bpr; c++) hdrAsc += c.toString(16).toUpperCase();
  bytesHTML = hdrHex + '</div>';
  asciiHTML = hdrAsc + '</div>';

  for (let row = startRow; row < endRow; row++) {
    const rowStart = row * bpr;
    const rowEnd = Math.min(rowStart + bpr, HEX.data.length);
    const offset = rowStart.toString(16).padStart(8, '0').toUpperCase();
    addrHTML += '<div class="hex-row" style="color:var(--text-faint)">' + offset + '</div>';

    let rowBytes = '<div class="hex-row">';
    let rowAscii = '<div class="hex-row">';

    for (let bi = rowStart; bi < rowEnd; bi++) {
      const b = HEX.data[bi];
      const hex = b.toString(16).padStart(2, '0');
      const isCursor = bi === HEX.cursorByte;
      const isSel = HEX.selStart >= 0 && bi >= Math.min(HEX.selStart, HEX.selEnd) && bi <= Math.max(HEX.selStart, HEX.selEnd);
      const isModified = HEX.original && HEX.original[bi] !== b;
      const isZero = b === 0;
      const isNonPrint = b < 32 || b > 126;

      let cls = 'hex-byte';
      if (isCursor) cls += ' cursor';
      else if (isSel) cls += ' sel';
      else if (isModified) cls += ' modified';
      else if (isZero) cls += ' zero';
      else if (isNonPrint) cls += ' nonprint';

      const gap = (bi - rowStart) === bpr/2 - 1 ? ' style="margin-right:14px"' : '';
      rowBytes += '<span class="' + cls + '"' + gap + ' data-idx="' + bi + '">' + hex + '</span> ';

      const aChar = (b >= 32 && b < 127) ? String.fromCharCode(b) : (b === 0 ? '·' : b < 32 ? '↓' : '×');
      let aCls = 'hex-char';
      if (isCursor) aCls += ' cursor';
      else if (isSel) aCls += ' sel';
      else if (isModified) aCls += ' modified';

      rowAscii += '<span class="' + aCls + '" data-idx="' + bi + '">' + escH(aChar) + '</span>';
    }

    // Pad incomplete last row
    if (rowEnd - rowStart < bpr) {
      const pad = bpr - (rowEnd - rowStart);
      for (let p = 0; p < pad; p++) {
        if ((rowEnd - rowStart + p) === bpr/2 - 1) rowBytes += '<span class="hex-byte" style="opacity:0;margin-right:14px">  </span> ';
        else rowBytes += '<span class="hex-byte" style="opacity:0">  </span> ';
      }
    }

    rowBytes += '</div>';
    rowAscii += '</div>';
    bytesHTML += rowBytes;
    asciiHTML += rowAscii;
  }

  addrEl.innerHTML = addrHTML;
  bytesEl.innerHTML = bytesHTML;
  asciiEl.innerHTML = asciiHTML;

  // Scroll indicator
  const scrollInfo = HEX.totalRows > HEX.rowsVisible
    ? ' [rows ' + (startRow+1) + '-' + endRow + '/' + HEX.totalRows + ']' : '';
  document.getElementById('hex-status-right').textContent =
    (HEX.data ? HEX.data.length : 0) + ' bytes' + scrollInfo;

  // Update offset display
  document.getElementById('hex-offset-display').textContent =
    'OFF: 0x' + HEX.cursorByte.toString(16).padStart(6,'0').toUpperCase();
}

function hexUpdateStatus() {
  if (!HEX.data) return;
  const b = HEX.data[HEX.cursorByte];
  const info = b !== undefined ? [
    '0x' + b.toString(16).padStart(2,'0').toUpperCase(),
    '  dec:' + b,
    '  oct:' + b.toString(8).padStart(3,'0'),
    '  bin:' + b.toString(2).padStart(8,'0'),
    '  char:' + (b >= 32 && b < 127 ? String.fromCharCode(b) : '·'),
  ].join('') : '';

  const sel = HEX.selStart >= 0
    ? '  SEL: ' + Math.abs(HEX.selEnd - HEX.selStart) + 1 + ' bytes'
    : '';

  document.getElementById('hex-status-left').textContent =
    (HEX.filePath ? HEX.filePath : '(no file)') + (HEX.dirty ? ' ●' : '') +
    '  [' + info + ']' + sel;
}

function hexScrollToCursor() {
  const bpr = HEX.bytesPerRow;
  const curRow = Math.floor(HEX.cursorByte / bpr);
  if (curRow < HEX.scrollTop) {
    HEX.scrollTop = curRow;
    hexRender();
  } else if (curRow >= HEX.scrollTop + HEX.rowsVisible) {
    HEX.scrollTop = curRow - HEX.rowsVisible + 1;
    hexRender();
  }
}

// ── Hex editor keyboard handling ──────────────────────────────────
function hexHandleKey(e) {
  if (!HEX.data) return;
  const len = HEX.data.length;
  const bpr = HEX.bytesPerRow;

  // Hex digit input
  const hexInput = '0123456789abcdefABCDEF'.indexOf(e.key) >= 0 && !e.ctrlKey && !e.metaKey;

  if (hexInput) {
    e.preventDefault();
    const nibble = parseInt(e.key, 16);
    if (HEX.pendingHigh === -1) {
      // First nibble (high)
      HEX.pendingHigh = nibble;
      // Show partial edit visually (handled in render as pending)
    } else {
      // Second nibble (low) — commit byte
      const newByte = (HEX.pendingHigh << 4) | nibble;
      HEX.data[HEX.cursorByte] = newByte;
      HEX.pendingHigh = -1;
      HEX.dirty = true;
      // Advance cursor
      if (HEX.cursorByte < len - 1) HEX.cursorByte++;
    }
    hexRender(); hexUpdateStatus();
    return;
  }

  // Clear pending on non-hex key
  HEX.pendingHigh = -1;

  switch (e.key) {
    case 'ArrowRight':
      e.preventDefault();
      if (e.shiftKey) {
        if (HEX.selStart === -1) HEX.selStart = HEX.cursorByte;
        HEX.selEnd = Math.min(len-1, HEX.cursorByte + 1);
        HEX.cursorByte = HEX.selEnd;
      } else {
        HEX.selStart = -1;
        HEX.cursorByte = Math.min(len-1, HEX.cursorByte + 1);
      }
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'ArrowLeft':
      e.preventDefault();
      if (e.shiftKey) {
        if (HEX.selStart === -1) HEX.selStart = HEX.cursorByte;
        HEX.selEnd = Math.max(0, HEX.cursorByte - 1);
        HEX.cursorByte = HEX.selEnd;
      } else {
        HEX.selStart = -1;
        HEX.cursorByte = Math.max(0, HEX.cursorByte - 1);
      }
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'ArrowDown':
      e.preventDefault();
      HEX.cursorByte = Math.min(len-1, HEX.cursorByte + bpr);
      if (!e.shiftKey) HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'ArrowUp':
      e.preventDefault();
      HEX.cursorByte = Math.max(0, HEX.cursorByte - bpr);
      if (!e.shiftKey) HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'Home':
      e.preventDefault();
      HEX.cursorByte = e.ctrlKey ? 0 : Math.floor(HEX.cursorByte/bpr)*bpr;
      if (!e.shiftKey) HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'End':
      e.preventDefault();
      HEX.cursorByte = e.ctrlKey ? len-1 : Math.min(len-1, Math.floor(HEX.cursorByte/bpr)*bpr+bpr-1);
      if (!e.shiftKey) HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'PageDown':
      e.preventDefault();
      HEX.cursorByte = Math.min(len-1, HEX.cursorByte + HEX.rowsVisible * bpr);
      HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'PageUp':
      e.preventDefault();
      HEX.cursorByte = Math.max(0, HEX.cursorByte - HEX.rowsVisible * bpr);
      HEX.selStart = -1;
      hexScrollToCursor(); hexRender(); hexUpdateStatus(); break;
    case 'Tab':
      e.preventDefault();
      // Switch focus between hex and ascii pane (stub)
      break;
    case 'Delete':
      // Zero out byte
      if (HEX.selStart >= 0) {
        const lo = Math.min(HEX.selStart, HEX.selEnd);
        const hi = Math.max(HEX.selStart, HEX.selEnd);
        for (let i = lo; i <= hi; i++) HEX.data[i] = 0;
        HEX.selStart = -1; HEX.dirty = true;
      } else {
        HEX.data[HEX.cursorByte] = 0; HEX.dirty = true;
      }
      hexRender(); hexUpdateStatus(); break;
    case 's':
      if (e.ctrlKey) { e.preventDefault(); hexSave(); }
      break;
    case 'f':
      if (e.ctrlKey) { e.preventDefault(); hexSearch(); }
      break;
    case 'g':
      if (e.ctrlKey) { e.preventDefault(); hexGoTo(); }
      break;
  }
}

function hexByteClick(e) {
  const idx = parseInt(e.target.dataset.idx);
  if (isNaN(idx)) return;
  if (e.shiftKey && HEX.selStart >= 0) {
    HEX.selEnd = idx;
  } else if (e.shiftKey) {
    HEX.selStart = HEX.cursorByte;
    HEX.selEnd = idx;
  } else {
    HEX.selStart = -1;
    HEX.selEnd = -1;
  }
  HEX.cursorByte = idx;
  HEX.pendingHigh = -1;
  hexRender(); hexUpdateStatus();
  document.getElementById('hex-bytes-col').focus();
}

function hexSearch() {
  const query = prompt('Hex search (e.g. "48 65 6c" or text):');
  if (!query || !HEX.data) return;
  let pattern;
  if (/^([0-9a-fA-F]{2}\s*)+$/.test(query.trim())) {
    pattern = query.trim().split(/\s+/).map(h => parseInt(h, 16));
  } else {
    pattern = [...new TextEncoder().encode(query)];
  }
  // Search forward from cursor
  outer: for (let i = HEX.cursorByte + 1; i <= HEX.data.length - pattern.length; i++) {
    for (let j = 0; j < pattern.length; j++) {
      if (HEX.data[i+j] !== pattern[j]) continue outer;
    }
    HEX.cursorByte = i;
    HEX.selStart = i;
    HEX.selEnd = i + pattern.length - 1;
    hexScrollToCursor(); hexRender(); hexUpdateStatus();
    return;
  }
  alert('Pattern not found');
}

function hexGoTo() {
  const input = prompt('Go to offset (hex: 0x1a2b or decimal):');
  if (!input || !HEX.data) return;
  const offset = input.startsWith('0x') || input.startsWith('0X')
    ? parseInt(input, 16) : parseInt(input);
  if (isNaN(offset) || offset < 0 || offset >= HEX.data.length) {
    alert('Invalid offset: ' + input + ' (file size: ' + HEX.data.length + ')');
    return;
  }
  HEX.cursorByte = offset;
  HEX.selStart = -1;
  hexScrollToCursor(); hexRender(); hexUpdateStatus();
}

async function hexSave() {
  if (!HEX.data || !HEX.filePath) {
    alert('No VFS file path — use Export to download');
    return;
  }
  // Decode bytes back to string for VFS
  const dec = new TextDecoder('utf-8', { fatal: false });
  const content = dec.decode(HEX.data);
  await fsWriteFileSafe(HEX.filePath, content);
  HEX.dirty = false;
  HEX.original = new Uint8Array(HEX.data);
  hexRender(); hexUpdateStatus();
  document.getElementById('hex-status-left').textContent = 'Saved: ' + HEX.filePath;
}

function hexExport() {
  if (!HEX.data) return;
  const blob = new Blob([HEX.data], { type: 'application/octet-stream' });
  const name = HEX.filePath ? HEX.filePath.split('/').pop() : 'export.bin';
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 10000);
}

// ── Wire up hex editor events ──────────────────────────────────────
(function initHexEditor() {
  // Bytes column: keyboard + click
  const bytesCol = document.getElementById('hex-bytes-col');
  const asciiCol = document.getElementById('hex-ascii-col');
  if (!bytesCol) return;

  bytesCol.addEventListener('keydown', hexHandleKey);
  bytesCol.addEventListener('click', hexByteClick);
  asciiCol.addEventListener('click', hexByteClick);

  // Mouse wheel scroll
  document.getElementById('hex-main').addEventListener('wheel', (e) => {
    if (!HEX.data) return;
    e.preventDefault();
    const delta = e.deltaY > 0 ? 3 : -3;
    HEX.scrollTop = Math.max(0, Math.min(HEX.scrollTop + delta, Math.max(0, HEX.totalRows - HEX.rowsVisible)));
    hexRender();
  }, { passive: false });

  // Resize observer to re-render on panel resize
  const ro = new ResizeObserver(() => { if (HEX.data) hexRender(); });
  ro.observe(document.getElementById('hex-main'));
})();

// switchPanelTab already handles hex — fit xterm only for shell
// hexedit command in shell calls hexLoadContent + switchPanelTab('hex')

// ═══════════════════════════════════════════════════════════════════
//  OFFLINE PACK — fetches CDN libs and embeds them into the IDE HTML
// ═══════════════════════════════════════════════════════════════════
async function packOffline() {
  switchPanelTab('terminal');
  termLog('sys', 'Offline Pack: fetching CDN assets...');
  termLog('warn', 'This requires network access to CDNs. May take 30-60s.');

  const cdnAssets = [
    { tag: 'link', url: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css' },
    { tag: 'script', url: 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js' },
    { tag: 'script', url: 'https://cdnjs.cloudflare.com/ajax/libs/BrowserFS/2.0.0/browserfs.min.js' },
    { tag: 'script', url: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js' },
  ];

  let html;
  try {
    const resp = await fetch(location.href);
    if (!resp.ok) throw new Error('HTTP '+resp.status);
    html = await resp.text();
  } catch(e) {
    termLog('error', 'Cannot read this page ('+e.message+'). Host on a local server first.');
    termLog('info', 'python3 -m http.server 8080  or  npx serve .');
    return;
  }

  for (const asset of cdnAssets) {
    const shortName = asset.url.split('/').pop();
    try {
      termLog('sys', '  Fetching: ' + shortName);
      const r = await fetch(asset.url);
      if (!r.ok) throw new Error('HTTP '+r.status);
      const text = await r.text();
      const esc = asset.url.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
      if (asset.tag === 'link') {
        html = html.replace(
          new RegExp('<link[^>]*href=["\']'+esc+'["\'][^>]*/?>','gi'),
          '<style>/* offline: '+shortName+' */\n'+text+'\n</style>'
        );
      } else {
        html = html.replace(
          new RegExp('<script[^>]*src=["\']'+esc+'["\'][^>]*><'+'/script>','gi'),
          '<script>/* offline: '+shortName+' */\n'+text+'\n<'+'/script>'
        );
      }
      termLog('sys', '  Inlined: ' + shortName + ' (' + (text.length/1024).toFixed(0) + ' KB)');
    } catch(e) {
      termLog('warn', '  Failed: ' + shortName + ' — ' + e.message);
    }
  }

  // Also try to fetch and inline Google Fonts
  try {
    termLog('sys', '  Fetching Google Fonts...');
    const fontResp = await fetch('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&family=Rajdhani:wght@500;600;700&display=swap');
    if (fontResp.ok) {
      let fontCss = await fontResp.text();
      // Fetch each woff2 and embed as data URI
      const fontUrls = [...fontCss.matchAll(/url\(([^)]+)\)/g)].map(m=>m[1].replace(/['"]/g,''));
      for (const fu of fontUrls) {
        try {
          const fr = await fetch(fu);
          if (!fr.ok) continue;
          const buf = await fr.arrayBuffer();
          const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
          fontCss = fontCss.replace(fu, 'data:font/woff2;base64,' + b64);
        } catch(e) {}
      }
      html = html.replace(/@import url\([^)]*fonts\.googleapis[^)]*\);?/gi, '');
      html = html.replace('</style>', fontCss + '\n</style>');
      termLog('sys', '  Inlined: Google Fonts');
    }
  } catch(e) { termLog('warn', '  Google Fonts failed: ' + e.message); }

  const blob = new Blob([html], { type: 'text/html' });
  const name = 'void-ide-v16-offline.html';
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  termLog('sys', 'Saved: ' + name + ' (' + (blob.size/1024/1024).toFixed(2) + ' MB)');
  termLog('info', 'Note: Monaco worker scripts still load from CDN. For truly full offline,');
  termLog('info', 'set require.config({ paths: { vs: "./vs" } }) and host Monaco locally.');
}

// ═══════════════════════════════════════════════════════════════════
//  PROXY ENGINE — WebSocket tunnel to companion proxy server
//  Supports: HTTP CONNECT tunnel, SOCKS5, OpenVPN passthrough,
//            WireGuard config passthrough
// ═══════════════════════════════════════════════════════════════════

const PROXY = {
  ws: null,
  mode: 'http',
  connected: false,
  connecting: false,
  pendingReqs: {},   // id → {resolve, reject, url}
  reqId: 0,
  stats: { tx: 0, rx: 0, req: 0, latencies: [] },
  bypass: ['localhost', '127.0.0.1'],
  intercept: 'all',
  _origFetch: window.fetch.bind(window),
  _patchedFetch: false,
};

function proxyLog(level, msg) {
  const el = document.getElementById('proxy-log');
  if (!el) return;
  const ts = new Date().toTimeString().slice(0,8);
  const div = document.createElement('div');
  div.innerHTML = '<span class="plog-ts">' + ts + '</span><span class="plog-' + level + '">' + escH(msg) + '</span>';
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}

function proxyClearLog() {
  const el = document.getElementById('proxy-log');
  if (el) el.innerHTML = '';
}

function proxySetStatus(state, msg) {
  const dot = document.getElementById('proxy-status-dot');
  const txt = document.getElementById('proxy-status-text');
  const btnC = document.getElementById('proxy-btn-connect');
  const btnD = document.getElementById('proxy-btn-disconnect');
  if (!dot) return;
  dot.className = 'proxy-status-dot ' + state;
  if (txt) txt.textContent = msg;
  if (btnC) btnC.style.display = (state === 'connected' || state === 'connecting') ? 'none' : '';
  if (btnD) btnD.style.display = (state === 'connected' || state === 'connecting') ? '' : 'none';
}

function proxySetMode(mode) {
  PROXY.mode = mode;
  ['http','socks5','wsx','wstunnel','ovpn','wg'].forEach(m => {
    const tab = document.getElementById('pmode-' + m);
    // cfg: socks5 shares http panel, so no separate proxy-cfg-socks5
    const cfg = document.getElementById('proxy-cfg-' + m);
    if (tab) tab.classList.toggle('active', m === mode);
    if (cfg) cfg.style.display = m === mode ? '' : 'none';
  });
  // http and socks5 share the proxy-cfg-http panel
  const httpCfg = document.getElementById('proxy-cfg-http');
  if (httpCfg) httpCfg.style.display = (mode === 'http' || mode === 'socks5') ? '' : 'none';
}

function proxyWstPreview() {
  const base = (document.getElementById('proxy-ws-url')?.value || 'ws://localhost:8765').trim();
  const prefix = document.getElementById('proxy-wst-prefix')?.value || 'v1';
  const host = document.getElementById('proxy-wst-host')?.value || 'target-host';
  const port = document.getElementById('proxy-wst-port')?.value || '80';
  const preview = document.getElementById('proxy-wst-url-preview');
  if (preview) preview.textContent = base + '/' + prefix + '/tcp/' + host + '/' + port;
}

function proxyUpdateStats() {
  const fmt = n => n < 1024 ? n + ' B' : n < 1048576 ? (n/1024).toFixed(1) + ' KB' : (n/1048576).toFixed(2) + ' MB';
  const lat = PROXY.stats.latencies.length ? Math.round(PROXY.stats.latencies.reduce((a,b)=>a+b,0)/PROXY.stats.latencies.length) + 'ms' : '—';
  const el = id => document.getElementById(id);
  if (el('proxy-stat-tx')) el('proxy-stat-tx').textContent = fmt(PROXY.stats.tx);
  if (el('proxy-stat-rx')) el('proxy-stat-rx').textContent = fmt(PROXY.stats.rx);
  if (el('proxy-stat-req')) el('proxy-stat-req').textContent = PROXY.stats.req;
  if (el('proxy-stat-lat')) el('proxy-stat-lat').textContent = lat;
}

async function proxyConnect() {
  if (PROXY.connecting || PROXY.connected) return;
  const wsUrlBase = (document.getElementById('proxy-ws-url')?.value || 'ws://localhost:8765').trim();
  const token     = document.getElementById('proxy-token')?.value || '';
  const mode      = PROXY.mode;

  PROXY.bypass = (document.getElementById('proxy-bypass')?.value || '')
    .split('\n').map(s => s.trim()).filter(Boolean);
  PROXY.intercept = document.getElementById('proxy-intercept')?.value || 'all';

  // ── websockify mode (novnc/websockify) ──────────────────────────
  // Protocol: connect with Sec-WebSocket-Protocol: 'binary'|'base64',
  // then stream raw bytes directly — no framing, no JSON.
  // websockify bridges the WS connection to a pre-configured TCP target.
  if (mode === 'wsx') {
    const sub = document.getElementById('proxy-wsx-sub')?.value || 'binary';
    const tgtHost = document.getElementById('proxy-wsx-host')?.value?.trim() || '';
    const tgtPort = document.getElementById('proxy-wsx-port')?.value?.trim() || '80';
    proxySetStatus('connecting', 'Connecting to websockify @ ' + wsUrlBase + '…');
    proxyLog('sys', 'websockify connect → ' + wsUrlBase + ' [sub: ' + sub + ', target: ' + tgtHost + ':' + tgtPort + ']');
    PROXY.connecting = true;
    PROXY._wsxSub = sub;
    PROXY._wsxRxBuf = []; // raw byte chunks received
    try {
      const ws = new WebSocket(wsUrlBase, [sub]);
      ws.binaryType = 'arraybuffer';
      PROXY.ws = ws;
      ws.onopen = () => {
        PROXY.connecting = false;
        PROXY.connected  = true;
        const nego = ws.protocol || sub;
        proxySetStatus('connected', 'websockify ✓ [' + nego + '] → ' + (tgtHost || 'server target') + ':' + tgtPort);
        proxyLog('ok', 'websockify connected ✓  negotiated subprotocol: ' + nego);
        proxyLog('sys', 'Raw TCP stream open. Use proxy.send(bytes) to write, proxy.recv() to read.');
        proxyLog('sys', 'Or use shell: proxy fetch <http-url-via-tunnel>');
        PROXY._wsxEncoder = nego === 'base64'
          ? { enc: b => btoa(String.fromCharCode(...new Uint8Array(b))), dec: s => Uint8Array.from(atob(s), c=>c.charCodeAt(0)).buffer }
          : { enc: b => b, dec: b => b };
      };
      ws.onmessage = (e) => {
        const data = e.data;
        const decoded = PROXY._wsxEncoder ? PROXY._wsxEncoder.dec(data) : data;
        PROXY._wsxRxBuf.push(decoded);
        PROXY.stats.rx += (decoded.byteLength || (decoded.length || 0));
        PROXY.stats.req++;
        proxyUpdateStats();
        // Resolve any pending read
        if (PROXY._wsxReadResolve) {
          const fn = PROXY._wsxReadResolve;
          PROXY._wsxReadResolve = null;
          fn(decoded);
        }
      };
      ws.onerror = () => {
        PROXY.connecting = false;
        proxyLog('err', 'websockify: WebSocket error — is websockify running? Check CORS headers too.');
        proxySetStatus('error', 'websockify error');
      };
      ws.onclose = (e) => {
        PROXY.connecting = false;
        if (PROXY.connected) {
          PROXY.connected = false;
          proxyLog('warn', 'websockify: disconnected (code ' + e.code + ')');
          proxySetStatus('', 'Disconnected');
        }
      };
    } catch(err) {
      PROXY.connecting = false;
      proxyLog('err', 'websockify: ' + err.message);
      proxySetStatus('error', err.message);
    }
    return;
  }

  // ── wstunnel mode (erebe/wstunnel) ─────────────────────────────
  // Protocol: HTTP upgrade to ws://<server>/<prefix>/tcp/<host>/<port>
  // After upgrade: raw binary frames, no framing overhead.
  // Target host:port is encoded in the URL path at connect time.
  if (mode === 'wstunnel') {
    const prefix  = (document.getElementById('proxy-wst-prefix')?.value || 'v1').trim();
    const tgtHost = (document.getElementById('proxy-wst-host')?.value || '').trim();
    const tgtPort = (document.getElementById('proxy-wst-port')?.value || '80').trim();
    const creds   = (document.getElementById('proxy-wst-creds')?.value || '').trim();
    if (!tgtHost) { proxyLog('err', 'wstunnel: target host is required'); return; }
    // Build wstunnel upgrade URL: ws://server/v1/tcp/host/port
    const wsUrl = wsUrlBase.replace(/\/+$/, '') + '/' + prefix + '/tcp/' + tgtHost + '/' + tgtPort;
    const wsOpts = {};
    if (creds) wsOpts.headers = { 'Authorization': 'Basic ' + btoa(creds) };

    proxySetStatus('connecting', 'Connecting via wstunnel…');
    proxyLog('sys', 'wstunnel connect → ' + wsUrl);
    PROXY.connecting = true;
    PROXY._wstRxBuf = [];
    try {
      const ws = new WebSocket(wsUrl);
      ws.binaryType = 'arraybuffer';
      PROXY.ws = ws;
      ws.onopen = () => {
        PROXY.connecting = false;
        PROXY.connected  = true;
        proxySetStatus('connected', 'wstunnel ✓ → ' + tgtHost + ':' + tgtPort);
        proxyLog('ok', 'wstunnel tunnel open ✓  target: ' + tgtHost + ':' + tgtPort);
        proxyLog('sys', 'Raw TCP stream open to ' + tgtHost + ':' + tgtPort);
      };
      ws.onmessage = (e) => {
        PROXY._wstRxBuf.push(e.data);
        PROXY.stats.rx += e.data.byteLength || 0;
        PROXY.stats.req++;
        proxyUpdateStats();
        if (PROXY._wstReadResolve) {
          const fn = PROXY._wstReadResolve;
          PROXY._wstReadResolve = null;
          fn(e.data);
        }
      };
      ws.onerror = () => {
        PROXY.connecting = false;
        proxyLog('err', 'wstunnel: connection error — check server URL and that wstunnel server is running');
        proxySetStatus('error', 'wstunnel error');
      };
      ws.onclose = (e) => {
        PROXY.connecting = false;
        if (PROXY.connected) {
          PROXY.connected = false;
          proxyLog('warn', 'wstunnel: closed (code ' + e.code + ')');
          proxySetStatus('', 'Disconnected');
        }
      };
    } catch(err) {
      PROXY.connecting = false;
      proxyLog('err', 'wstunnel: ' + err.message);
      proxySetStatus('error', err.message);
    }
    return;
  }

  // ── VOID custom JSON protocol (http/socks5/ovpn/wg) ─────────────
  const wsUrl = wsUrlBase;
  proxySetStatus('connecting', 'Connecting to ' + wsUrl + '…');
  proxyLog('sys', 'Connecting → ' + wsUrl + ' [mode: ' + mode + ']');
  PROXY.connecting = true;

  let handshake = { type: 'hello', mode, token, version: '1.0' };
  if (mode === 'ovpn') {
    handshake.ovpn_config = document.getElementById('proxy-ovpn-cfg')?.value || '';
    handshake.username    = document.getElementById('proxy-ovpn-user')?.value || '';
    handshake.password    = document.getElementById('proxy-ovpn-pass')?.value || '';
  }
  if (mode === 'wg') {
    handshake.wg_config = document.getElementById('proxy-wg-cfg')?.value || '';
  }

  try {
    const ws = new WebSocket(wsUrl);
    PROXY.ws = ws;

    ws.onopen = () => {
      proxyLog('ok', 'WebSocket connected — sending handshake');
      ws.send(JSON.stringify(handshake));
    };

    ws.onmessage = (e) => {
      let msg;
      try { msg = JSON.parse(e.data); } catch(_) { proxyLog('warn', 'Non-JSON message: ' + e.data); return; }

      if (msg.type === 'hello_ack') {
        PROXY.connecting = false;
        PROXY.connected  = true;
        proxySetStatus('connected', 'Connected [' + mode.toUpperCase() + '] — ' + (msg.server_info || wsUrl));
        proxyLog('ok', 'Tunnel established ✓  server: ' + (msg.server_info || 'void-proxy-server'));
        if (msg.ip) proxyLog('ok', 'Tunnel IP: ' + msg.ip);
        if (PROXY.intercept !== 'manual') proxyPatchFetch();
        return;
      }

      if (msg.type === 'error') {
        proxyLog('err', 'Server error: ' + msg.message);
        if (!PROXY.connected) {
          PROXY.connecting = false;
          proxySetStatus('error', 'Error: ' + msg.message);
        }
        return;
      }

      if (msg.type === 'resp' && msg.id) {
        const pending = PROXY.pendingReqs[msg.id];
        if (!pending) return;
        delete PROXY.pendingReqs[msg.id];
        const latency = Date.now() - pending.t0;
        PROXY.stats.latencies.push(latency);
        if (PROXY.stats.latencies.length > 50) PROXY.stats.latencies.shift();
        PROXY.stats.rx += msg.body ? msg.body.length : 0;
        PROXY.stats.req++;
        proxyUpdateStats();
        proxyLog('rx', '[' + msg.status + '] ' + pending.url + ' (' + latency + 'ms)');
        if (msg.error) { pending.reject(new TypeError(msg.error)); return; }
        const body = msg.base64 ? Uint8Array.from(atob(msg.body), c => c.charCodeAt(0)).buffer : (msg.body || '');
        const resp = new Response(body, { status: msg.status || 200, headers: { 'Content-Type': msg.mime || 'text/plain' } });
        pending.resolve(resp);
        return;
      }

      if (msg.type === 'log') { proxyLog(msg.level || 'sys', msg.message); return; }
      if (msg.type === 'stats') { if (msg.tx) PROXY.stats.tx += msg.tx; proxyUpdateStats(); return; }
    };

    ws.onerror = (e) => {
      PROXY.connecting = false;
      proxyLog('err', 'WebSocket error — is the proxy server running?');
      proxySetStatus('error', 'Connection failed');
    };

    ws.onclose = (e) => {
      PROXY.connecting = false;
      if (PROXY.connected) {
        PROXY.connected = false;
        proxyLog('warn', 'Disconnected (code ' + e.code + ')' + (e.reason ? ': ' + e.reason : ''));
        proxySetStatus('', 'Disconnected');
        proxyUnpatchFetch();
      }
    };

  } catch(err) {
    PROXY.connecting = false;
    proxyLog('err', 'Failed to create WebSocket: ' + err.message);
    proxySetStatus('error', 'Error: ' + err.message);
  }
}

function proxyDisconnect() {
  if (PROXY.ws) {
    try { PROXY.ws.send(JSON.stringify({ type: 'bye' })); } catch(_) {}
    PROXY.ws.close(1000, 'user disconnect');
    PROXY.ws = null;
  }
  PROXY.connected = false;
  PROXY.connecting = false;
  proxyUnpatchFetch();
  proxySetStatus('', 'Disconnected');
  proxyLog('sys', 'Disconnected by user.');
}

async function proxyTest() {
  if (!PROXY.connected) { proxyLog('warn', 'Not connected — connect first'); return; }

  // websockify/wstunnel: send a raw HTTP GET over the TCP stream
  if (PROXY.mode === 'wsx' || PROXY.mode === 'wstunnel') {
    proxyLog('sys', 'Testing raw stream — sending HTTP GET / …');
    try {
      const t0 = Date.now();
      const resp = await PROXY.httpGet('/');
      const latency = Date.now() - t0;
      const statusLine = resp.split('\r\n')[0] || resp.slice(0, 80);
      proxyLog('ok', 'Stream test OK ✓  ' + statusLine + '  (' + latency + 'ms)');
    } catch(e) {
      proxyLog('err', 'Stream test failed: ' + e.message);
    }
    return;
  }

  // VOID JSON protocol: fetch via WS tunnel
  proxyLog('sys', 'Testing tunnel — fetching https://api.ipify.org?format=json …');
  try {
    const t0 = Date.now();
    const resp = await proxyFetchViaWS('https://api.ipify.org?format=json', {});
    const text = await resp.text();
    const latency = Date.now() - t0;
    proxyLog('ok', 'Tunnel test OK ✓  response: ' + text + '  (' + latency + 'ms)');
  } catch(e) {
    proxyLog('err', 'Tunnel test failed: ' + e.message);
  }
}

// Send a fetch request through the WS tunnel
function proxyFetchViaWS(url, opts) {
  return new Promise((resolve, reject) => {
    if (!PROXY.ws || PROXY.ws.readyState !== WebSocket.OPEN) {
      reject(new TypeError('Proxy not connected'));
      return;
    }
    const id = ++PROXY.reqId;
    PROXY.pendingReqs[id] = { resolve, reject, url, t0: Date.now() };
    const payload = {
      type: 'req', id,
      method: opts.method || 'GET',
      url,
      headers: opts.headers || {},
      body: opts.body || null,
    };
    const str = JSON.stringify(payload);
    PROXY.stats.tx += str.length;
    proxyUpdateStats();
    proxyLog('tx', (opts.method || 'GET') + ' ' + url);
    PROXY.ws.send(str);
    // Timeout after 30s
    setTimeout(() => {
      if (PROXY.pendingReqs[id]) {
        delete PROXY.pendingReqs[id];
        reject(new TypeError('Proxy request timed out: ' + url));
      }
    }, 30000);
  });
}

function proxyBypassCheck(url) {
  try {
    const host = new URL(url).hostname;
    return PROXY.bypass.some(b => {
      if (b.startsWith('*.')) return host.endsWith(b.slice(1));
      return host === b;
    });
  } catch(_) { return false; }
}

function proxyPatchFetch() {
  if (PROXY._patchedFetch) return;
  PROXY._patchedFetch = true;
  const origFetch = PROXY._origFetch;
  window.fetch = async function(input, init) {
    const url = typeof input === 'string' ? input : (input?.url || String(input));
    // Only intercept http/https — let VFS and blob pass through
    if (!/^https?:/.test(url)) return origFetch(input, init);
    if (PROXY.intercept === 'external' && /^https?:\/\/localhost|127\.0\.0\.1/.test(url)) return origFetch(input, init);
    if (proxyBypassCheck(url)) return origFetch(input, init);
    if (!PROXY.connected) return origFetch(input, init);
    return proxyFetchViaWS(url, init || {});
  };
  proxyLog('sys', 'fetch() patched — external requests routed via tunnel');
}

function proxyUnpatchFetch() {
  if (!PROXY._patchedFetch) return;
  PROXY._patchedFetch = false;
  window.fetch = PROXY._origFetch;
  proxyLog('sys', 'fetch() restored to native');
}

// Show the companion server source code in a new file
async function proxyShowServerCode() {
  const code = `#!/usr/bin/env node
// void-proxy-server — companion WebSocket proxy server for VOID IDE
// Usage: node void-proxy-server.js [port]
// or:    npx void-proxy-server
//
// Supports modes: http (HTTP CONNECT tunnel), socks5, ovpn (spawns openvpn), wg (spawns wg-quick)

const http    = require('http');
const https   = require('https');
const net     = require('net');
const { WebSocketServer } = require('ws');
const { spawn, exec } = require('child_process');
const PORT = process.argv[2] || 8765;

const wss = new WebSocketServer({ port: PORT });
console.log('[void-proxy] listening on ws://localhost:' + PORT);

wss.on('connection', (ws, req) => {
  const remote = req.socket.remoteAddress;
  console.log('[void-proxy] client connected:', remote);
  let mode = 'http', ovpnProc = null, wgIface = null;

  ws.on('message', async (data) => {
    let msg;
    try { msg = JSON.parse(data); } catch(e) { return; }

    // ── Handshake ──────────────────────────────────────────────────
    if (msg.type === 'hello') {
      mode = msg.mode || 'http';
      console.log('[void-proxy] mode:', mode);

      if (mode === 'ovpn') {
        // Write config and spawn openvpn
        const fs = require('fs'), os = require('os'), path = require('path');
        const cfgPath = path.join(os.tmpdir(), 'void-ovpn-' + Date.now() + '.ovpn');
        fs.writeFileSync(cfgPath, msg.ovpn_config || '');
        const args = ['--config', cfgPath, '--daemon', '--log', '/tmp/void-ovpn.log'];
        if (msg.username) args.push('--auth-user-pass', '/dev/stdin');
        ovpnProc = spawn('openvpn', args);
        ovpnProc.on('error', e => ws.send(JSON.stringify({ type:'error', message:'openvpn: ' + e.message })));
        setTimeout(() => {
          ws.send(JSON.stringify({ type:'hello_ack', server_info:'void-proxy+openvpn', mode }));
        }, 2000);
        return;
      }

      if (mode === 'wg') {
        // Write wg config and bring up interface
        const fs = require('fs'), os = require('os'), path = require('path');
        wgIface = 'void-wg0';
        const cfgPath = '/etc/wireguard/' + wgIface + '.conf';
        try {
          fs.writeFileSync(cfgPath, msg.wg_config || '');
          exec('wg-quick up ' + wgIface, (err, stdout, stderr) => {
            if (err) { ws.send(JSON.stringify({ type:'error', message:'wg-quick: ' + stderr })); return; }
            ws.send(JSON.stringify({ type:'hello_ack', server_info:'void-proxy+wireguard', mode }));
          });
        } catch(e) { ws.send(JSON.stringify({ type:'error', message:e.message })); }
        return;
      }

      // http / socks5 — no extra setup needed
      ws.send(JSON.stringify({ type:'hello_ack', server_info:'void-proxy-server/1.0', mode }));
      return;
    }

    // ── Proxied request ────────────────────────────────────────────
    if (msg.type === 'req') {
      const { id, url, method, headers, body } = msg;
      try {
        const lib = url.startsWith('https') ? https : http;
        const reqOpts = { method: method || 'GET', headers: headers || {} };
        const proxyReq = lib.request(url, reqOpts, (res) => {
          let chunks = [];
          res.on('data', c => chunks.push(c));
          res.on('end', () => {
            const buf = Buffer.concat(chunks);
            const mime = res.headers['content-type'] || 'application/octet-stream';
            const isText = /^text|json|xml|javascript|svg/.test(mime);
            if (isText) {
              ws.send(JSON.stringify({ type:'resp', id, status:res.statusCode, mime, body:buf.toString('utf8') }));
            } else {
              ws.send(JSON.stringify({ type:'resp', id, status:res.statusCode, mime, body:buf.toString('base64'), base64:true }));
            }
          });
        });
        proxyReq.on('error', e => ws.send(JSON.stringify({ type:'resp', id, error:e.message })));
        if (body) proxyReq.write(body);
        proxyReq.end();
      } catch(e) {
        ws.send(JSON.stringify({ type:'resp', id, error:e.message }));
      }
      return;
    }

    if (msg.type === 'bye') {
      if (wgIface) exec('wg-quick down ' + wgIface);
      if (ovpnProc) ovpnProc.kill();
      ws.close();
    }
  });

  ws.on('close', () => {
    console.log('[void-proxy] client disconnected');
    if (wgIface) exec('wg-quick down ' + wgIface);
    if (ovpnProc) ovpnProc.kill();
  });
});
`;
  const path = '/void-proxy-server.js';
  await fsWriteFileSafe(path, code);
  await openFile(path);
  switchPanelTab('shell');
  await refreshTree();
  proxyLog('sys', 'Server source written to ' + path);
  termLog('sys', 'void-proxy-server.js written → run: node void-proxy-server.js');
}

// ── Raw stream helpers (websockify / wstunnel) ───────────────────
// Expose PROXY.send(data) and PROXY.recv() for node scripts
PROXY.send = function(data) {
  if (!PROXY.ws || !PROXY.connected) { proxyLog('err', 'proxy.send: not connected'); return; }
  if (PROXY.mode === 'wsx' && PROXY._wsxEncoder) {
    PROXY.ws.send(PROXY._wsxEncoder.enc(data));
  } else {
    PROXY.ws.send(data);
  }
  PROXY.stats.tx += data.byteLength || data.length || 0;
  proxyUpdateStats();
};

PROXY.recv = function(timeoutMs) {
  timeoutMs = timeoutMs || 10000;
  return new Promise((resolve, reject) => {
    // Check buffer first
    const buf = PROXY.mode === 'wsx' ? PROXY._wsxRxBuf : PROXY._wstRxBuf;
    if (buf && buf.length) { resolve(buf.shift()); return; }
    const resolveKey = PROXY.mode === 'wsx' ? '_wsxReadResolve' : '_wstReadResolve';
    PROXY[resolveKey] = resolve;
    setTimeout(() => {
      if (PROXY[resolveKey] === resolve) {
        PROXY[resolveKey] = null;
        reject(new Error('proxy.recv: timeout after ' + timeoutMs + 'ms'));
      }
    }, timeoutMs);
  });
};

// Convenience: send an HTTP request over the raw TCP stream (websockify/wstunnel)
// Returns response body as text
PROXY.httpGet = async function(path, headers) {
  if (!PROXY.connected) throw new Error('proxy.httpGet: not connected');
  const host = document.getElementById('proxy-wsx-host')?.value || document.getElementById('proxy-wst-host')?.value || 'localhost';
  const req = 'GET ' + path + ' HTTP/1.1\r\nHost: ' + host + '\r\nConnection: close\r\n' + (headers || '') + '\r\n';
  const enc = new TextEncoder();
  PROXY.send(enc.encode(req).buffer);
  // Collect response chunks
  let response = '';
  try {
    while (true) {
      const chunk = await PROXY.recv(5000);
      const dec = new TextDecoder();
      const text = dec.decode(chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : chunk);
      response += text;
      if (response.includes('\r\n0\r\n') || response.length > 1024*1024) break;
    }
  } catch(e) { /* timeout = end of response */ }
  return response;
};

// ── Shell: proxy command ──────────────────────────────────────────
// Registered in zshExecSingle via the cases below
boot().catch(e => {
  console.error('Boot failed:', e);
  document.getElementById('terminal-output').innerHTML =
    `<div class="term-line"><span class="term-tag error">ERROR</span><span class="term-msg error">Boot failed: ${e.message}. Try refreshing.</span></div>`;
});
</script>
</body>
</html>
